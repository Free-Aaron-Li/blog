<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="第十二章 动态内存 前言 在此之前，我们使用的程序中对象都有着严格定义的生存期：\n全局对象，在程序启动时分配，在程序结束时销毁。 局部自动对象，当进入定义所在程序时创建，在离开块时销毁。 局部static对象，在第一次使用前分配，在程序结束时销毁。 显然这存在限制，为此C++支持动态分配对象。动态分配对象的生存期与它们在哪里创建无关，只有当显式地被释放时，这些对象才会被销毁。\n">
<title>C&#43;&#43; 基础： 第十二章 动态内存</title>

<link rel='canonical' href='https://Free-Aaron-Li.github.io/p/c-%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/'>

<link rel="stylesheet" href="/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css"><meta property='og:title' content="C++ 基础： 第十二章 动态内存">
<meta property='og:description' content="第十二章 动态内存 前言 在此之前，我们使用的程序中对象都有着严格定义的生存期：\n全局对象，在程序启动时分配，在程序结束时销毁。 局部自动对象，当进入定义所在程序时创建，在离开块时销毁。 局部static对象，在第一次使用前分配，在程序结束时销毁。 显然这存在限制，为此C++支持动态分配对象。动态分配对象的生存期与它们在哪里创建无关，只有当显式地被释放时，这些对象才会被销毁。\n">
<meta property='og:url' content='https://Free-Aaron-Li.github.io/p/c-%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/'>
<meta property='og:site_name' content='亚伦的博客'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='C&#43;&#43;' /><meta property='article:published_time' content='2025-04-06T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2025-04-06T00:00:00&#43;00:00'/><meta property='og:image' content='https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg' />
<meta name="twitter:title" content="C++ 基础： 第十二章 动态内存">
<meta name="twitter:description" content="第十二章 动态内存 前言 在此之前，我们使用的程序中对象都有着严格定义的生存期：\n全局对象，在程序启动时分配，在程序结束时销毁。 局部自动对象，当进入定义所在程序时创建，在离开块时销毁。 局部static对象，在第一次使用前分配，在程序结束时销毁。 显然这存在限制，为此C++支持动态分配对象。动态分配对象的生存期与它们在哪里创建无关，只有当显式地被释放时，这些对象才会被销毁。\n"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg' />
    <link rel="shortcut icon" href="/favicon.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu_d0557925549c907f.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">😁</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">亚伦的博客</a></h1>
            <h2 class="site-description">开发、学习及趣事</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://space.bilibili.com/630183635'
                        target="_blank"
                        title="Bilibili"
                        rel="me"
                    >
                        
                        
                            <?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1743928299453" class="icon" viewBox="0 0 1129 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1861" xmlns:xlink="http://www.w3.org/1999/xlink" width="282.25" height="256"><path d="M234.909 9.656a80.468 80.468 0 0 1 68.398 0 167.374 167.374 0 0 1 41.843 30.578l160.937 140.82h115.07l160.936-140.82a168.983 168.983 0 0 1 41.843-30.578A80.468 80.468 0 0 1 930.96 76.445a80.468 80.468 0 0 1-17.703 53.914 449.818 449.818 0 0 1-35.406 32.187 232.553 232.553 0 0 1-22.531 18.508h100.585a170.593 170.593 0 0 1 118.289 53.109 171.397 171.397 0 0 1 53.914 118.288v462.693a325.897 325.897 0 0 1-4.024 70.007 178.64 178.64 0 0 1-80.468 112.656 173.007 173.007 0 0 1-92.539 25.75h-738.7a341.186 341.186 0 0 1-72.421-4.024A177.835 177.835 0 0 1 28.91 939.065a172.202 172.202 0 0 1-27.36-92.539V388.662a360.498 360.498 0 0 1 0-66.789A177.03 177.03 0 0 1 162.487 178.64h105.414c-16.899-12.07-31.383-26.555-46.672-39.43a80.468 80.468 0 0 1-25.75-65.984 80.468 80.468 0 0 1 39.43-63.57M216.4 321.873a80.468 80.468 0 0 0-63.57 57.937 108.632 108.632 0 0 0 0 30.578v380.615a80.468 80.468 0 0 0 55.523 80.469 106.218 106.218 0 0 0 34.601 5.632h654.208a80.468 80.468 0 0 0 76.444-47.476 112.656 112.656 0 0 0 8.047-53.109v-354.06a135.187 135.187 0 0 0 0-38.625 80.468 80.468 0 0 0-52.304-54.719 129.554 129.554 0 0 0-49.89-7.242H254.22a268.764 268.764 0 0 0-37.82 0z m0 0" fill="#20B0E3" p-id="1862"></path><path d="M348.369 447.404a80.468 80.468 0 0 1 55.523 18.507 80.468 80.468 0 0 1 28.164 59.547v80.468a80.468 80.468 0 0 1-16.094 51.5 80.468 80.468 0 0 1-131.968-9.656 104.609 104.609 0 0 1-10.46-54.719v-80.468a80.468 80.468 0 0 1 70.007-67.593z m416.02 0a80.468 80.468 0 0 1 86.102 75.64v80.468a94.148 94.148 0 0 1-12.07 53.11 80.468 80.468 0 0 1-132.773 0 95.757 95.757 0 0 1-12.875-57.133V519.02a80.468 80.468 0 0 1 70.007-70.812z m0 0" fill="#20B0E3" p-id="1863"></path></svg>
                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://github.com/Free-Aaron-Li/'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1743928354280" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2983" xmlns:xlink="http://www.w3.org/1999/xlink" width="256" height="256"><path d="M512 0C229.283787 0 0.142041 234.942803 0.142041 524.867683c0 231.829001 146.647305 428.553077 350.068189 497.952484 25.592898 4.819996 34.976961-11.38884 34.976961-25.294314 0-12.45521-0.469203-45.470049-0.725133-89.276559-142.381822 31.735193-172.453477-70.380469-172.453477-70.380469-23.246882-60.569859-56.816233-76.693384-56.816234-76.693385-46.493765-32.58829 3.540351-31.948468 3.540351-31.948467 51.356415 3.71097 78.356923 54.086324 78.356923 54.086324 45.683323 80.19108 119.817417 57.072162 148.993321 43.593236 4.649376-33.91059 17.915029-57.029508 32.50298-70.167195-113.675122-13.222997-233.151301-58.223843-233.1513-259.341366 0-57.285437 19.919806-104.163095 52.678715-140.846248-5.246544-13.265652-22.820334-66.626844 4.990615-138.884127 0 0 42.996069-14.076094 140.760939 53.787741 40.863327-11.644769 84.627183-17.445825 128.177764-17.6591 43.465272 0.213274 87.271782 6.014331 128.135109 17.6591 97.679561-67.906489 140.59032-53.787741 140.59032-53.787741 27.938914 72.257282 10.407779 125.618474 5.118579 138.884127 32.844219 36.683154 52.593405 83.560812 52.593405 140.846248 0 201.586726-119.646798 245.990404-233.663158 258.957473 18.341577 16.208835 34.721032 48.199958 34.721032 97.210357 0 70.167195-0.639822 126.7275-0.639823 143.960051 0 14.033439 9.213443 30.370239 35.190235 25.209005 203.250265-69.527373 349.769606-266.123484 349.769605-497.867175C1023.857959 234.942803 794.673558 0 512 0" fill="#3E75C3" p-id="2984"></path></svg>
                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E9%93%BE%E6%8E%A5/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>链接</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">
                    
                        <li id="i18n-switch">  
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 5h7" />
  <path d="M9 3v2c0 4.418 -2.239 8 -5 8" />
  <path d="M5 9c-.003 2.144 2.952 3.908 6.7 4" />
  <path d="M12 20l4 -9l4 9" />
  <path d="M19.1 18h-6.2" />
</svg>



                            <select name="language" title="language" onchange="window.location.href = this.selectedOptions[0].value">
                                
                                    <option value="https://Free-Aaron-Li.github.io/en/" >English</option>
                                
                                    <option value="https://Free-Aaron-Li.github.io/" selected>中文</option>
                                
                            </select>
                        </li>
                    
                

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#前言">前言</a></li>
    <li><a href="#动态内存和智能指针">动态内存和智能指针</a>
      <ol>
        <li><a href="#shared_ptr类">shared_ptr类</a>
          <ol>
            <li><a href="#make_shared函数">make_shared函数</a></li>
            <li><a href="#shared_ptr的拷贝和赋值">shared_ptr的拷贝和赋值</a></li>
            <li><a href="#shared_ptr自动销毁所管理的对象">shared_ptr自动销毁所管理的对象</a></li>
            <li><a href="#使用了动态生存期的资源的类">使用了动态生存期的资源的类</a></li>
          </ol>
        </li>
        <li><a href="#直接管理内存">直接管理内存</a>
          <ol>
            <li><a href="#动态分配的const对象">动态分配的const对象</a></li>
            <li><a href="#内存耗尽">内存耗尽</a></li>
            <li><a href="#释放动态内存">释放动态内存</a></li>
          </ol>
        </li>
        <li><a href="#shared_ptr和new的结合使用">shared_ptr和new的结合使用</a>
          <ol>
            <li><a href="#不要混合使用普通指针和智能指针">不要混合使用普通指针和智能指针</a></li>
            <li><a href="#不要使用get初始化另一个智能指针或为智能指针赋值">不要使用get初始化另一个智能指针或为智能指针赋值</a></li>
            <li><a href="#其他shared_ptr操作">其他shared_ptr操作</a></li>
          </ol>
        </li>
        <li><a href="#智能指针和异常">智能指针和异常</a>
          <ol>
            <li><a href="#智能指针和哑类">智能指针和哑类</a></li>
          </ol>
        </li>
        <li><a href="#unique_ptr">unique_ptr</a>
          <ol>
            <li><a href="#向unique_ptr传递删除器">向unique_ptr传递删除器</a></li>
          </ol>
        </li>
        <li><a href="#weak_ptr">weak_ptr</a></li>
      </ol>
    </li>
    <li><a href="#122-动态数组">12.2 动态数组</a>
      <ol>
        <li><a href="#new和数组">new和数组</a>
          <ol>
            <li><a href="#智能指针和动态数组">智能指针和动态数组</a></li>
          </ol>
        </li>
        <li><a href="#allocator类">allocator类</a></li>
      </ol>
    </li>
    <li><a href="#123-使用标准库文本查询程序">12.3 使用标准库：文本查询程序</a>
      <ol>
        <li><a href="#文本查询程序的设计">文本查询程序的设计</a></li>
      </ol>
    </li>
    <li><a href="#总结">总结</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/c-%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/">
                
                    <img src="https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg" loading="lazy" alt="Featured image of post C&#43;&#43; 基础： 第十二章 动态内存" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/c&#43;&#43;-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" >
                C&#43;&#43; 学习笔记
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/c-%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/">C&#43;&#43; 基础： 第十二章 动态内存</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Apr 06, 2025</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 22 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="第十二章-动态内存">第十二章 动态内存
</h1><h2 id="前言">前言
</h2><p>在此之前，我们使用的程序中对象都有着严格定义的生存期：</p>
<ul>
<li>全局对象，在程序启动时分配，在程序结束时销毁。</li>
<li>局部自动对象，当进入定义所在程序时创建，在离开块时销毁。</li>
<li>局部static对象，在第一次使用前分配，在程序结束时销毁。</li>
</ul>
<p>显然这存在限制，为此C++支持动态<strong>分配对象</strong>。动态分配对象的生存期与它们在哪里创建无关，只有当显式地被释放时，这些对象才会被销毁。</p>
<p><strong>动态对象的正确释放是编程中极其容易出错的地方</strong>。那么为了更安全释放，标准库定义了两个<strong>智能指针</strong>来管理动态分配的对象。当一个对象应该被释放时，指向它的智能指针可以确保自动地释放它。</p>
<blockquote>
<p>静态内存：局部static对象、类static数据成员以及定义在任何函数之外的变量</p>
<p>栈内存：定义在函数内的非static对象</p>
<p>分配在静态或栈内存的对象由编译器自动创建和销毁。除了静态内存和栈内存，每个程序还拥有一个内存池。称为<strong>自由空间</strong>或<strong>堆</strong>，程序用堆来存储<strong>动态分配</strong>（dynamically allocate）的对象——即那些在程序运行时分配的对象。</p></blockquote>
<h2 id="动态内存和智能指针">动态内存和智能指针
</h2><p>在C++中，动态内存的管理通过一对运算符完成：</p>
<ul>
<li><strong>new</strong>，在动态内存中为对象分配空间并返回一个指向对象的指针，可以选择对对象初始化</li>
<li><strong>delete</strong>，接受一个动态对象的指针，销毁该指针指向的对象，并释放与之关联的内存</li>
</ul>
<p>但是动态内存的使用容易出问题，难以确保在正确时间释放内存，那么就可能出现“内存泄露”、“引用非法指针”等。对此，标准库引入两种智能指针（smart pointer）：</p>
<ul>
<li><strong>shared_ptr</strong>，允许多个指针指向同一个对象</li>
<li><strong>unique_ptr</strong>，独占所指向的对象</li>
</ul>
<blockquote>
<p>智能指针的行为类似常规指针，区别在于智能指针负责自动释放所指向的对象。上述的两种指针区别在于管理底层指针的方式不同。</p>
<p>同时，标准库还定义了一个<strong>weak_ptr</strong>的伴随类，其是一个弱引用，指向shared_ptr所管理的对象。三者均定义在<code>memory</code>头文件中。</p></blockquote>
<h3 id="shared_ptr类">shared_ptr类
</h3><p>智能指针为模板，在创建时需要提供额外的信息表明指针可以指向的类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">shard_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p_1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">shard_ptr</span><span class="o">&lt;</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">p_2</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th style="text-align: center">shared_ptr和unique_ptr都支持的操作</th>
          <th style="text-align: center">解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">shared_ptr&lt;T&gt; sp<br/>unique_ptr&lt;T&gt; up</td>
          <td style="text-align: center">空智能指针，可以指向类型为T的对象</td>
      </tr>
      <tr>
          <td style="text-align: center">p</td>
          <td style="text-align: center">将p用作一个条件判断，若p指向一个对象，则为true</td>
      </tr>
      <tr>
          <td style="text-align: center">*p</td>
          <td style="text-align: center">解引用p,获得它指向的对象</td>
      </tr>
      <tr>
          <td style="text-align: center">p-&gt;member</td>
          <td style="text-align: center">等价于(*p).member</td>
      </tr>
      <tr>
          <td style="text-align: center">p.get()</td>
          <td style="text-align: center">返回p中保存的指针。要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了</td>
      </tr>
      <tr>
          <td style="text-align: center">swap(p,q)<br/>p.swap(q)</td>
          <td style="text-align: center">交换p和q中的指针</td>
      </tr>
  </tbody>
</table></div>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th style="text-align: center">shard_ptr独有的操作</th>
          <th style="text-align: center">解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">make_shared&lt;T&gt;(<i>args</i>)</td>
          <td style="text-align: center">返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用<i>args</i>初始化此对象</td>
      </tr>
      <tr>
          <td style="text-align: center">shared_ptr&lt;T&gt;p(q)</td>
          <td style="text-align: center">p是shared_ptr q的拷贝。此操作会递增q中的计数器。q中的指针必须能转化为T*</td>
      </tr>
      <tr>
          <td style="text-align: center">p=q</td>
          <td style="text-align: center">p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0,则将其管理的原内存释放</td>
      </tr>
      <tr>
          <td style="text-align: center">p.unique()</td>
          <td style="text-align: center">若p.use_count()为1,返回true,否则返回false</td>
      </tr>
      <tr>
          <td style="text-align: center">p.use_count()</td>
          <td style="text-align: center">返回与p共享对象的智能指针数量；可能很慢，主要用于调试</td>
      </tr>
  </tbody>
</table></div>
<h4 id="make_shared函数">make_shared函数
</h4><p><strong>最安全的分配和使用动态内存</strong>的方法是调用make_shared标准库函数，此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p_3</span><span class="o">=</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">// 指向一个值为42的int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p_4</span><span class="o">=</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="sc">&#39;9&#39;</span><span class="p">);</span> <span class="c1">// 指向一个值为“99”的string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p_5</span><span class="o">=</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// 指向一个值初始化的int
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="shared_ptr的拷贝和赋值">shared_ptr的拷贝和赋值
</h4><p>当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">p</span><span class="o">=</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">// p指向的对象只有p一个引用者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="nf">q</span><span class="p">(</span><span class="n">P</span><span class="p">);</span> <span class="c1">// p和q指向相同对象，此对象有两个引用者
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为<strong>引用计数</strong>（reference count）。无论何时拷贝一个shared_ptr,计数器都会递增。例如，当用一个shared_ptr初始化另一个shared_ptr,或将它作为参数传递给一个函数以及作为函数的返回值时，它所关联的计数器就会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域）时，计数器就会递减。</p>
<p>当一个shared_ptr的计数器变为0,它就会自动释放自己所管理的对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">// p指向的int只有一个引用者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span> <span class="c1">// 给p赋值，令它指向另一个地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	   <span class="c1">// 递增q指向的对象的引用计数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	   <span class="c1">// 递减p原来指向的对象的引用计数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	   <span class="c1">// p原来指向的对象已经没有引用者，会自动释放
</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>到底是用一个计数器还是其他数据结构来记录有多少指针共享对象，完全由标准库的具体实现来决定。关键是智能指针类能记录有多少个shared_ptr指向相同的对象，并能在恰当的时候自动释放对象。</p></blockquote>
<h4 id="shared_ptr自动销毁所管理的对象">shared_ptr自动销毁所管理的对象
</h4><p>shared_ptr类会通过<strong>析构函数</strong>（destructor）完成销毁工作。shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数为0,shared_ptr的析构函数就会销毁对象，并释放它所占用的内存。</p>
<blockquote>
<p>如果将shared_ptr存放在一个容器中，而后不再需要某些元素，而只使用其中的一部分，要记得用erase删除不再需要的那些元素</p></blockquote>
<h4 id="使用了动态生存期的资源的类">使用了动态生存期的资源的类
</h4><p>程序使用动态内存出于以下三种原因之一：</p>
<ul>
<li>程序不知道需要多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个对象间共享数据</li>
</ul>
<h3 id="直接管理内存">直接管理内存
</h3><p>在前面我们知道C++定义了new和delete进行动态内存的分配和释放。相对于智能指针，这两个运算符管理非常容器出错。自己直接管理内存的类与使用智能指针的类不同，它们不能依赖于类对象拷贝、赋值和销毁操作的任何默认定义，因此，使用智能指针的程序更容易编写和调试。</p>
<p>常见的new：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span><span class="o">*</span> <span class="n">pi</span> <span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">// pi指向一个动态分配的、未初始化的无名对象
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是为定义的，而类类型对象将用默认构造函数进行初始化。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">string</span> <span class="o">*</span><span class="n">p_s</span><span class="o">=</span><span class="k">new</span> <span class="n">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">pi</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>默认初始化</p>
<p>如果定义变量时没有指定初值，则变量被默认初始化（default initialized），此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，同时<strong>定义变量</strong>的位置也会对此有影响。</p>
<p>如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0；定义在函数体内部的内置类型变量将<strong>不被初始化</strong>。一个未被初始化的内置类型变量的值是未定义的。如果试图拷贝或以其他形式访问此类值将引发错误。</p></blockquote>
<p>对动态分配的对象，我们可以采用直接初始化、传统的构造方式、列表初始化、值初始化的方式进行初始化。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span><span class="o">*</span> <span class="n">p_s0</span><span class="o">=</span><span class="k">new</span> <span class="n">string</span><span class="p">;</span> <span class="c1">// 默认初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="n">p_i1</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span> <span class="c1">// 直接初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="n">p_s1</span><span class="o">=</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="s">&#34;1&#34;</span><span class="p">);</span> <span class="c1">// 传统的构造方式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">p_v1</span><span class="o">=</span><span class="k">new</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span> <span class="c1">// 列表初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span><span class="o">*</span> <span class="n">p_s2</span><span class="o">=</span><span class="k">new</span> <span class="n">string</span><span class="p">();</span> <span class="c1">// 值初始化 
</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>对于定义了自己的构造函数的类类型（如string）来说，值初始化是没有意义的，但是对内置类型对象来说则有很大的意义：值初始化的的内置类型对象有着良好的值，而默认初始化的对象的值则是未定义的。</p>
<p>同样，对于类中依赖于编译器合成的默认构造函数的内置类型成员，如果它们未在类内被初始化，那么它们的值也是未定义的。</p>
<p>所以，出于与变量初始化相同的原因，<strong>对动态分配的对象进行初始化通常是个好主意</strong></p></blockquote>
<p>这里就有一个“骚操作”：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">p_1</span> <span class="o">=</span> <span class="k">new</span> <span class="k">auto</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span> <span class="c1">// 从obj那里推断想要分配的对象的类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">p_2</span> <span class="o">=</span> <span class="k">new</span> <span class="k">auto</span><span class="p">{</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">};</span> <span class="c1">// 错误，括号中只能有单个初始化器
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="动态分配的const对象">动态分配的const对象
</h4><p>类似其他任何const对象，一个动态分配的const对象必须进行初始化。对于一个定义了默认构造函数的类类型，其const动态对象可以隐式初始化。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">P_c_i</span> <span class="o">=</span> <span class="k">new</span> <span class="k">const</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">string</span><span class="o">*</span> <span class="n">p_c_s</span> <span class="o">=</span> <span class="k">new</span> <span class="k">const</span> <span class="n">string</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="内存耗尽">内存耗尽
</h4><p>如果自由空间（堆空间）资源耗尽，new表达式将会失败，并抛出<code>bad_alloc</code>异常。可以改变new方式阻止其抛出异常：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">p_1</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="n">nothrow</span><span class="p">)</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">// 如果分配失败，new返回一个空指针
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对上述代码中形式的new称为<strong>定位new</strong>（placement new）。定位new表达式允许我们向new传递额外的参数。上述我们向new传递一个由标准库定义的nothrow对象，告诉它不能抛出异常。bad_alloc和nothrow都定义在new头文件中。</p>
<h4 id="释放动态内存">释放动态内存
</h4><p>传递给delete的指针必须指向动态分配的内存，或者是一个空指针。释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为都是未定义的。</p>
<p>虽然一个const对象的值不能被改变，但是其本身是可以被销毁的。</p>
<blockquote>
<p>由内置指针（而不是智能指针）管理的动态内存在会被显式释放前一直都会存在</p>
<p>所以，动态内存的管理非常容易出错。</p>
<p>使用new和delete管理动态内存存在三个常见问题：</p>
<ol>
<li>忘记delete内存。忘记释放动态内存会导致“内存泄露”问题，因为这种内存永远不可能被归还给自由空间。查找内存泄露错误是非常困难的，因为通常应用程序运行很长时间后，真正耗尽内存后，才能检测到这种错误。</li>
<li>使用已经释放掉的对象。即“空指针异常”。</li>
<li>同一块内存被释放两次。这种情况下自由空间可能被破坏掉。</li>
</ol>
<p>相对于查找和修正这些错误来说，制造出错误简单很多。</p></blockquote>
<p>当delete一个指针后，其指针值无效，但是机器上指针仍然保存已释放动态内存的地址。即<strong>空悬指针</strong>（dangling pointer）。</p>
<p>未初始化指针的所有缺点空悬指针一个不落。其中“在指针即将离开其作用域前释放掉它所关联的内存”可以作为一种解决方案，如果想要保留指针，需要在delete之后nullptr赋予它，这样清楚地指出指针不指向任何对象。</p>
<p>但这仅仅做出一点小的修复，动态内存的另一个基本问题是存在多个指针指向相同内存的情况，仅解决其中一个指针，其他指针依旧存在问题。</p>
<p>所以，<strong>对于动态内存请务必使用智能指针</strong>！</p>
<h3 id="shared_ptr和new的结合使用">shared_ptr和new的结合使用
</h3><p>如果不初始化一个智能指针，那么它就会被初始化为一个空指针。其实，还可以用new返回的指针来初始化智能指针。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接受指针参数的智能指针构造函数是explicit的，所以，不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式。相同的，不能将一个智能指针不能隐式转换为内置指针。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span> <span class="c1">//false 内置指针隐式转换为智能指针
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象。</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th style="text-align: center">定义和改变shared_ptr的其他方法</th>
          <th style="text-align: center">解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">shared_ptr<T> p(q)</td>
          <td style="text-align: center">p管理内置指针q所指向的对象；q必须指向new分配的内存，且能够转换为T*类型</td>
      </tr>
      <tr>
          <td style="text-align: center">shared_ptr<T> p(u)</td>
          <td style="text-align: center">p从unique_ptr u那里接管了对象的所有权：将u置为空</td>
      </tr>
      <tr>
          <td style="text-align: center">shared_ptr<T> p(q,d)</td>
          <td style="text-align: center">p接管了内置指针q所指向的对象的所有权。q必须能转换为T*类型。p将使用可调用d来代替delete</td>
      </tr>
      <tr>
          <td style="text-align: center">shared_ptr<T> p(p2,d)</td>
          <td style="text-align: center">p是shared_ptr p2的拷贝，唯一的区别是p将用可调用对象d来代替delete</td>
      </tr>
      <tr>
          <td style="text-align: center">p.reset()<br/>p.reset(q)<br/>p.reset(q,d)</td>
          <td style="text-align: center">若p是唯一指向其对象的shared_ptr,reset会释放此对象。若传递了可选的参数内置指针q,会令p指向q,否则会将p置为空。若还传递了参数d,就会调用d而不是delete来释放q</td>
      </tr>
  </tbody>
</table></div>
<h4 id="不要混合使用普通指针和智能指针">不要混合使用普通指针和智能指针
</h4><p>shared_ptr可以协调对象的析构，但这仅限于其自身的拷贝（也是shared_ptr）之间。这就是推荐使用make_shared而不是new的原因。可以在分配对象的同时就将shared_ptr与之绑定，从而避免无意中将同一块内存绑定到多个独立创建的shared_ptr上。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">){</span> <span class="c1">// 值传递，ptr引用计数+1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 使用ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="c1">// 销毁ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span> <span class="c1">// 引用计数为1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">process</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// 在process中引用计数为2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="c1">// 正确，引用计数为1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="o">*</span> <span class="nf">x</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">));</span> <span class="c1">// 危险：x是一个普通指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">process</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// 错误，无法隐式转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">process</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span> <span class="c1">// 合法，临时shared_ptr，内存会被释放
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span> <span class="c1">//未定义：x是一个空悬指针！
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当将一个shared_ptr绑定到一个普通指针时，我们就将内存的管理责任交给了这个shared_ptr。一旦这样做了，我们就不应该再使用内置指针来访问shared_ptr所指向的内存了。</p>
<blockquote>
<p>使用一个内置指针访问一个智能指针所负责的对象是危险的，因为我们无法知道对象何时被销毁！</p></blockquote>
<h4 id="不要使用get初始化另一个智能指针或为智能指针赋值">不要使用get初始化另一个智能指针或为智能指针赋值
</h4><p>智能指针类型定义了一个get函数，用于返回一个指向“智能指针管理的对象”的内置指针。此函数设计的目的是：将指针的<strong>访问权限</strong>传递给代码。<strong>使用get返回的指针的代码不能delete此指针</strong>。</p>
<p><strong>将另一个智能指针绑定到get返回的指针上是错误的</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span> <span class="c1">// 引用计数为1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="n">q</span><span class="o">=</span><span class="n">p</span><span class="p">.</span><span class="n">get</span><span class="p">();</span> <span class="c1">// 使用q时需要注意，不要让它管理的指针被释放
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// 当程序块结束，q被销毁，它指向的内存被释放
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="c1">// 错误，p指向的内存已经被释放
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>p和q指向相同的内存。由于二者相互独立，因此各自引用计数为1.当q所在程序块结束，q被销毁，这会导致q指向的内存被释放。从而导致p变成空悬指针，当意图使用p时，将发生为定义行为。同时，当p被销毁时，这块内存将会被二次delete。</p>
<h4 id="其他shared_ptr操作">其他shared_ptr操作
</h4><p>可以使用reset来将一个新的指针赋予一个shared_ptr：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">p</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">));</span> <span class="c1">// true
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>与赋值类似，reset会更新引用计数，如果需要的话，会释放p指向的对象。reset成员经常与unique一起使用，来控制多个shared_ptr共享的对象。<strong>在改变底层对象之前，需要检查是否是当前对象仅有的用户</strong>。如果不是，在改变之前需要进行一份拷贝。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">.</span><span class="n">unique</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="n">p</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">));</span> <span class="c1">// 分配新的拷贝
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">*</span><span class="n">p</span> <span class="o">+=</span> <span class="n">newVal</span><span class="p">;</span> <span class="c1">// 是唯一的用户，可以改变对象的值
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="智能指针和异常">智能指针和异常
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f_v1</span><span class="p">(){</span> 
</span></span><span class="line"><span class="cl">	<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pt</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span><span class="c1">// 分配一个新对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 如果在这里抛出异常，且在f中未被捕获
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="c1">// 函数结束时，shared_ptr仍然会自动释放内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f_v2</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">// 动态分配一个新对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 如果在这里抛出异常，且f并未捕获异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">delete</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// 在此之前退出，内存无法被释放
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>智能指针确保了内存在不需要时将其释放，但是如果是内置指针则不一定能够正常释放。</p>
<h4 id="智能指针和哑类">智能指针和哑类
</h4><p>包括所有标准库类在内的很多C++类都定义了析构函数，通过析构函数清理对象使用的资源。但是并不是所有的类都是这样良好的定义的，对于某些类需要用户显式地释放所使用的任何资源。对于这种类称为<strong>哑类</strong>。</p>
<p>在使用哑类的过程中，如果程序员忘记释放资源或者在资源分配和释放之间发生异常，都会导致资源泄露。那么基于这种情况，可以使用智能指针管理动态内存的类似技术来管理哑类。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 假设存在一个网络库，其中connection没有析构函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">destination</span><span class="p">;</span> <span class="c1">// 表示需要连接什么
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">connection</span><span class="p">;</span>  <span class="c1">// 连接所需信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">connection</span> <span class="nf">connect</span><span class="p">(</span><span class="n">destination</span><span class="o">*</span><span class="p">);</span> <span class="c1">// 打开连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">disconnect</span><span class="p">(</span><span class="n">connection</span><span class="p">);</span> <span class="c1">// 关闭给定的连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">destination</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 获得一个连接，需要显式关闭它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">connction</span> <span class="n">c</span><span class="o">=</span> <span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">	<span class="c1">// 使用连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 忘记调用disconnect函数关闭连接，那么f函数结束就无法关闭它。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="c1">// 资源泄露
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于上述出现的情况，通过使用shared_ptr修改默认的<strong>删除器</strong>实现对connection的智能管理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">end_connection</span><span class="p">(</span><span class="n">connection</span><span class="o">*</span> <span class="n">p</span><span class="p">){</span><span class="n">disconnect</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">destination</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">connection</span> <span class="n">c</span><span class="o">=</span><span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">connection</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="n">end_connection</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1">// 当p被销毁时，调用disconnect函数确保连接关闭
</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>注意：智能指针陷阱</p>
<p>为了正确使用智能指针，必选坚持的一些基本规范：</p>
<ul>
<li>不使用相同的内置指针初始化（或reset）<strong>多个</strong>智能指针</li>
<li>不delete get()返回的指针</li>
</ul>
<blockquote>
<p>get函数仅是为了将智能指针访问内存的权力暂时给予内置指针</p></blockquote>
<ul>
<li>不使用get()初始化或reset另一个智能指针</li>
</ul>
<blockquote>
<p>get()本质是某个智能指针的内置指针化，如果初始化或reset给另一个智能指针。将导致同一块动态内存被多个智能指针所管理，将导致出现空悬指针、多次delete等问题。</p></blockquote>
<ul>
<li>如果你使用get()返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了</li>
</ul>
<blockquote>
<p>get()仅仅作为智能指针向内置指针传递权力的工具，当权力的源头失效了自然所对应的内置指针就变为空悬指针，需要将内置指针赋予nullptr</p></blockquote>
<ul>
<li>如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器</li>
</ul>
<blockquote>
<p>智能指针默认调用delete操作销毁内存</p></blockquote></blockquote>
<h3 id="unique_ptr">unique_ptr
</h3><p>一个“unique_ptr”“拥有”它所指向的一个对象。</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th style="text-align: center">unique_ptr特有操作</th>
          <th style="text-align: center">解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">unique_ptr<T> u1<br/>unique_ptr&lt;T,D&gt; u2</td>
          <td style="text-align: center">空unique_ptr,可以指向类型为T的对象。u1会使用delete来释放它的指针；u2会使用一个类型为D的可调用对象来释放它的指针</td>
      </tr>
      <tr>
          <td style="text-align: center">unique_ptr&lt;T,D&gt; u(d)</td>
          <td style="text-align: center">空unique_ptr,指向类型为T的对象，用类型为D的对象d代替delete</td>
      </tr>
      <tr>
          <td style="text-align: center">u=nullptr</td>
          <td style="text-align: center">释放u指向的对象，将u置为空</td>
      </tr>
      <tr>
          <td style="text-align: center">u.release</td>
          <td style="text-align: center">u放弃对指针的控制权，<strong>返回指针</strong>并将u置为空</td>
      </tr>
      <tr>
          <td style="text-align: center">u.reset()</td>
          <td style="text-align: center">释放u指向的对象</td>
      </tr>
      <tr>
          <td style="text-align: center">u.reset(q)<br/>u.reset(nullptr)</td>
          <td style="text-align: center">如果提供了内置指针q,令u指向这个对象；否则将u置为空</td>
      </tr>
  </tbody>
</table></div>
<p>无法使用类似make_shared的标准库函数返回一个unique_ptr。所以当定义一个unique_ptr时，需要绑定到一个new返回的指针上。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于unique_ptr拥有它指向的对象，所以unique_ptr不支持普通的拷贝或赋值操作</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">p3</span><span class="o">=</span><span class="n">p1</span><span class="p">;</span> <span class="c1">// false
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>但是可以通过release或reset实现指针控制权的转移：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 将控制权从p1转移到p2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">release</span><span class="p">());</span> <span class="c1">// release将p1置为空，且返回指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p3</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 将控制权从p3转移到p2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">p2</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">release</span><span class="p">());</span> <span class="c1">// reset释放p2原本指向内存
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>调用release函数会切断unique_ptr和它原本管理的对象间的联系。release返回的指针（一般为内置指针）通常被用来初始化另一个智能指针或给另一个智能指针赋值。这仅仅是简单的权力交接，但是，如果不用一个智能指针保存release返回的指针，则需要负责资源的释放。</p>
<p>不能拷贝unique_ptr规则的一个例外：可以拷贝或赋值一个将要被销毁的unique_ptr：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="n">p</span><span class="p">));</span> <span class="c1">// 从int*创建一个unique_ptr&lt;int&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译器知道要返回的对象将要被销毁，所以在这种特殊的情况下，编译器执行一种特殊的“拷贝”。</p>
<h4 id="向unique_ptr传递删除器">向unique_ptr传递删除器
</h4><p>类似于shared_ptr,unique_ptr默认情况下用delete释放其对象，也可以重载unique_ptr中的默认删除器。但是,unique_ptr管理删除器的方式与shared_ptr不同。</p>
<p>重载一个unique_ptr中的删除器会影响到unique_ptr类型以及如何构造该类型的对象。所以必须在尖括号中unique_ptr指向类型之后提供删除器类型。在创建或reset一个这种unique_ptr类型的对象时，必须提供一个指向类型的可调用对象（删除器）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">objT</span><span class="p">,</span><span class="n">delT</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="n">objT</span><span class="p">,</span><span class="n">fun</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">Destination</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">Connection</span> <span class="n">c</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Connection</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">end_connection</span><span class="p">)</span><span class="o">*&gt;</span> <span class="n">p</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="n">end_connection</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="weak_ptr">weak_ptr
</h3><p>weak_ptr是一种不控制所指向对象生存周期的智能指针，它指向由一个shared_ptr管理的对象。其具有**“弱”共享对象**的特点：<strong>绑定</strong>到某个shared_ptr上并不会改变该shared_ptr引用计数；即使weak_ptr还指向某个对象，当指向该对象的shared_ptr被销毁时，该对象也会被释放。并不会因为weak_ptr关系而不释放。</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th style="text-align: center">weak_ptr</th>
          <th style="text-align: center">解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">weak_ptr<T> w</td>
          <td style="text-align: center">空weak_ptr可以指向类型为T的对象</td>
      </tr>
      <tr>
          <td style="text-align: center">weak_ptr<T> w(sp)</td>
          <td style="text-align: center">与shared_ptr指向相同对象的weak_ptr。T必须能转换为sp指向的类型</td>
      </tr>
      <tr>
          <td style="text-align: center">w=p</td>
          <td style="text-align: center">p可以是一个shared_ptr或一个weak_ptr。赋值后w与p共享对象</td>
      </tr>
      <tr>
          <td style="text-align: center">w.reset()</td>
          <td style="text-align: center">将w置为空</td>
      </tr>
      <tr>
          <td style="text-align: center">w.use_count()</td>
          <td style="text-align: center">与w共享对象的shared_ptr的数量</td>
      </tr>
      <tr>
          <td style="text-align: center">w.expired()</td>
          <td style="text-align: center">若w.use_count()为0,返回true,否则返回false</td>
      </tr>
      <tr>
          <td style="text-align: center">w.lock()</td>
          <td style="text-align: center">如果expired为true，返回一个空shared_ptr；否则返回一个指向w的对象的shared_ptr</td>
      </tr>
  </tbody>
</table></div>
<p>由于weak_ptr“弱”共享的特性，存在weak_ptr指向内存已经被释放情况。所以，weak_ptr不能直接访问对象，需要调用lock函数检查weak_ptr指向对象是否存在，如果存在返回指向共享内存的shared_ptr。</p>
<h2 id="122-动态数组">12.2 动态数组
</h2><p>C++与标准库提供两种一次分配一个对象数组的方法。一种采用new表达式，可以分配并初始化一个对象数组；另一种采用allocator类，允许将分配和初始化分离。</p>
<blockquote>
<p>注意：尽管提供直接访问动态数组的方法，但是大多数应用应该使用标准库容器而不是动态分配数组。</p></blockquote>
<h3 id="new和数组">new和数组
</h3><p>分配数组必须指明对象元素的数量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">p_1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">get_size</span><span class="p">()];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 或者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="kt">int</span> <span class="n">arrT</span><span class="p">[</span><span class="mi">42</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">p_2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">arrT</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>分配一个数组会得到一个元素类型的指针。同时由于分配的内存并不是数组类型，所以不能调用begin或者end。</p>
<p>初始化动态分配对象的数组，使用new分配的对象，不论是单个分配还是数组中的，都是默认初始化。可以对数组中的元素进行值初始化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">p_3</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>也可以提供一个元素初始化器的花括号列表：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">string</span> <span class="o">*</span><span class="n">p_4</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">[</span><span class="mi">10</span><span class="p">]{</span><span class="s">&#34;a&#34;</span><span class="p">,</span><span class="s">&#34;b&#34;</span><span class="p">,</span><span class="s">&#34;c&#34;</span><span class="p">,</span><span class="n">string</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&#34;d&#34;</span><span class="p">)};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果初始化器数目小于元素数目，剩余元素进行值初始化；如果大于，则new表达式失败，不会分配任何内存且抛出bad_array_new_length（定义在new中）的异常。</p>
<p><strong>动态分配一个空数组是合法的</strong>，但是指向该空数组的指针不能解引用。</p>
<p>释放动态数组则采用特殊形式的delete：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">delete</span> <span class="p">[]</span> <span class="o">*</span><span class="n">p_5</span><span class="p">;</span> <span class="c1">// 空括号是必需的，其指示编译器此指针指向一个对象数组的第一个元素
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>该delete语句将销毁p_5指向的数组中元素并释放内存。数组中的元素按照逆序销毁。</p>
<blockquote>
<p>如果在delete一个数组指针时忘记方括号或者delete一个单一对象的指针时使用了方括号都是未定义的。编译器很可能不会给出警告。程序可能在执行过程中在没有任何警告的情况下行为异常。</p></blockquote>
<h4 id="智能指针和动态数组">智能指针和动态数组
</h4><p>标准库提供可以管理new分配数组的unique_ptr版本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">up</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="n">up</span><span class="p">.</span><span class="n">release</span><span class="p">();</span> <span class="c1">// 自动使用delete[]销毁其指针
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>由于unique_ptr指向的是一个数组而不是对象，所以不能使用点和箭头成员运算符。可以使用下标运算符来访问数组中的元素：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">!=</span><span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="err">）</span>
</span></span><span class="line"><span class="cl">	<span class="n">up</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th style="text-align: center">指向数组的unique_ptr</th>
          <th style="text-align: center">解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">unique_ptr&lt;T[]&gt; u</td>
          <td style="text-align: center">u可以指向一个动态分配的数组，数组元素类型为T</td>
      </tr>
      <tr>
          <td style="text-align: center">unique_ptr&lt;T[]&gt; u(p)</td>
          <td style="text-align: center">u指向内置指针p所指向的动态分配的数组。p必须能转换为类型T*</td>
      </tr>
      <tr>
          <td style="text-align: center">u[i]</td>
          <td style="text-align: center">返回u拥有的数组中位置i处的对象（u必须指向一个数组）</td>
      </tr>
  </tbody>
</table></div>
<p>shared_ptr不支持直接管理动态数组：</p>
<ol>
<li>需要自定义删除器</li>
<li>为定义下标运算符</li>
</ol>
<p>所以，如果使用shared_ptr管理动态内存数组，需要这样：</p>
<p>释放数组：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sp</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">],[](</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">){</span><span class="k">delete</span><span class="p">[]</span> <span class="n">p</span><span class="p">;});</span>
</span></span><span class="line"><span class="cl"><span class="n">sp</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span> <span class="c1">// 使用提供的lambda释放数组
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>访问数组元素：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">!=</span><span class="mi">10</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="p">(</span><span class="n">sp</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">+</span><span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="allocator类">allocator类
</h3><p>new将内存分配和对象构造组合在一起，delete操作将对象析构和内存释放组合在一起。这带来一定的局限性。当分配单个对象时，通常希望上述操作合并起来，因为我们几乎肯定知道对象有什么值。但是当分配一大块内存时，我们通常需要事先计划，等到真正执行对象时才执行创建操作。</p>
<p>标准库提供allocator类，其将内存分配和对象构造分离，通过提供一种类型感知的内存分配方法，其分配的内存是原始的、未构造的。</p>
<p>allocator本身是一个模板，当分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对齐位置。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">allocator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="k">const</span> <span class="n">p</span><span class="o">=</span><span class="n">alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="c1">// 分配n个未初始化的string
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th style="text-align: center">标准库allocator类及其算法</th>
          <th style="text-align: center">解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">allocator<T> a</td>
          <td style="text-align: center">定义了一个名为a的allocator对象，它可以为类型为T的对象分配内存</td>
      </tr>
      <tr>
          <td style="text-align: center">a.allocate(n)</td>
          <td style="text-align: center">分配一段原始的、未构造的内存，保存n个类型为T的对象</td>
      </tr>
      <tr>
          <td style="text-align: center">a.deallocate(p,n)</td>
          <td style="text-align: center">释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小。在调用deallocate之前，用户必须对每个在这块内存中创建的对象调用destroy</td>
      </tr>
      <tr>
          <td style="text-align: center">a.construct(p,<i>args</i>)</td>
          <td style="text-align: center">p必须是一个类型为T*的指针，指向一块原始内存；<i>arg</i>被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象</td>
      </tr>
      <tr>
          <td style="text-align: center">a.destroy(p)</td>
          <td style="text-align: center">p为T*类型的指针，此算法对p指向的对象执行析构函数</td>
      </tr>
  </tbody>
</table></div>
<p>allocator分配的内存是未构造的，按需要在此内存中构造对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// q指向最后构造的元素之后的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">q</span><span class="o">++</span><span class="p">);</span> <span class="c1">// *q为空字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">q</span><span class="o">++</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="sc">&#39;c&#39;</span><span class="p">);</span> <span class="c1">// *q为cc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">q</span><span class="o">++</span><span class="p">,</span><span class="s">&#34;hi&#34;</span><span class="p">);</span> <span class="c1">// *q为hi
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对未构造的对象使用原始内存是错误的！</p>
<p>当用完对象后，必须使用每个构造的元素调用destroy销毁它们。当元素被销毁，那么可以选择重新使用这部分内存也可以通过调用deallocate释放内存。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">while</span><span class="p">(</span><span class="n">q</span><span class="o">!=</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">alloc</span><span class="p">.</span><span class="n">destroy</span><span class="p">(</span><span class="o">--</span><span class="n">q</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl"><span class="n">alloc</span><span class="p">.</span><span class="n">deallocate</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在标准库中还为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th style="text-align: center">allocator算法</th>
          <th style="text-align: center">解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">uninitialized_copy(b,e,b2)</td>
          <td style="text-align: center">从迭代器b和e指出的输入范围中拷贝元素到迭代器b2指定的未构造的原始内存中。b2指向的内存必须足够大，能容纳输入序列中元素的拷贝</td>
      </tr>
      <tr>
          <td style="text-align: center">uninitialized_copy_n(b,n,b2)</td>
          <td style="text-align: center">从迭代器b指向的元素开始，拷贝n个元素到b2开始的内存中</td>
      </tr>
      <tr>
          <td style="text-align: center">uninitialized_fill(b,e,t)</td>
          <td style="text-align: center">在迭代器b和e指定的原始内存范围中创建对象，对象的值均为t的拷贝</td>
      </tr>
      <tr>
          <td style="text-align: center">uninitialized_fill_n(b,n,t)</td>
          <td style="text-align: center">从迭代器b指向的内存地址开始创建n个对象。b必须指向足够大的未构造的原始内存，能够容纳给定数量的对象</td>
      </tr>
  </tbody>
</table></div>
<p>例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// vi为int的vector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="n">uninitialized_copy</span><span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">vi</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">uninitialized_fill_n</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">vi</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="mi">42</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="123-使用标准库文本查询程序">12.3 使用标准库：文本查询程序
</h2><p>实现一个简单的文本查询程序：允许用户在一个给定的文件中查询单词，查询结果为单词在文件中出现的次数及其所在行的列表。</p>
<p>例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Enter</span> <span class="n">the</span> <span class="n">file</span> <span class="n">name</span> <span class="n">to</span> <span class="n">look</span> <span class="nl">up</span><span class="p">:</span> <span class="n">QuotesInEnglish</span><span class="p">.</span><span class="n">txt</span>
</span></span><span class="line"><span class="cl"><span class="n">Enter</span> <span class="n">word</span> <span class="n">to</span> <span class="n">look</span> <span class="k">for</span><span class="p">,</span> <span class="n">or</span> <span class="sc">&#39;q&#39;</span> <span class="n">to</span> <span class="nl">exit</span><span class="p">:</span> <span class="n">the</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;the&#34;</span> <span class="n">occurs</span> <span class="mi">17</span> <span class="nl">times</span><span class="p">:</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">line</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">2</span><span class="err">、</span><span class="n">Variety</span> <span class="n">is</span> <span class="n">the</span> <span class="n">spice</span> <span class="n">of</span> <span class="n">life</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">line</span> <span class="mi">17</span><span class="p">)</span> <span class="mi">5</span><span class="err">、</span><span class="n">Doubt</span> <span class="n">is</span> <span class="n">the</span> <span class="n">key</span> <span class="n">to</span> <span class="n">knowledge</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">line</span> <span class="mi">49</span><span class="p">)</span> <span class="mi">13</span><span class="err">、</span><span class="n">Life</span> <span class="n">is</span> <span class="n">the</span> <span class="n">art</span> <span class="n">of</span> <span class="n">drawing</span> <span class="n">sufficient</span> <span class="n">conclusions</span> <span class="n">form</span> <span class="n">insufficient</span> <span class="n">premises</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">line</span> <span class="mi">65</span><span class="p">)</span> <span class="mi">17</span><span class="err">、</span><span class="n">Life</span> <span class="n">is</span> <span class="n">a</span> <span class="n">great</span> <span class="n">big</span> <span class="n">canvas</span><span class="p">,</span> <span class="n">and</span> <span class="n">you</span> <span class="n">should</span> <span class="k">throw</span> <span class="n">all</span> <span class="n">the</span> <span class="n">paint</span> <span class="n">on</span> <span class="n">it</span> <span class="n">you</span> <span class="n">can</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">line</span> <span class="mi">77</span><span class="p">)</span> <span class="mi">20</span><span class="err">、</span><span class="n">The</span> <span class="n">wealth</span> <span class="n">of</span> <span class="n">the</span> <span class="n">mind</span> <span class="n">is</span> <span class="n">the</span> <span class="n">only</span> <span class="n">wealth</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">line</span> <span class="mi">105</span><span class="p">)</span> <span class="mi">27</span><span class="err">、</span><span class="n">Wealth</span> <span class="n">is</span> <span class="n">the</span> <span class="n">test</span> <span class="n">of</span> <span class="n">a</span> <span class="n">man</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">character</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">line</span> <span class="mi">109</span><span class="p">)</span> <span class="mi">28</span><span class="err">、</span><span class="n">The</span> <span class="n">best</span> <span class="n">hearts</span> <span class="n">are</span> <span class="n">always</span> <span class="n">the</span> <span class="n">bravest</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">line</span> <span class="mi">117</span><span class="p">)</span> <span class="mi">30</span><span class="err">、</span><span class="n">There</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">only</span> <span class="n">one</span> <span class="n">corner</span> <span class="n">of</span> <span class="n">the</span> <span class="n">universe</span> <span class="n">you</span> <span class="n">can</span> <span class="n">be</span> <span class="n">sure</span> <span class="n">of</span> <span class="n">improving</span><span class="p">,</span> <span class="n">and</span> <span class="n">that</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">your</span> <span class="n">own</span> <span class="n">self</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">line</span> <span class="mi">125</span><span class="p">)</span> <span class="mi">32</span><span class="err">、</span><span class="n">Death</span> <span class="n">comes</span> <span class="n">to</span> <span class="n">all</span><span class="p">,</span> <span class="n">but</span> <span class="n">great</span> <span class="n">achievements</span> <span class="n">raise</span> <span class="n">a</span> <span class="n">monument</span> <span class="n">which</span> <span class="n">shall</span> <span class="n">endure</span> <span class="n">until</span> <span class="n">the</span> <span class="n">sun</span> <span class="n">grows</span> <span class="n">old</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">line</span> <span class="mi">133</span><span class="p">)</span> <span class="mi">34</span><span class="err">、</span><span class="n">Suffering</span> <span class="n">is</span> <span class="n">the</span> <span class="n">most</span> <span class="n">powerful</span> <span class="n">teacher</span> <span class="n">of</span> <span class="n">life</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">line</span> <span class="mi">149</span><span class="p">)</span> <span class="mi">38</span><span class="err">、</span><span class="n">A</span> <span class="n">fall</span> <span class="n">into</span> <span class="n">the</span> <span class="n">pit</span><span class="p">,</span> <span class="n">a</span> <span class="n">gain</span> <span class="n">in</span> <span class="n">your</span> <span class="n">wit</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">line</span> <span class="mi">153</span><span class="p">)</span> <span class="mi">39</span><span class="err">、</span><span class="n">A</span> <span class="n">guest</span> <span class="n">should</span> <span class="n">suit</span> <span class="n">the</span> <span class="n">convenience</span> <span class="n">of</span> <span class="n">the</span> <span class="n">host</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">line</span> <span class="mi">161</span><span class="p">)</span> <span class="mi">41</span><span class="err">、</span><span class="n">All</span> <span class="n">rivers</span> <span class="n">run</span> <span class="n">into</span> <span class="n">the</span> <span class="n">sea</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">line</span> <span class="mi">169</span><span class="p">)</span> <span class="mi">43</span><span class="err">、</span><span class="n">An</span> <span class="n">apple</span> <span class="n">a</span> <span class="n">day</span> <span class="n">keeps</span> <span class="n">the</span> <span class="n">doctor</span> <span class="n">away</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">line</span> <span class="mi">181</span><span class="p">)</span> <span class="mi">46</span><span class="err">、</span><span class="n">Behind</span> <span class="n">the</span> <span class="n">mountains</span> <span class="n">there</span> <span class="n">are</span> <span class="n">people</span> <span class="n">to</span> <span class="n">be</span> <span class="n">found</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Enter</span> <span class="n">word</span> <span class="n">to</span> <span class="n">look</span> <span class="k">for</span><span class="p">,</span> <span class="n">or</span> <span class="sc">&#39;q&#39;</span> <span class="n">to</span> <span class="nl">exit</span><span class="p">:</span> <span class="n">q</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">进程已结束，退出代码为</span> <span class="mi">0</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="文本查询程序的设计">文本查询程序的设计
</h3><p>|<a class="link" href="https://github.com/Free-Aaron-Li/Cpp_Study-program/blob/master/Cpp_Primer_Studying/PartII_STL/ChapterTwelve_DynamicMemory/src/main.cpp#L36C9-L36C9"  target="_blank" rel="noopener"
    >源代码</a>|</p>
<p><strong>开发一个程序在设计上的一种好方法是列出程序的操作</strong>，了解需要哪些操作会帮助我们分析出需要什么样的数据结构。</p>
<ul>
<li>当程序读取输入文件时，它必须<strong>记住单词出现的每一行</strong>。因此，程序需要<strong>逐行读取</strong>输入文件，并将每一行分解为独立的单词。</li>
<li>当程序生成输出时，
<ul>
<li>它必须能提取每个单词所<strong>关联的行号</strong></li>
<li>行号必须按照升序出现且<strong>无重复</strong></li>
<li>它必须能打印给定行号中的文本</li>
</ul>
</li>
</ul>
<p>对此，可以这样实现：</p>
<ul>
<li>使用一个vector<string>来保存整个输入文件的一份拷贝。输入文件中的每行保存为vector中的一个元素。当需要打印一行时，可以用行号作为下标来提取行文本。</li>
<li>使用一个istringstream来将每行分解为单词</li>
<li>使用一个set来保存每个单词在输入文本中出现的行号。这保证了每行只出现一次且行号按照升序保存</li>
<li>使用一个map来将每个单词与它出现的行号set关联起来。这样我们就可以方便地提取任意单词的set</li>
<li>为了实现类之间共享数据，使用shared_ptr来反映数据结构中的共享关系</li>
</ul>
<h2 id="总结">总结
</h2><p>分配动态内存的同时需要负责释放内存，在释放时存在空悬指针、多次delete等问题。智能指针是解决动态内存的好方式，在使用动态指针时，根据计数器会自动释放内存。</p>
<p>现代C++程序应尽可能使用智能指针。</p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/c&#43;&#43;/">C&#43;&#43;</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
	const mainArticleElement = document.querySelector(".main-article");
        renderMathInElement(mainArticleElement, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>

    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="has-image">
    <a href="/p/c-%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%80%E5%A7%8B/">
        
        
            <div class="article-image">
                
                    <img src="https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg" loading="lazy" data-key="" data-hash="https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">C&#43;&#43; 基础： 第一章 开始</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/c-%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/">
        
        
            <div class="article-image">
                
                    <img src="https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg" loading="lazy" data-key="" data-hash="https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">C&#43;&#43; 基础： 第七章 类</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/c-%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/">
        
        
            <div class="article-image">
                
                    <img src="https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg" loading="lazy" data-key="" data-hash="https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">C&#43;&#43; 基础： 第三章 字符串、向量和数组</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/c-%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/">
        
        
            <div class="article-image">
                
                    <img src="https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg" loading="lazy" data-key="" data-hash="https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">C&#43;&#43; 基础： 第九章 顺序容器</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/c-%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/">
        
        
            <div class="article-image">
                
                    <img src="https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg" loading="lazy" data-key="" data-hash="https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">C&#43;&#43; 基础： 第二章 变量和基本类型</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    <script src="https://utteranc.es/client.js" 
        repo="Free-Aaron-Li/utterances"
        issue-term="pathname"
        
        label="comment"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    let utterancesLoaded = false;

    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;

        
        utterancesLoaded = true;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        if (!utterancesLoaded) return;
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2025 Aaron
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.30.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
