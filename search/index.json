[{"content":"第八章 IO流 前言 C++语言并不会直接处理输入输出，而是通过一族定义在标准库中的类型来处理IO。这些类型支持从设备中读取数据、向设备写入数据IO操作。设备可以是文件、控制台窗口等，还有一些类型允许访问内存IO。\nIO库定义了读写内置类型值的操作。\n8.1 IO类 在之前我们使用的IO类型和对象都是操作char数据且这些对象都是关联到用户的控制台窗口。但在实际开发中还不够，所以在C++的IO操作中还包括以下类型供开发者使用。\n在头文件iostream定义了读写流的基本类型、fstream定义了读写命名文件的类型、sstream定义了读写内存string对象的类型。\n头文件 类型 iostream istream，wistream 从流读取数据ostream，wostream向流写入数据iostream，wiostream读写流 fstream ifstream，wifstream从文件读取数据ofstream，wofstream向文件写入数据fstream，wfstream读写文件 sstream istringstream，wistringstream从stream读取数据ostringstream，wostringstream向string写入数据stringstream，wstringstream读写string 为了支持宽字符的语言，标准库定义了一组类型与对象来操作wchar_t类型的数据。宽字符版本的类型和函数的名字以一个w开始。\n从概念上讲，IO操作并不会因为设备类型和字符大小而受到影响。例如，我希望通过某个文件读取宽字符数据，其与在终端窗口读取普通字符数据其操作都是一致的，都是通过输入运算符\u0026raquo;。那么这样就存在一个好处，我们可以忽略不同类型的流之间的差异（但并不是不存在差异），使得开发效率得到提高。\n这种忽略流差异的技术通过继承机制（inheritance）实现，利用模板，通过使用具有继承关系的类使得我们忽略工作细节。\nIO对象无拷贝或赋值 如标题，IO对象不存在拷贝或者赋值初始化的操作：\n1 2 3 4 ofstream of_1,of_2; of_1=of_2; /* 错误：无法对流对象进行赋值 */ ofstream print(ofstream); /* 错误：无法初始化ofstream参数 */ of_2=print(of_2); /* 错误：无法拷贝流对象 */ 由此引申出，无法将返回类型或者形参设置为流类型，同时由于读写一个IO对象会改变其状态，所以常常使用引用方式传递和返回流且此引用不能为const。\n状态条件 IO操作并不是万无一失的，其潜在可能发生的错误，有一些错误能够较为容易修复，但是有一些错误其可能在系统层面，其修复的范围远远超过应用层面，这时就需要一些IO操作上的函数或者标志来帮助程序确定IO操作状态，其称为访问和操作流的 条件状态（condition state)。\n状态名 解释 strm::iostate iostate是一种机器相关的类型，提供了表达条件状态的完整功能 strm::badbit 指出流已经崩溃 strm::failbit 指出一个IO操作失败 strm::eofbit 指出流已经到达文件结束 strm::goodbit 指出流处于错误状态，此值保证为零 s.eof() 若s流的eofbit置位，则返回true s.fail() 若s流的failbit或者badbit置位，则返回true s.bad() 若s流的badbit置位，则返回true s.good() 若s流处于有效状态，则返回true s.clear() 将s流中所有条件状态位复位，将流的状态设置为有效，返回void s.clear(flags) 根据给定的flags标志位，将s流中对应的条件状态位复位。flags的类型为strm.iostate，返回void s.setstate(flags) 根据给定的flags标志位，将s流中对应的条件状态位置位。flags的类型为strm.iostate，返回void s.rdstate() 返回s流的当前条件状态。返回值的类型为：strm::iostate strm是一种IO类型，s为流\n当一个流发生错误，那么后续的IO操作都会失败，为了程序的健壮性，通常需要使用流之前判断其是否处于良好状态。最简单的方式：\n1 2 while(cin\u0026gt;\u0026gt;word) /* ok,next */ 当流出现问题，我们肯定希望查询到错误原因，这个时候就需要依赖条件状态，IO库定义了一个与机器相关的iostate类型，其提供表达流状态的完整功能，作为一个位集合使用。通过位运算符进行一次性检测或者设置多个标志位。\n具体来讲：\nbadbit，系统级错误，例如：不可恢复的读写错误。当badbit被置位，流就无法再使用 failbit，发生可恢复错误，例如：期望读取数值结果读取字符，当错误被修复，流还可以使用。 当读取文件结束，eofbit和failbit都会被置位，goodbit值为0,表示流未发生错误。 如果badbit、failbit和eofbit任意一个被置位，则检测状态的条件会失败。 在上述描写到，IO库定义的一系列查询标志位的函数，当错误位被置位时其对应的函数就会返回true，注意一点，无论是badbit还是eofbit还是其本身failbit被置位，都会同时触发fail() 函数，所以在上述判断流状态的条件代码实际等价于!fail()。\n管理条件状态 在上述列表上介绍了四种管理条件状态的函数，我们可以使用clear()清除所有错误标志位，也可以使用clear(flags)清除指定的错误标志位，例如：\n1 2 3 /* 假设cin出现所有的错位状态位 */ /* 希望复位单一状态位 */ cin.clear(cin.rdstate()\u0026amp;~cin.failbit\u0026amp;~cin.badbit); 我们可以通过读取当前状态，例如上述代码，我们就可以复位failbit和badbit，但是eofbit保持不变。\n管理输出缓冲 每个输出流都管理一个缓冲区，用来保存程序读写的数据。\n缓冲机制的存在可以带来很大的性能提升，操作系统可以将（多个）程序的（多个）输出操作组合成为单一的系统级别写操作。\n例如：\n1 2 3 4 cout\u0026lt;\u0026lt;\u0026#34;hello\u0026#34;; cout\u0026lt;\u0026lt;\u0026#34;world\u0026#34;; cout\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;!\u0026#34;; 在前两行表达式就是将输出操作组合在一起，都存放在缓冲区。第三行则进行缓冲区的刷新，那么第四行表达式中数据就和前两行数据不存放在一起（前两行数据已经被刷新掉了）。\n导致缓冲刷新的原因有很多，例如：\n程序正常结束，作为main函数的return操作的一部分，缓冲刷新将会被执行 缓冲区已满，后入的数据只有在刷新缓冲区后才能继续写入缓冲区 使用操作符endl显式刷新缓冲区 在每个输出操作之后，使用操作符unitbuf设置流的内部状态，借此清空缓冲区 默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的 一个输出流可能被关联到另一个流 当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin和cerr都关联到cout。因此，读cin或者写cerr都会导致cout的缓冲区被刷新。 刷新输出缓冲区 在此之前，我们使用操作符endl来进行换行和刷新缓冲区（当时我们可能还没注意到endl具有刷新缓冲区的功能）。类似的，IO库中还存在flush和ends两种操作符也可以执行刷新操作。\nflush刷新缓冲区，但是不输出任何额外的字符（类似endl但不换行）；ends向缓冲区插入一个空字符，然后刷新缓冲区。\n如果想要在每次输出操作后都执行刷新缓冲区的操作，那么我们可以使用unitbuf操作符。它告诉流在接下来的每次写操作之后都会进行一次flush操作。nounitbuf操作符则是重置流，使其恢复使用正常的系统管理的缓冲区刷新机制。\n1 2 3 cout\u0026lt;\u0026lt;unitbuf; /* 下面所有的输出操作均会立即刷新缓冲区 */ /* .... */ cout\u0026lt;\u0026lt;nounitbuf; /* 回到正常的缓冲方式 */ 注意\n如果程序崩溃，输出缓冲区是不会被刷新的\n如果程序异常终止，其缓冲区不会被刷新。其所输出的数据很可能停留在输出缓冲区中等待打印\n注意这个细节，如果我们调试一个已经崩溃的程序，需要检查认为已经输出的数据确实已经被刷新了，否则追踪一个没有价值的代码是毫无意义的。\n关联输入和输出流 当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。\n在IO库中，cin默认已经和cout关联在一起，也就是说当执行cin语句时，在此之前的cout的缓冲区 将会被刷新。\n开发\n交互式系统通常应该关联输入流和输出流。这意味着所有的输出，包括用户提示信息，都会在读操作之前被打印出来。\n我们可以通过tie函数关联流。\n1 2 3 cin.tie(\u0026amp;cout); /* 将cin和cout关联 */ cin.tie(nullptr); /* cin不再和其他流关联 */ cin.tie(\u0026amp;cerr); /* cin与cerr关联 */ 8.2 文件输入输出 在IO库中，头文件fstream定义了三个类型来支持文件IO操作。\nifstream，从给定文件读取数据 ofstream，向给定文件写入数据 fstream，向给定文件读写数据 ifstream继承于iostream，所以常规操作与cin和cout对象操作类似，同样可以使用IO运算符（\u0026laquo;和\u0026raquo;)来读写文件，也可以使用getline从一个ifstream读取数据。\n除此之外，fstream还具有一些自己独特的操作：\n操作 解释 fstream fstrm; 创建一个未绑定的文件流 fstream fstrm(s); 创建一个fstream，并打开名为s的文件。s可以是string类型，也可以是指向C风格字符串的指针。同时其构造函数都是explicit的。默认的文件模式mode依赖于fstream的类型 fstream fstrm(s,mode); 与上述类似，但是按照指定mode打开文件 fstrm.open(s) 打开名为s的文件，并将文件与fstrm绑定。s的类型与上述类似，默认的文件mode依赖于fstream的类型。返回void fstrm.close() 关闭与fstrm绑定的文件。返回void fstrm.is_open() 返回一个bool值，指出与fstrm关联的文件是否成功打开且尚未关闭 fstream是头文件fstream中定义的一个类型，可以是ifstream，也可以是ofstream，当然也可以是fstream。\n使用文件流对象 当打算读取某个文件时，我们需要定义一个文件流对象，并将其与文件关联起来。每个文件流对象都定义了一个open成员函数，其完成一些系统相关的操作（定位给定文件，视情况打开读或写模式）\n创建文件流对象，我们可以选择提供文件名（当然，也可以后续提供）。如果提供一个文件名，那么open将会自动调用。\n1 2 ifstream input(ifile); /* 构造一个ifstream并打开给定文件 */ ofstream output; /* 构造一个ofstream对象，并未关联文件 */ 文件名可以是string对象，也可以是C风格字符数组。在C++11版本之前仅允许C风格字符数组。\n用fstream代替iostream\u0026amp; 在前文提到，在要求使用基类型对象的地方，我们可以用继承类型的对象来代替。也就是说，在一个接受iostream类型引用（指针）参数的函数，可以使用一个对应的fstream（或者sstream）类型来调用。\n成员函数open和close 在前文提到，我们可以定义一个文件流对象，但不将其与文件关联起来。\n关联文件使用文件流对象的成员函数open，\n1 2 3 ifstream input(ifile); /* 构造一个ifstream并给定文件 */ ofstream output; /* 构造一个ofstream对象，但不关联文件 */ output.open(ifile); /* 关联指定文件 */ 但一个文件流已经被打开了，那么其就保持与对应文件的关联。这个时候，希望再次调用成员函数open将会失败且failbit会被置位。如果希望文件流关联另一个文件，需要关闭已经关联的文件。这个时候就需要用到成员函数close。\n1 2 input.close(); /* 关闭文件 */ input.open(ifile_1); /* 关联另一个文件 */ 如果open成功，那么open将会设置流的状态，这个时候IO库条件状态good()将会为true。\n当一个fstream对象离开其作用域，与之关联的文件会自动关闭。当一个fstream对象被销毁时，close会自动调用。\n开发\n由于调用open可能会失败，所以在进行open时应该习惯于进行是否成功的检测。\n文件模式 每个文件流都有一个关联的文件模式（file mode），用来指出如何使用文件\n文件模式 解释 in 以读方式打开 out 以写方式打开 app 每次写操作前均定位到文件末尾 ate 打开文件后立即定位到文件末尾 trunc 截断文件 binary 以二进制方式进行IO 每个文件流类型都定义了一个默认的文件模式。ifstream默认以in模式打开，ofstream默认以out模式打开，fstream默认以in和out模式打开。\n无论那种方式打开文件，我们都可以指定文件模式。当然指定是有限制的：\n只可以对ofstream或者fstream对象设定out模式 只可以对ifstream或者fstream对象设定in模式 trunc模式的设定前提是out模式被设定 app模式设定前提是trunc模式没有被设定。在app模式下，即便没有显式指定out模式，文件也总是以输出方式被打开 默认情况下，out模式打开的文件是会被截断的（即便没有设定trunc），如果想要保留则需要指定app模式，或者同时指定in模式，使打开文件同时进行读写操作 ate和binary模式可用用于任何类型的文件流对象，且可以与其他任何文件模式组合使用 在上文我们提到out模式默认会截断，即清空文件已有数据。所以如果希望保留则需要显式指定app或者in模式。\n8.3 string流 sstream头文件定义了三种类型来支持内存IO。\n和fstream和iostream类似，sstream的三种类型分别对string读取数据、写入数据和读取写入数据：istringstream、ostringstream、stringstream。\n当然，除了继承iostream的操作，sstream也具有对内存IO类型的特殊操作：\n操作 解释 sstream strm; strm是一个未绑定的sstream对象 sstream strm(s); strm作为sstream对象，保存string s的一个拷贝 strm.str() 返回strm所保存的string的拷贝 strm.str(s) 将string s拷贝到strm中。，返回void sstream是头文件sstream中定义的一个类型。\n当我们的某些工作是对整行文本进行处理，而其他工作是处理行内的单个单词时，通常考虑使用istringstream。\n当我们逐步构造输出，希望最后一起打印时，ostringstream通常是我们的一般解。\n总结 fstream和sstream都继承于iostream，所以在操作上三者具有很多相同点。\n对于声明在语句外的流，可以通过在语句块内部使用clear函数解决EOF问题。\n条件状态的特性需要记牢！\n","date":"2025-04-06T00:00:00Z","image":"https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg","permalink":"https://Free-Aaron-Li.github.io/p/c-%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%85%AB%E7%AB%A0-io%E6%B5%81/","title":"C++ 基础： 第八章 IO流"},{"content":"第二章 变量和基本类型 前言 数据类型是程序的基础：它告诉我们数据的意义以及我们能在数据上执行的操作。\n2.1 基本内置类型 C++定义了包括算术类型（arithmetic type）和空类型（void）在内的基本数据类型。\n2.1.1 算术类型 算术类型分为两类：整型和浮点型。\n具体分类：\n类型 含义 最小容量 bool 布尔类型 未定义 char 字符 8位 wchar_t 宽字符 16位 char16_t Unicode字符 16位 char32_t Unicode字符 32位 short 短整型 16位 int 整型 16位 long 长整型 32位 long long 长整型 64位 float 单精度浮点数 6位有效数字 double 双精度浮点数 10位有效数字 long double 扩展精度浮点数 10位有效数字 基本数据类型char，其空间应确保可以存放机器基本字符集中任意字符对应的数字值。即一个char的大小和一个机器字节一样。\n除去布尔型和扩展的字符型之外，其他整型可以划分为带符号的（signed）和无符号的（unsigned）两种。\n其中char类型是个特殊存在，其存在三种类型：char、signed char和unsigned char。但是字符的表现形式仅有两种， 根据编译器决定类型char实际上应该表现为那种形式（无符号/有符号）。同时由于其表现形式由编译器决定，存在唯二性， 所以在算术表达式中不能使用char类型。（实在要使用，必须规定其具体类型）\n2.1.2 类型转换 对象的类型定义了对象能包含的数据和能参与的运算。类型所能表示的值的范围决定了转换的过程。\n当赋给无符号类型一个超出它表示范围的值时，结果时初始值对无符号类型表示数值总数取模后的余数。例如：unsigned char c = -1 //假设char占8比特，c的值为255,由于8比特大小的无符号char可以表示0~255内的值，其实际结果便是该值对256取模后得到的余数255。\n当赋给带符号类型一个超出它范围的值时，结果时未定义的（undefined），存在一下可能：程序可能正常工作、可能程序崩溃 可能产生未知的数据（即垃圾数据）\nPS:\n程序应当尽量避免依赖于实现环境的行为、避免无法预知的行为\n2.1.3 字面值常量 形如 12 的值被称为字面值常量（literal）。每个字面值常量都对应一种数据类型，其形式和值决定了它的数据类型。\n整型和浮点型字面值 整型字面值具体的数据类型由其符号和值决定。\n1 2 3 20 /* 十进制 */ 024 /* 八进制 */ 0x24 /* 十六进制 */ 默认，十进制为带符号数，剩下两种都有可能。\n字符和字符串字面值 字符串字面值的类型实际是由常量字符构成的数组。编译器在每个字符串的结尾处添加一个空字符“\\0”，因此，实际长度比内容多1。\n转义字符 C++语言规定的转义序列包括：\n1 2 3 4 换行符 \\n 横向制表符 \\t 报警（响铃）符 \\a 纵向制表符 \\v 退格符 \\b 双引号 \\\u0026#34; 反斜杠 \\\\ 问号 \\? 单引号 \\\u0026#39; 回车符 \\r 进纸符 \\f 通过为字面值添加前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。\n布尔字面值和指针字面值 true和false是布尔类型的字面值，nullptr是指针字面值。\n2.2 变量 变量提供一个具名的、可供程序操作的存储空间 。C++中每个变量都有数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。对于C++程序员来说，“变量（variable）”和“对象（object）”一般可以互换使用。\n2.2.1 变量定义 变量定义的基本格式：类型说明符（type specifier），一个或多个变量名组成的列表。\nPS:\n对象（object），指一块能存储数据并具有某种类型的内存空间。 一部分人认为：仅在与类有关的场景下才能使用“对象”这个词；一部分人认为应该将把命名的对象和未命名的对象区分开将命名了的对象叫做变量；还有一部分人仍未应该将能够被程序修改的数据称为对象，而只读程序称为值（value）\n初始化 当对象在创建时获得一个特定的值，称为这个对象被初始化（initialized）了。\n初始化并不是赋值，虽然都是通过=方式，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来代替。\n列表初始化 1 2 3 4 int a=0; int a={0}; int a{0}; int a(0); 上述四种均可为a赋值。\n默认初始化 定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式地初始化，则其值由类确定。\n未初始化的变量含有一个不确定的值，使用未初始化的变量的值绝对是一种错误且严重的编程行为（此行为很难调试）\n究其原因：①、编译器虽然会对部分未初始化的变量提出警告，但其本身并未要求检查此类错误；②、使用未初始化的变量会带来无法预测的结果，形成黑箱！\n强烈建议：对每一个内置类型的变量都应该初始化，虽无强制要求，但是为了程序安全很有必要。\n2.2.2 变量声明和定义的关系 为了允许把程序拆分成多个逻辑部分，C++支持分离式编译（separate compilation）机制，在此机制下程序可以分割为若干个文件，每个文件皆可独立编译。\n为了实现该机制，那么必须能够存在能够在文件共享代码的方法。例如：std::count O(∩_∩)O哈哈~\n在此之下，C++语言将声明和定义区分开来，声明（declaration）使得名字为程序所知，一个文件若想在别处使用该名字则必须包含对此名字的声明。而定义（definition）则负责创建与名字关联的实体。\n变量声明规定了变量的类型和名字。（与定义区别在于：定义还多一项为变量申请存储空间，也可能赋予一个初始值的功能）\n如果想要声明一个变量而非定义该变量，就会在变量前添加关键字extern，同时不要显式的初始化变量。\n1 2 extern int i; //声明i而非定义i int j; //声明且定义j 任何包含了显式初始化的声明即称为定义。同时，在函数体内部，如果试图初始化一个已经被关键词extern标记的变量，将引发错误。同时在函数体外这样做，将会出现警告。\nNote:\n变量能且只能被定义一次，但是可以被多次的声明\n2.2.3 标识符 标识符（identifier）由字母、数字和下划线组成。其必须是字母或下划线开头。\n其变量的命名规范\n变量命名有许多约定俗成的规范，下面这些规范能够有效地提高提高程序的可读性：\n标识符要能体现实际含义 变量名一般用小写字母，比如index，不要使用Index或者INDEX 用户自定义的类名一般以大写字母开头，如Search() 如果标识符由多个单词组成，则单词间应该有明显区分，如Student_name或者StudentName,不可Studentname 2.2.4 名字的作用域 不论在程序的那个位置，使用到的每一个名字都会指向其一个实体。然而，同一名字出现在不同的位置，也有可能指向不同实体。\n名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。\n全局作用域（global scope）定义在函数体之外，声明后在整个程序的范围内都可以使用。 块作用域（block scope）定义于函数体之内，在其函数体内可以使用。 Suggestion\n当第一次使用变量时再去定义它。原因①：有助于更容易找到变量的定义；原因②：当定义位置与其第一次被使用位置很近时，会赋予一个更加合理的初始值。\n嵌套作用域 内层作用域（inner scope） 外层作用域（outer scope） 其被嵌套的作用域是相对的，在作用域中声明了某个名字，其所嵌套的所有作用域都可以使用该名字，同时，也允许在其嵌套作用域中重新定义外层作用域的名字。\nWarning\n如果函数使用到全局变量，不宜再次定义与其名字相同的局部变量。\n2.3 复合类型 复合类型(compound type)是指基于其他类型定义的类型。C++语言中有几种复合类型，这里介绍：引用和指针。\n2.3.1 引用 Note\nC++ 11中新增了一种引用：所谓的“右值引用（rvalue reference）”，这种引用主要用在内置类中。严格来说，我们平常使用的术语“引用（reference）”其实是指“左值引用（lvalue reference）”。\n引用（reference）作用就是为对象起别名。\nPS\n引用其本质上应该是指针常量（即该形式：数据类型* const 变量名），其限制为：能够更改指针对应的值，但是不能修改对应的地址值。所以：引用必须初始化。\n同样的道理，对引用进行的所有操作都是在为与之绑定的对象进行操作，其引用并不是一个对象，无法定义引用的引用。也就不能使用这样的操作：与字面值绑定或者与某个表达式绑定。\n2.3.2 指针 指针（pointer）是“指向（point to）”另一种类型的复合类型。\n其与引用类似，指针也实现对其他对象的间接访问。但是指针与引用又有很多地方不相同：\n①、指针本身就是一个对象，允许对指针的赋值和拷贝，并且在指针的生命周期中可以先后指向多个不同的对象。\n②、指针无须定义时赋初值，但同时和其他内置类型一样，在块作用域内定义指针如果没有初始化，也将拥有一个不确定值。\n获取对象的地址 指针存放某个对象的地址，想要获取地址，需要使用取地址符（操纵符\u0026amp;）\nWarning\n①、因为引用不是对象，所以不能定义指向引用的指针\n②、所有指针的类型都要和它所指向的对象严格匹配，因为在声明语句中指针的类型实际上被用来指定它所指向对象的类型\n指针值 指针值（即地址值）应该属于下列4种情况之一：\n指向一个对象 指向紧邻的对象所占空间的下一个位置 空指针 无效指针，即上述情况之外的其他值 任何试图访问无效指针的值都会引发错误，且编译器并不会检查此类错误，程序员应该清楚任意给定的指针的有效性；虽然2、3两种情况是有效的，但是试图访问其指针指向的对象同样不被允许。\n利用指针访问对象 如果指针指向一个对象，允许使用解引用符（操纵符*）来访问该对象。\nWarning\n解引用操作仅适用于那些明确指向对象的有效指针。\n空指针 空指针（null pointer）不指向任何对象。\nSuggestion\n使用未经初始化的指针是引发运行时错误的一大原因。\n建议初始化所有指针，并且在可能的情况下，尽量等到定义了对象后再定义指针。实在不行，便将指针定义为nullptr，使得编译器明白该指针并未指向任何对象。\n赋值和指针 指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上二者有很大不同，其中最重要的一点就是引用本身并非一个对象。一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。 但是对于指针，则没有这种限制，和其他任何变量（只要不是引用）一样，给指针赋值就是令它存放一个新地址，从而指向一个新对象。\n其他指针操作 若指针值为0，则条件取false，其他情况都返回true。 对于两个类型相同的合法指针，可以进行比较，比较结果为布尔类型。其比较对象是两个指针的存放的地址值。 void* 指针 void*是一种特殊的指针类型，可用于存放任意对象的地址，但是对存放何种对象类型并不了解。\n由于无法知道指针指向的对象是什么类型，所以就不能直接操作void*指针所指向的对象。\n概括来讲：void*就仅仅只是内存空间，无法读取内存空间所存的对象。\n2.3.3 理解复合类型的声明 前面说过：变量的定义包括一个基本数据类型（base type）和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。例如：\n1 int i = 1024, *p = \u0026amp;i, \u0026amp;r = i; /* i是int类型的数，p是int类型指针，r是int类型引用 */ 可能觉得基本数据类型和类型修饰符有什么关系，其实后者不过是声明符的一部分。\nWarning\n有一种错误的观点认为：在定义语句总，类型修饰符作用于本次定义的全部变量。其造成错误看法的原因很多，其中一种是：\n1 int* p1,p2; 在此观点下，会认为p1和p2是两个都是int类型的指针变量。其实只有p1是，p2是int类型变量。其*仅仅修饰了p1。\n所以，为了强调标量具有复合类型，建议将修饰符和变量标识符写在一起。\n指向指针的引用 虽然，引用本身不是对象，无法使用指针指向引用，但是指针本身是对象，可以使用引用指向指针。\n1 2 3 4 5 6 int i = 1024; int *p; int *\u0026amp;r = p; /* r是对指针p的引用，建议从右向左看*\u0026amp;r */ r = \u0026amp;i; /* r本身是引用指针p，所以这里将i的地址赋值给指针p */ *r = 0; /* 指针p指向的i值赋予为0*/ Suggestion\n面对一条较为复杂的指针或者引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。\n2.4 const限定符 有时候我们并不希望定义一个变量，它的值无法改变。这个时候，我们就可以通过const对此类变量加以限定。\n因为const对象一旦完成创建就无法修改其值，所以const对象必须初始化。\n初始化和const const类型的变量与普通变量并没多大区别，其主要限制在于只能在const类型的对象上执行不改变内容的操作。在此限制下还有一种是初始化，如果利用一个对象取初始化另一个对象，则它们是不是const都无关紧要。\n1 2 3 int i =1024; const int ci = i; /* ci的常量特征仅仅在执行改变ci的操作时才发挥作用，这里仅仅对ci进行初始化操作 */ int j = ci; 默认情况下，const对象仅在文件内有效 默认情况下，const对象被设定为仅在文件内有效，当多个文件中出现了同名的const变量时，其实等同于不同文件中分别定义了独立的变量。\n如果希望在多个文件中都可以使用该const类型对象，而无需编译器为每个文件分别生成独立变量。解决方法便是：对于const变量不管是声明还是定义都添加extern关键字。例如：\n1 2 3 4 5 /* file_1.cpp */ extern const int BUFFERSIZE=1024; /* 初始化常量 */ /* file_1.hpp */ extern const int BUFFERSIZE; /* 在头文件中也使用extern关键字，作用是指明该常量并非本文件独有，它的定义在别处出现 */ Note\n如果想要在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字\n2.4.1 const的引用 可以将引用绑定到const对象上，称为对常量的引用(reference to const)。。\n1 2 3 4 const int i=1024; cosnt \u0026amp;r=i; /* 正确，引用的对象和其引用本身都为常量 */ r=42; /* 错误，r是对常量i的引用，常量无法被修改 */ int r2=i; /* 错误，普通引用（对非常量的引用）无法指向常量对象 */ 通俗上讲：我们一般将“对常量（const）的引用”说成“常量引用”。但是严格上讲，并不存放常量引用，因为引用本身就不是一个对象，无法保证引用的不变。\n初始化和对const的引用 初始化常量引用时运行用任意表达式作为初始值，只要其表达式能够转换为引用类型。运行常量引用绑定非常量的对象、字面值或一般表达式。（这也是“引用的类型必须与所引用的类型一致”的两个例外之一）\n1 2 3 4 5 int i =23; const int \u0026amp;v1=i; /* 允许将const int\u0026amp;绑定到一个普通int对象上 */ const int \u0026amp;v2=23; /* 正确，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式 */ const int \u0026amp;v3 = v1*2; /* 正确 */ int \u0026amp;v4=v1*2; /* 错误，无法将常量赋值给普通变量 */ 常量引用仅对引用可参与的操作做出限定，对于引用的对象本身是不是一个常量未作限定。\n1 2 3 4 5 int i = 23; int \u0026amp;v1 =i; const int \u0026amp;v2=i; /* 绑定常量 其实际步骤为：const int temporary = i; const int \u0026amp;v2 = temporary; */ v1 = 0; /* 正确*/ v2=0; /* 错误，v2作为一个常量引用 */ 2.4.2 指针和const 与引用类似，存在指向常量的指针（pointer to const），其不能改变所指对象的值。\n1 2 3 4 const double pi = 3.14; double \u0026amp;ptr= \u0026amp;pi; /* 错误，无法将指向常量的指针指向非常量 */ const double *cptr=\u0026amp;pi; /* 正确 */ *cptr=3.15; /* 错误，无法修改常量的值 */ 由此可以看出：指向常量的指针必定是指针常量。\n与对常量的引用一样并未规定所指的对象必须是一个常量。仅作出不能通过该指针修改对象的值。\n1 2 3 /* 运行指向常量的指针所指向的对象为非常量 */ double dval = 3.14; cptr = \u0026amp;dval; /* 合法 */ 与之“指向常量的指针”（也可以说是“指针常量”）const *ElemType p对应的“常量指针”*ElemType const p。\n1 2 int number=1; int *const p=\u0026amp;number; /* 正确，p将一直指向number变量 */ 在这里指的“常量指针”表示指针定为常量，即存放在指针中的地址为常熟，所以“常量指针”是无法再次指向新的对象。\n2.4.3 顶层const 在此回答一下：什么是常量引用？什么是指针常量？什么是常量指针？\n😆不知道有没有搞糊涂呢？\n那么我们来学习一下顶层const吧！深刻立即这三者。\n指针本身既是对象，同时它又可以指向对象。那么便存在这两个对象是否是常量的关系：\n指针是常量，指向对象不是常量。常量指针ElemType *const pi 指针不是常量，指向对象是常量。指针常量const ElemType *pi 指针是常量，指向对象也是常量。常指针常量const ElemType *const pi 至于如何读，则遵从从右向左读，观察首先遇见的是const还是ElemType。\n回到标题，何为“顶层const”？从上述我们已经了解const定义位置的不同会产生不同结果，所以我们在此下定义：顶层const（top-level const)表示指针本身是个常量，底层const(low-level const)表示所指对象是一个常量。\n同样，此定义具有普适性，我们可以说：顶层const可以表示任意对象为常量，例如：指针、类、算术类型等。底层const则与指针和引用等复合类型的基本类型有关。\n例如：\n1 2 3 4 5 int i=0; int *const p1=\u0026amp;i; /* 不能修改p1值，顶层const */ const int j=0; /* 不能修改j的值，顶层const */ const int *p2=\u0026amp;j; /* 可以修改p1值，底层const */ const int \u0026amp;r=j; /* 用于声明的const都为底层const */ 说完顶层和底层const，那么它们有什么特点？\n当对执行对象进行拷贝操作，顶层const不受影响。\n我们之前说过，执行拷贝操作并不会改变被拷贝对象的值，所以拷入和拷出对象是否是常量都没什么影响。\n例如：i=j;\n但是对于底层const来说拷入和拷出对象必须都为底层const才行。\n1 2 3 int *p3=p2; /* 错误，p2拥有底层const，但是p3并未拥有 */ /* 非常量可以转换为常量 */ p2=\u0026amp;i; 同时，还有一个点：对常量对象取地址其实是一种底层const。\n2.4.4 constexpr和常量表达式 何谓“constexpr”?\nconst expression，常量表达式。即在编译过程中就可得到答案，而非在运行过程中且值不会改变的表达式。\n例如：\n1 2 3 const int SIZE=20; /* 正确 */ const int NEXT=SIZE-1; /* 正确 */ const int RESULT=getValue(); /* 错误 */ C++ 11新特性：constexpr：\n使用场景：当我们无法立刻确定某个常量的初始值时，可以使用该声明类型由编译器检验此变量的初始值是否为常量表达式。\n例如：\n1 2 3 constexpr int i=0; /* 正确 */ constexpr int j=i+1; /* 正确 */ constexpr int k=getValue(); /* 当getValue()函数为constexpr函数时，正确 */ 注意\n当在constexpr声明中定义一个指针，其限定符constexpr仅对指针有效，对所指向的对象无效。\n1 2 3 constexpr int i=10; const int *p=\u0026amp;i; /* 指向int常量的指针 */ constexpr int *p=\u0026amp;i; /* 指向int常量的常量指针 */ 2.5 处理类型 为什么需要进行类型处理？\n由于程序愈发复杂从而导致程序中使用到的类型也愈发繁多，其中不免存在类型名称不明确或难写的情况。这个时候就需要通过对类型处理获取良好地编写和审查代码体验。\n2.5.1 类型别名 type alias，类型别名。类型别名的作用显而易见，为类型起个别名从而获得更好的体验。\n例如：\n1 2 3 4 5 6 /* 将类型名可视化 */ typedef int ElemType; /* 将类型名简单化*/ typedef _Size_Of_Aarry AarrySize; /* 此类型作用是设置全局元素类型 */ typedef double ElementType; /* 将类型名做注释，助于理解 */ 当然，除了使用关键字typedef这一声明语句的基本数据类型之外，C++ 11也规定一种新方式：使用别名声明（alias declaration）来定义类型的别名：\n例如：\n1 using ElemType=int; /* int的别名为ElemType */ 其类型别名与类型名等价。\n2.5.2 auto类型说明符 auto，C++ 11新特性。auto是C++的一个特殊类型声明，它在声明时标识一个自动变量。通过编译器区分析此时表达式所属的类型。类似于JavaScript的var。\n需要注意的是：\n编译器推断出来的auto类型有时候和初始值的类型是不完全一样的，编译器会适当地改变结果类型使其更符号初始化规则。 当引用被用作初始值时，编译器会以引用对象的类型作为auto的类型。 auto会一般会忽略顶层const而保留底层const，若需顶层const则要手动加上。 一个典型的例子：\n1 2 3 4 const std::string str=\u0026#34;hello\u0026#34;; for(auto \u0026amp;c:str){ /* ... */ } 在这个例子中，c的类型是const char \u0026amp;，编译器会将引用对象的类型作为auto的类型，所以auto类型为const char，不会忽略顶层const。\n所以，在一般的定义类型上尽量少用auto语句，我们较难以发现auto的类型。若想要实现类似auto的效果，可以使用下方的decltype类型说明符。\n2.5.3 decltype类型说明符 decltype，类型说明符。C++ 11引入新特性，它的作用是选择并返回操作数的数据类型。\n听起来是不是很模糊🙃，那么直接示例出发：\n1 2 3 const int i=10,\u0026amp;j=i; decltype(i) k=100; /* 我们将i的类型（const int）拿过来给k，那么k的类型为const int */ decltype(j) m=k; /* m的类型即为const int \u0026amp; */ 特殊的：\n1 2 3 4 int i=10,\u0026amp;j=i,*p=\u0026amp;i; decltype(j+1) m; /*int, ① */ decltype(*p) k; /*int\u0026amp;, ② */ decltype((i)) e; /*int\u0026amp;, ③ */ 解释\n语句①： j本身为引用，若语句①中decltype表达式仅有j，则返回值类型为int\u0026amp;，但当将j作为表达式的一部分，那么显然该表达式将会是一个具体值而非引用，所以表达式为j+1其返回值类型为int。通过这种方式我们可以将引用类型转为基本数据类型。\n语句②： 如果decltype表达式仅有解引用操作，那么decltype得到的为引用类型。原因：解引用指针所得到的是指向对象。\n语句③：若对decltype添加多层括号，编译器会将其认为是表达式，而非一层括号表示的该变量的类型。具体来讲，decltype(i)得到的是i的类型，decltype((i))得到的是i的引用。\n2.6 自定义数据结构 何谓“数据结构”？\n数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。\n用本书的理解：数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法。\n常见的基本数据类型并不能满足我们对数据的处理需求，所以特别需要自定义数据结构用于处理特殊的数据。这些自定义的数据结构包括：string、istream、ostream等等。\n编写自己的头文件\n为了处理类，确保在不同文件中使用到同一个类和类定义一致性。所以类通常被定义在头文件中，而且类所在头文件的名字应该与类的名字一致。\n头文件通常包含哪些只能被定义一次的实体，例如：类、const、constexpr变量等。\n在某些情况下，一个源程序可能包含多个同样的头文件，例如：iostream。为了确保头文件多次包含依旧能够正常工作，常用的技术手段是预处理器（preprocessor），同时还会用到头文件保护符（header guard）。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 #ifndef CPP_PRIMER_2_6_HPP #define CPP_PRIMER_2_6_HPP #include \u0026lt;string\u0026gt; struct Sales_data{ std::string isbn; unsigned long sold_number; double sales_revenue; }; #endif //CPP_PRIMER_2_6_HPP 头文件保护符依赖于预处理变量。预处理变量存在两种状态：已定义和未定义。\n我们从示例代码中理解：\n#define指令会将一个名字（比如这里的“CPP_PRIMER_2_6_HPP”，在CLion中该名字的处理方式是项目名称+设定名称）设定为预处理变量。\n以下指令检查某个指定的预处理变量是否已定义：\n#ifdef指令：当变量已定义时为真。 #ifndef指令：当变量未定义时为真。 回到示例，通过#define指令将“CPP_PRIMER_2_6_HPP”设置为预处理变量，当我们第一次使用该头文件时，#ifndef指令检测为真，那么便会将该头文件中#ifndef指令到#endif指令之间内容拷贝到目标程序中。拷贝结束后该头文件已经被定义，那么后续如果再次包含该头文件，则会忽略#ifndef指令和#endif指令之间内容。\n","date":"2025-04-06T00:00:00Z","image":"https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg","permalink":"https://Free-Aaron-Li.github.io/p/c-%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/","title":"C++ 基础： 第二章 变量和基本类型"},{"content":"第九章 顺序容器 前言 本章是对第三章——字符串、向量和数组的扩展延伸，在第三章我们对标准库的顺序容器有一定了解，那么学习完本章我们对顺序容器的知识将会更加完整。\n标准库定义了几种关联容器，关联容器中元素的位置由元素相关联的关键字值决定。我们将在本章对关联容器做一定了解，在第十一章将会介绍关联容器特有的操作。\n在第三章我们就发现，顺序容器在操作上似乎有共通性，原因是在于容器类共享公共的接口，不同容器按照不同方式对其进行扩展。当然每种容器都提供不同的性能和功能的权衡。\n容器可以看作一些特定类型对象的集合。顺序容器（sequential container)为用户（一般是程序员）提供控制元素存储和访问顺序的能力，根据元素加入容器的位置相对应。与之相对的关联容器，其依赖于元素的值，根据关键字的值来存储元素。\n此外，标准库还提供三种容器适配器，分别为容器操作定义不同的接口，借此与容器类型进行适配。\n9.1 顺序容器概述 在前言简述了顺序容器的概念，标准库中存在以下顺序容器：\n顺序容器类型 解释 vector 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢 array 固定大小数组。支持快速随机访问。不能添加或删除元素 string 与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快 deque 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快 list 双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快 forward_list 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快 从上述的解释中，我们不难发现顺序容器有着不同的性能折中。\n例如：\n插入/删除元素较慢（以向容器添加或删除元素为代价）\n无法进行快速随机访问（以非顺序访问容器元素为代价）\n补充\nforward_list和array是C++11中新增加的类型。\nforward_list在设计之初，其目的就是为了获得与最好的手写单向链表数据结构一致的性能，所以该类型并没有size操作，毕竟保存或计算其大小也会比手写链表多出额外开销:)。\narray类型与内置类型概念上一致，但是array更为安全、容易使用。当然，array对象大小是固定的，所以不支持添加和删除元素以及其他改变容器大小的操作。\n虽然我们不愿承认大多数开发者设计的数据结构比标准库中容器运行速度慢，但事实便是如此:)。在C++下的标准库中容器的性能几乎与精心设计优化的同类数据结构一样好（通常更好😉）。\n确定使用哪种顺序容器 如无特殊要求，vector无疑是最好的选择。\n顺序容器并不能依靠随性选择，而应该结合实际需求。当鱼与熊掌不可兼得时，我们必要时还需要通过测试性能获得最佳答案。\n那么以下是一些选择顺序容器的基本原则：\n在没有特殊/很好的理由下，vector是不二之选 如果程序中存在很多容量较小元素，同时空间的额外开销很重要。请不要选择list/forward_list 如果程序要求随机访问元素，则应该选择vector/deque 如果程序要求在容器中间插入/删除元素，则应该选择list/forward_list 如果程序需要头尾位置插入/删除元素，同时不会在中间位置插入/删除元素，则应该选择deque 如果程序只有在读取输入时，在输入阶段需要在容器中间位置插入元素，随后需要随机访问元素，那么 首先，确定是否需要在容器中间位置插入元素。当处理数据时，通常很容易向vector追加数据，再通过调用sort函数重排容器中的元素，相对于直接在容器中间位置插入元素性能更优 如果必须这样做，那么我们应该考虑在输入阶段使用list，在读取阶段将list中内容拷贝到vector中。 开发\n在不确定使用何种容器的情况下，使用公共操作对容器进行操作绝对是最好的选择！例如，无法确定是使用vector还是list，我们应该避免使用下标，而应该使用迭代器操作。\n9.2 容器库概览 容器类型上的操作形成了一种层次：\n某些操作是所有容器类型都提供的 另外一些操作仅针对顺序容器、关联容器或无序容器 还有一些操作只适用于一小部分容器 一般来说，每个容器都定义在一个头文件中，文件名与类型名相同。容器均定义为模板类，所以我们必须提供额外信息来生成特定的容器类型。同时对大多数容器而言，我们还需要提供元素类型信息。\n所有容器类型都提供的操作：\n容器操作 解释 类型别名 iterator 此容器类型的迭代器类型 const_iterator 可以读取元素，但不能修改元素的迭代器类型 size_type 无符号整数类型，足够保存此种容器类型最大可能容器的大小 difference_type 带符号整数类型，足够保存两个迭代器之间的距离 value_type 元素类型 reference 元素的左值类型：与value_type\u0026amp;含有相同 const_reference 元素的const左值类型 构造函数 C c; 默认构造函数，构造空容器(array除外） C c1(c2); 构造c2的拷贝c1 C c(b,e); 构造c，将迭代器b和e指定范围内的元素拷贝到c（array不支持） C c{a,b,c\u0026hellip;}; 列表初始化c 赋值与swap c1=c2 将c1中的元素替换为c2中元素 c1={a,b,c\u0026hellip;} 将c1中的元素替换为列表中元素（ array不支持） a.swap(b) 交换a和b的元素 swap(a,b) 与a.swap(b)等价 大小 c.size() c中元素数目（forward_list不支持） c.max_size() c可保存的最大元素数目 c.empty() 判断c容器元素是否为空 添加/删除元素（array不支持） 注：在不同容器中，这些操作的接口都不同 c.insert(args) 将args中元素拷贝进c c.emplace(inits) 使用inits构造c中的一个元素 c.erase(args) 删除args指定的元素 c.clear() 删除c中所有元素，返回void ==,!= 相等（不相等）运算符 \u0026lt;,\u0026lt;=,\u0026gt;,\u0026gt;= 关系运算符(无序关联容器不支持） 获取迭代器 c.begin(),c.end() 返回指向c的首元素和尾元素之后位置的迭代器 c.cbegin(),c.cend() 返回const_iterator 反向容器的额外成员（forward_list不支持） reverse_iterator 按照逆序寻址元素的迭代器 const_reverse_iterator 不能修改元素的逆序迭代器 c.rbegin(),c.rend() 返回指向c的尾元素和首元素之前位置的迭代器 c.crbegin(),c.crend() 返回const_reverse_iterator 迭代器 与容器类似，迭代器同样存在公共接口。\n运算符 解释 *iter 返回迭代器iter所指元素的引用，解引用 iter -\u0026gt;mem 解引用iter并获取该元素的名为mem的成员，等价于(*item).mem ++iter 令iter指示容器的下一个元素 \u0026ndash;iter 令iter指示容器中的上一个元素 iter1==iter2 判断两个迭代器是否相等，如果两个迭代器指示的是同一个元素或者它们是同一个容器的尾后迭代器，则相等 forward_list迭代器不支持递减运算符\n迭代器范围（iterator range）由一对迭代器表示。两个迭代器分别指向同一个容器中的元素或者尾元素之后元素位置（one past the last element）[one piece :)]。从数学的角度我们可以认为该范围是左闭合区间（left-inclusive interval）。\n那么，我们为什么要采用这种方式的迭代器范围呢？\n好处有三：\n如果begin和end相等，说明范围为空 如果二者不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素 通过对begin的递增，可以使得begin=end 1 2 3 4 5 /* value为可行值 */ while(begin!=end){ *begin=value; ++begin; } 从上例可以看出：在此循环之内都可以安全的解引用begin，begin必定指向一个元素，同时我们也能确定该循环最终必定会结束。\n容器类型成员 在前面的章节中我们遇见过size_type、iterator和const_iterator三种类型。后两种类型都是迭代器类型，加上前面介绍的反向迭代器的reverse_iterator和const_reverse_iterator两种类型，我们现在总共认识五种容器类型。\n上述类型均为类型别名。类型别名的作用是在不了解容器中元素类型的情况下使用它，比如，需要元素类型，可以使用value_type，如果需要元素类型的引用则可以使用reference或const_reference。这在泛型编程中很有作用。\n例如：\n1 2 std::vector\u0026lt;int\u0026gt;::iterator it; std::vector\u0026lt;int\u0026gt;::difference_type df; begin和end成员 begin和end存在多个版本，其中：\n带r版本返回反向迭代器 带c版本返回const迭代器 当对const对象调用这些成员时，获得的是const版本迭代器。\n比较常用的是将auto和begin与end结合，获得的迭代器依赖于容器类型（C++11支持），这样我们可以不用显式声明迭代器类型。\n开发\n在不需要进行访问操作时，应该使用cbegin和cend。\n容器定义和初始化 每个容器类型都定义了一个默认构造函数。容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数（除了array之外）。\n容器定义与初始化 解释 C c 默认构造函数 C c1(c2)C c1=c2 c1初始化为c2的拷贝，c1和c2必须相同类型、相同容器类型、相同元素类型 C c{a,b,c\u0026hellip;}C c={a,b,c\u0026hellip;} c初始化为初始化列表中元素的拷贝。列表中元素类型必须与C的元素类型相容。 C c(b,e) c初始化为迭代器b和e指定范围中的元素的拷贝。 C c(n) c中包含n个元素，这些元素均进行值初始化，且该构造函数为explicit C seq(n,t) c中包含n个初始值为t的元素 注意\narray容器是特殊的。\n容器的默认构造函数中，如果容器为array则容器中元素按照默认方式初始化，否则该容器为空。\n在进行两容器对象拷贝初始化时，array容器除了上述条件还需要保证二者必须具有相同大小。 同样，对容器对象进行列表初始化，列表中元素数目必须小于等于array的大小，对遗漏的元素进行值初始化。\narray容器无法通过迭代器指定范围中的元素进行拷贝，也无法仅指明元素大小的方式初始化容器。\n那么，通过上面的列表，我们可以总结出：\n将一个容器初始化为另一个容器的拷贝 直接进行拷贝C c1(c2)，或者通过迭代器指定元素范围进行拷贝C c1(it_begin,it_end)。当然以上array容器均不可以使用😅 需要注意的是： 当直接通过一个容器的拷贝对另一个容器进行初始化时，两个容器的容器类型和元素类型必须相同，但是如果选择通过传递迭代器参数的方式，则不需要容器类型相同，甚至不需要元素类型相同，只要拷贝的元素能够转换到被初始化的元素类型即可。 1 2 3 4 5 std::vector\u0026lt;std::string\u0026gt; v1{\u0026#34;hello\u0026#34;,\u0026#34;world\u0026#34;,\u0026#34;!\u0026#34;}; std::vector\u0026lt;const char*\u0026gt; word{\u0026#34;h\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;o\u0026#34;,\u0026#34;!\u0026#34;}; std::forward_list\u0026lt;std::string\u0026gt; v2{v1.cbegin(),v1.cend()}; /* const char*转换为string */ std::forward_list\u0026lt;std::string\u0026gt; v3{word.cbegin(),word.cend()}; 既然可以使用迭代器参数来表示一个容器的元素范围，那么也就可以用来表示一个容器的子序列 1 2 /* it_1,it_2分别表示某个正确容器的某个迭代器，其指向正确元素且it_1\u0026lt;it_2 */ std::vector\u0026lt;int\u0026gt; total(it_1,it_2); 列表初始化 当我们采用列表初始化的方式，实际上显式指定容器中每个元素的值并隐含指定了容器的大小。当然array除外🙃 与顺序容器相关的构造函数 除了与关联容器相同的构造函数外，顺序容器（当然不包括array🫠）还提供另外一种构造函数。其会接受一个容器大小和一个（可选）元素初始值。如果不提供元素初始值，则默认会创建一个值初始化容器。 1 2 std::vector\u0026lt;int\u0026gt; v_1(10,1); std::vector\u0026lt;int\u0026gt; v_2(10); 注意： 如果元素类型是内置类型或者具有默认构造函数的类类型，则允许只为构造函数提供一个容器大小参数，但是如果元素类型并没有默认构造函数，那么除了提供容器大小参数外，还必须显式指定元素初始值。 只有顺序容器的构造函数才接受大小参数，关联函数不支持 array具有固定大小 与内置数组一致，标准库array的大小也是类型的一部分。所以在定义array时必须指定元素类型和容器大小 1 2 array\u0026lt;int,10\u0026gt;::iterator it; /* ok */ array\u0026lt;int\u0026gt;::size_type i; /* error */ 因此，在array并不支持普通的容器构造函数，这些构造函数都会确定容器的大小（无论是显式还是隐式）。同时在大多数情况下允许向一个array构造函数传递大小参数是错误的（也是多余的）。 这种固定大小特性同样影响其构造函数的行为。 默认构造的array容器应该是非空的（这点于普通容器不同），其内元素被默认初始化。 在进行列表初始化时，初始值数目需要小于等于array大小。 列表初始化随顺序依次初始化容器内元素，如果存在遗漏则进行值初始化。所以当元素类型是类类型时，该类必须存在默认构造函数，否则值初始化不成功 对array进行拷贝和对象赋值 在内置数组类型下是不允许进行拷贝或者对象赋值操作的，但是array不存在此限制。 要求与其他容器一致，初始值的类型必须与要创建的容器类型相同、元素类型一致。但是还要求容器大小一致，毕竟容器大小也是array类型的一部分。 赋值和swap 在对容器的操作中，赋值运算符就是将左边容器中的全部元素替换成右边容器中元素的拷贝。\n容器赋值运算 解释 c1=c2 将c1中的元素替换成c2中元素的拷贝。c1和c2类型必须相同 c={a,b,c...} 将c1中元素替换为初始化列表中元素的拷贝（array不支持） swap(c1,c2)c1.swap(c2) 交换c1和c2中的元素。c1和c2必须具有相同的类型。swap通常比从c2向c1拷贝元素快得多 c.assign(a,b) 将c中元素替换为迭代器a和b所表示范围内的元素。迭代器a和b不能指向c中元素 c.assign(il) 将c中元素替换为初始化列表il中的元素 c.assign(n,t) 将c中元素替换为n个值为t的元素 注意\nassign操作不支持关联容器和array😉。\n赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效，但是swap操作例外（当然array和string容器除外）。\n总结表格中的特殊点和注意点：\n赋值运算左值和右值\n在c1=c2的格式下，赋值符号左右两边值的大小都将与右值大小一致 在c1={1,2,3}的格式下，c1的大小将会与初始值列表的大小一致 array容器\n和内置数组不一样的，array容器允许赋值，但是赋值符号左右两边的运算对象类型必须一致 由于有运算对象的大小可能和左边对象不一致，所以array类型不支持assign，也不允许使用花括号包围的值列表进行赋值 使用assign（仅顺序容器支持） 赋值运算要求左右两边运算对象必须具有相同类型，那么顺序容器还提供另外一种方式，通过assign成员允许我们向那个不同但是相容的类型赋值。类似于seq成员之于容器初始化 1 2 3 4 list\u0026lt;string\u0026gt; name; vector\u0026lt;const char*\u0026gt; oldstyle; name=oldstyle; /* error */ name.assign(oldstyle.cbegin(),oldstyle.cend()); /* ok */ 由于其旧元素被替换，所以传递给assign的迭代器不能指向调用assign的容器 除了上述的方式外，assign还接受一个整数值和一个元素值 1 2 list\u0026lt;string\u0026gt; name(1); /* 1个元素，为空string */ list\u0026lt;string\u0026gt; name.assign(10,\u0026#34;hi\u0026#34;); /* 10个元素，每个都是hi */ 使用swap\nswap操作交换两个相同类型容器的内容。 1 2 3 vector\u0026lt;string\u0026gt; v1(10); vector\u0026lt;string\u0026gt; v2(20); swap(v1,v2); /* 交换元素，v1将会有20个元素，v2将会有10个元素 */ swap本质上交换的是两个容器内部数据结构，元素本身并未交换。\n所以除了array之外，swap不会对任何元素进行拷贝、删除或者插入操作，因此可以保证在常数时间内完成。 那么就表示指向容器的迭代器、引用和指针在swap操作之后都不会失效，但是在swap之后，已经属于不同的容器了。\n当然，array又是一个例外，swap操作对于两个array是真正交换对应元素。所以，交换两个array所需时间与array中元素数目成正比。\n容器大小操作 每个容器类型都有三个与之大小相关的操作（存在一个例外，forward_list不支持size）。\n成员函数size返回容器中元素的数目 成员函数empty返回当size等于0时布尔值为true，反之为false max_size返回一个大于等于该类型容器所能容纳的最大元素数值 关系运算符 每个容器类型都支持相等运算符（==和!=），除了无序关联容器外的所有容器都支持关系运算符（\u0026gt;、\u0026gt;=、\u0026lt;、\u0026lt;=）。当然关系运算符左右两方对象必须是相同类型容器，保存相同类型元素。\n在前面我们介绍迭代器时就讲述过这些关系运算符的基本运行规则，下面详细描述一遍：\n总体上遵守元素逐对比较，先判元素大小后判容器大小。\n如果两个容器具有相同大小且所有元素都两两相等，则这两个容器相等；否则两个容器不等 如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器 如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等元素的比较结果 例如：\n1 2 3 4 5 6 7 8 9 10 11 a1: 1,3,5,7,9,11 a2：1,3,6 a3：1,3,5,7 a4：1,3,5,7,9,11 a5：1,3,7 那么： a1\u0026gt;a2，虽然a1[2]小于a2[2]，但是a1容量更大 a1\u0026gt;a3，a3相当于a1的子序列 a1=a4，二者逐个元素相等 a2\u0026lt;a5，二者在第三个元素比较上，a5第三个元素更大且二者容器大小一致 从上述我们不难看出容器的关系运算符比较实际上是对元素的关系运算符比较。\n借此我们也会发现，仅元素类型支持关系运算符时，容器之间才能进行比较。\n9.3 顺序容器操作 顺序容器和关联容器的不同之处在于两个组织元素的方式。\n在上文我们了解了所有容器都支持的操作，下面将介绍顺序容器独有的操作。\n向顺序容器添加元素 除了array外，所有标准库容器都提供灵活的内存管理。在运行时可以动态添加或者删除元素改变容器大小。\n添加元素操作 解释 c.push_back(t)c.emplace_back(args) 在c的尾部创建一个值为t或者由args创建的元素，返回void c.push_front(t)c.emplace_front(args) 在c的头部创建一个值为t或者由args创建的元素，返回void c.insert(p,t)c.emplace(p,args) 在迭代器p指向的元素之前创建一个值为t或由args创建的元素，返回指向新添加元素的迭代器 c.insert(p,b,e) 将迭代器b和e指定范围内的元素插入到迭代器p指向元素之前，且b和e不能指向c中元素，返回指向新添加元素的第一个元素迭代器，若范围为空，返回p c.insert(p,i) i为花括号包围的元素值列表。将给定元素添加到迭代器p所指向元素之前，返回指向新添加元素的第一个元素迭代器，若列表为空，返回p 注意\n以上的操作均会改变容器自身大小，所以array容器不支持上述所有操作。\nforward_list有自己专用版本的insert和emplace，同时forward_list不支持push_back和emplace_back。\nvector和string不支持push_front和emplace_front。\n最后，向一个vector、string和deque插入元素会使得所有指向容器的迭代器、引用和指针失效。\n对上述的容器操作进行一个总结：\n使用push_back\n其实在前面我们就已经使用过push_back操作了，实际上就是在某个容器尾部追加一个元素。（除了array和forward_list之外，每个顺序容器都支持push_back）。 常规用法：\n1 container.push_back(word); container可以是string、list、vector或者deque，在container这个容器尾部创建一个word的拷贝元素，且容器size加一。\n关键点就在于容器元素是拷贝，类似于值传递。容器中的元素与提供值的对象没有任何关系，容器中元素的改变都不会影响原始对象，反之亦然。\n使用push_front\n在对push_back支持的容器中，除了vector、string外，其他容器（list、forward_list和deque）还支持push_front操作，其操作是将元素插入到容器头部。 常规用法： 1 container.push_front(word); 其基本用法与push_back一致。 在容器的特定位置添加元素\n前面我们提到的push_front和push_back操作都是在容器的首尾添加元素，那么insert操作则是更为一般的执行添加功能。\n其允许在容器中任何位置添加0个或者多个元素。vector、list、deque和string都支持insert，其中forward_list提供特殊版本的insert操作。\n常规用法：\n1 container.insert(iter,word); insert函数接受一个迭代器作为其函数的第一个参数，该迭代器指出应该在那种位置放置新元素。其迭代器可以指向容器任何位置（包括尾部之后的下一个位置），同时由于迭代器可以指向不存在元素的位置，所以insert函数将元素插入到迭代器所指位置之前。\ninsert函数可以将元素插入到容器的任何位置，但是需要注意的是这样可能会很耗时。\n插入范围内元素\n除了支持上述的参数外，insert函数还可以接受一个元素数目和一个值，类似于对象初始化。 常规用法： 1 container.insert(iter,num,word); insert函数将会将给定数目（num）的元素（word）添加到指定位置（iter）之前，这些元素都会依照定值初始化。 除了接受给定数量的元素外，insert函数还接受一对迭代器和一个初始化列表。 常规用法： 1 2 container.insert(iter,iter_other_begin,iter_other_end); container.insert(iter,{\u0026#39;word_1\u0026#39;,\u0026#39;word_2\u0026#39;,...}); 注意： 无法传递一组指向添加元素的目标容器的迭代器。 在C++11标准下，接受元素个数或者范围的insert版本返回指向第一个新加入元素的迭代器，如果范围为空，不插入任何元素，insert操作会将以第一个参数返回。 使用insert的返回值\ninsert的返回值基本逻辑是：如果添加了新元素，则返回第一个新加入元素的迭代器，如果没有添加，则返回指定容器的迭代器（即第一个参数迭代器）。\n所以，我们可以通过使用insert的返回值，在容器中某个特定位置反复插入元素：\n1 2 3 4 list\u0026lt;string\u0026gt; list auto iter=list.cbegin(); while(cin\u0026gt;\u0026gt;word) iter=list.insert(iter,word); 使用emplace操作\nC++11标准中引入了三个新成员——emplace_front、emplace和emplace_back，分别与push_front、insert和push_back对应，区别是这些操作是构造而不是拷贝元素。\n当我们调用这三个成员函数时，其直接将参数传递给元素类型的构造函数，emplace成员使用这些参数在容器管理的内存空间中构造元素。\n例如：\n1 2 3 4 5 6 /* 假定c保存Sales_data元素 */ /* 在c尾部添加Sales_data元素 */ c.emplace_back(\u0026#34;abc\u0026#34;,25,19); /* 正确，直接将三个参数传递给Sales_data构造函数，再将Sales_data元素创建在c的尾部 */ c.push_back(\u0026#34;abc\u0026#34;,25,19); /* 错误，没有接受这三个参数的push_back版本 */ c.push_back(Sales_data(\u0026#34;abc\u0026#34;,25,19)); /* 正确，构造临时Sales_data对象 */ 对比第一种和最后一种构建方式就可明白emplace_back的操作，当调用emplace_back时，会在容器管理的内存空间中直接创建对象，而使用push_back方式则是创建临时对象，再将临时对象拷贝。\n注意\nemplace函数在容器中直接构造元素，那么传递给emplace函数的参数必须与元素类型的构造函数相匹配。\n访问元素 既然我们可以向容器中添加元素，自然就可以从容器中访问元素的操作。\n顺序容器中访问元素操作 解释 c.back() 返回c中尾元素的引用。若c为空，函数行为未定义 c.front() 返回c中首元素的引用。若c为空，函数行为未定义 c[n] 返回c中下标为n的元素的引用，n是一个无符号整数。若n\u0026gt;=c.size()，则函数行为未定义 c.at(n) 返回下标为n的元素的引用。如果下标越界，则抛出一个“out_of_range”异常 注意\nat和下标操作只适用于string、vector、deque和array。back不适用于forward_list。\n对一个空容器调用front和back是一种严重的程序设计错误。\n由于访问成员函数返回的是引用，且如果容器是const，则返回const引用。所以我们可以通返回的引用修改容器中元素值。\n安全使用下标操作实现随机访问。提供快速随机访问的容器（string、vector、deque和array）都会提供下标运算符。但是我们必须保证下标的合理有效性，下标运算符不会检查下标是否在合法范围，同时编译器也不会检查这种错误。\n如果希望下标合法，可以使用at成员函数，如果下标越界，at将会抛出一个out_of_range异常。\n删除元素 和添加元素方法类似，容器也存在多种删除元素的方式。（当然array除外😅）\n顺序容器的删除操作 解释 c.pop_back() 删除c中尾元素。若c为空，则函数行为未定义。函数返回void c.pop_front() 删除c中首元素。若c为空，则函数行为未定义。函数返回void c.erase(p) 删除迭代器p所指元素，返回一个指向被删元素之后元素的迭代器，若p指向尾元素，则返回尾后迭代器。若p是尾后迭代器，则函数行为未定义 c.erase(b,e) 删除迭代器b和e所指定范围内的元素。返回一个指向最后一个被删元素之后元素的迭代器，若e本身就是尾后迭代器，则函数也返回尾后迭代器 c.clear() 删除c中所有元素。返回void 注意\n由于这些操作会改变容器大小，所以array不支持上述操作。\n与insert和emplace一样，forward_list有自己特殊版本的erase，且forward_list不支持pop_back；vector和string不支持pop_front。\n删除deque中除首尾位置之外的任何元素都会使得所有迭代器、引用和指针失效。指向vector和string中删除点之后位置的迭代器、引用和指针都会失效。\n删除元素的成员函数并不会检查其参数，所以在删除前，请务必确保参数是正确的。\npop_front和pop_back成员函数 pop_front和pop_back成员函数分别删除首元素和尾元素。\n与vector和string不支持push_front类似，这两个容器也不支持pop_front。同样与forward_list不支持push_back类似，该容器也不支持pop_back。\n与元素访问成员函数类似，不能对一个空容器执行弹出操作。\n从容器内部删除元素 成员函数erase从容器中指定位置删除元素，既可以删除一个迭代器指定的单个元素，也可以删除由一对迭代器指定范围内的所有元素。这两种形式的erase都返回指向删除的（最后一个）元素之后位置的迭代器。 除了通过一组迭代器方式删除指定范围元素，也可以调用clear函数删除容器中所有元素。 特殊的forward_list操作 forward_list容器是由单链表组成的，所以其对容器的操作与其他容器（vector、list、deque等）不同，所以C++专门定义了其特殊版本的forward_list操作。\n1 2 flowchart LR elem1--\u0026gt;elem2--\u0026gt;elem3--\u0026gt;elem4 当删除elem3会改变elem2的值 1 2 flowchart LR elem1--\u0026gt;elem2---\u0026gt;elem4 单链表中对元素的增删下，假设我们删除elem3 其元素之前的元素（elem4）的后继将会改变，同时其元素之前的元素（elem2）的前驱也会发生改变。这就导致我们没有简单的方式来获取一个元素的前驱，所以在forward_list中添加或者删除元素实质上是通过改变给定元素之后的元素（elem2）来完成的。\n所以这就是forward_list的特殊之处，其操作的实现方式与其他容器的不同导致该容器并没有定义insert、emplace和erase，而是对应定义的insert_after、emplace_after和erase_after。\nforward_list插入或删除元素操作 解释 c.before_begin()c.cbefore_begin() 返回指向链表首元素之前不存在的元素的迭代器。此迭代器不能解引用。 c.insert_after(p,t)c.insert_after(p,n,t)c.insert_after(p,b,e)c.insert_after(p,i) 在迭代器p之后的位置插入元素。t表示对象，n表示数量，b和e表示一组迭代器（其不能指向c内元素），i表示一个花括号列表。返回一个指向最后一个插入元素的迭代器。如果范围为空则返回p。若p为尾后迭代器，则函数未定义 emplace_after(p,args) 使用args在p指定位置之后创建一个元素。返回指向这个新元素的迭代器。若p为尾后迭代器，则函数行为未定义 c.erase_after(p) c.erase_after(p,e) 删除p指向的位置之后的元素，或删除从p到e之间的元素。返回一个指向被删除元素之后元素的迭代器，若不存在则返回尾后迭代器。如果p指向c的尾元素或者是一个尾后迭代器，则函数行为未定义 在处理forward_list中增删元素时，我们需要关注两个迭代器——一个指向我们要处理的元素，另一个指向其前驱。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 /* 删除forward_list容器中的奇数 */ std::forward_list\u0026lt;int\u0026gt; list{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; auto prev = list.before_begin(); /* this is previous node */ auto curr = list.begin(); /* this is current node */ while (curr != list.end()) { if (*curr % 2) { curr = list.erase_after(prev); /* update current node */ } else { prev = curr; /* move previous node */ ++curr; /* move current node */ } } 改变容器大小 C++提供resize函数用于修改容器的大小（当然，这其中不包括array），如果当前容器大小大于所要求大小，则容器后部的元素会被删除；如果容器大小小于要求大小，则新元素（默认初始化）将会添加在容器尾部。\n顺序容器大小操作 解释 c.resize(n) 调整c的大小，将其修改为存储n个元素 c.resize(n,t) 调整c的大小，其添加的元素将会被初始化为t 例如：\n1 2 3 4 list\u0026lt;int\u0026gt; list(10,2); list.resize(15); /* 在list末尾添加5个新元素，其值为0，c大小为15*/ list.resize(20,3); /* 在list末尾添加5个新元素，其值为3，c大小为20 */ list.resize(10); /* 删除list后部10个元素，c大小为10，所有元素值为2 */ 容器操作可能使迭代器失效 对容器的操作可能会导致指向容器元素的指针、引用或者迭代器失效，这会引发严重的程序设计错误，同时很可能引起与未初始化指针一样的问题。\n向容器中添加元素 如果容器vector或者string,且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍然有效，但是指向插入位置之后元素的迭代器、指针和引用会失效 对于deque,插入到除了首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但是指向存在的元素的引用和指针不会失效 对于list和forward_list，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍然有效 向容器删除一个元素 对于list和forward_list,指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针仍然有效 对于deque,如果在首尾之外的任何位置删除元素，那么指向其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但是其他迭代器、引用和指针不受影响；如果删除首元素，上述也不受影响 对于vector和string,指向被删除之前元素的迭代器、引用和指针仍然有效 开发\n管理迭代器\n当使用迭代器（指向容器元素的指针或者引用）时，最小化要求迭代器必须保持有效的程序片段是一个好的方法。\n编写改变容器的循环程序 对于可能出现的指向失效问题，在循环程序中必须保证其指向的可靠。如果循环中使用insert或者erase， 那么我们可以借用其函数返回迭代器的方式来更新迭代器 不要保存end返回的迭代器 当我们添加/删除vector或者string的元素后，或者deque中首元素之外任何位置添加/删除元素后，原来end返回的迭代器总是会失效 如果在一个循环中插入/删除deque、string或者vector中的元素，不要缓存end返回的迭代器 9.4 vector对象是如何增长的 vector容器本身支持快速随机访问。为了支持这一特性，那么vector容器将元素连续存储。同时vector又支持容器大小可变，那么如果容器需要新增元素，不可能在容器尾后随意新建连续空间，vector容器必须新建一个空间，并将原本元素和新元素添加入新内存空间。但是如果每次新增一个元素就需要移动内存空间，对于性能要求是不可接受的。\n在此基础上，C++标准库开发者设计了可以减少容器空间重新分配次数的策略。在创建vector和string上实际的内存空间比需求空间更大。预留的空间用于备用，以此可以保留更多元素。\n那么这里就存在管理内存容器的操作了，所以vector和string提供一些成员函数，其允许我们对容器实现中内存分配部分互动。\n容器大小管理操作 解释 c.capacity() 不重新分配内存空间的情况下，c可以保存多少元素 c.shrink_to_fit() 将capacity()减少与size()相同大小 c.reserve(n) 分配至少能容纳n个元素的内存空间 注意\nshrink_to_fit仅支持vector、string和deque容器，capacity和reserve仅支持vector和string容器。 reserve并不会改变容器中元素的数量，仅影响vector预先分配多大的内存空间。（注意一个是元素数量，一个是容器内存空间大小）\n在实际对容器大小管理上，总结来讲：只有当需要的内存空间超过当前容量时，reserve调用才会改变vector的容量，如果需求大小大于当前容量，reserve至少分配与需求一样大的内存空间（可能更大）。\n具体来讲：\n如果需求大小小于或者等于当前容量，reserve什么也不会做。 特别的，当需求大小小于当前容量时，容器不会退回内存空间。所以，在调用reserve之后，capacity将会大于或者等于传递给reserve的参数。 调用reserve永远不会减少容器占用的内存空间。 C++11下，通过shrink_to_fit函数可以溢出多余的内存空间，但是具体实现下这是可以忽略的，也就是说调用该函数不一定退回内存空间。 在前面我们就提到size和capacity是两个不同的概念，size用于指代容器中已经保存的元素数量，而capacity用于指代容器中在不分配新内存空间下最多可以保存的元素（也就是说，capacity数量=size数量+预留数量）。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 int main() { std::vector\u0026lt;int\u0026gt; vector; std::cout \u0026lt;\u0026lt; \u0026#34;the size is: \u0026#34; \u0026lt;\u0026lt; vector.size() \u0026lt;\u0026lt; \u0026#34;,and the capacity is: \u0026#34; \u0026lt;\u0026lt; vector.capacity() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; for (std::vector\u0026lt;int\u0026gt;::size_type i = 0; i != 10; ++i) { vector.push_back(i); } std::cout \u0026lt;\u0026lt; \u0026#34;now,the size is: \u0026#34; \u0026lt;\u0026lt; vector.size() \u0026lt;\u0026lt; \u0026#34;,and the capacity is: \u0026#34; \u0026lt;\u0026lt; vector.capacity() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 其结果为：\n1 2 the size is: 0,and the capacity is: 0 now,the size is: 10,and the capacity is: 16 从上述结果可以看出，标准库会根据其具体实现为容器多分配一些内存空间。当需求数量超过capacity数量时，那么就必须为vector分配新空间，且标准库实现策略是将新分配空间的大小设置为原空间的两倍。\n从某种意义上来讲，当我们存储大量数据于vector时，该标准库实现策略是显得不够“聪明”的，因为这样可能会浪费内存资源，但是相较于重新分配空间，这样又显得合理。\n我们可以为每个vector实现选择自己的内存分配策略，但是需要注意：只有在迫不得已的情况下才分配新的内存空间。\n9.5 额外的string操作 额外的string操作大部分是针对string类和C风格字符数组之间的相互转换和允许使用下标替代迭代器。\n构造string的其他方法 除了在3.2.1节已经了解过的构造方式，以及与其他顺序容器相同的构造方式，string还有：\n构造string方式 解释 string s(cp,n) s是cp指向的数组中n个字符的拷贝，cp指向数组至少包含n个字符 string s(s2,pos2) s是string s2从下标pos2开始的字符的拷贝，若pos2\u0026gt;s2.size()，构造函数的行为未定义 string s(s2,pos2,len2) s是string s2从下标pos2开始len2个字符的拷贝。若pos2\u0026gt;s2.size()，构造函数行为未定义。不管len2的值是多少，构造函数至多拷贝s2.size()-pos2个字符。 示例：\n1 2 3 4 5 6 7 8 9 10 int main() { const char*c =\u0026#34;hello world!\u0026#34;; char cl[]={\u0026#39;h\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;o\u0026#39;}; std::string s1(c); /* hello world! */ std::string s2(cl,2); /* he */ std::string s3(c,5); /* hello */ std::string s4(c,5,6); /* world */ std::string s5(cl); /* 未定义 */ std::string s6(c,16); /* abnormal: out_of_range */ } 注意\nC风格字符是在文本末尾添加一个空格作为结尾，所以指针指向的数组（cl）必须以空字符结尾，这样拷贝操作才能在遇到空字符时停止。\n存在这种情况，如果我们传递给构造函数一个计数值，那么数组就可以不用空字符结尾。但是，如果我们没有传递计数值且数组也没有以空字符结尾，或者给定计数值大于数组大小，则该构造函数行为未定义。\nsubstr操作用于返回一个string，其为原本string的一部分或者全部的拷贝，可以通过传递一个开始位置和计数值获得。\n子字符串操作 解释 s.substr(pos,n) 返回一个string,包含s中从pos开始的n个字符的拷贝。pos默认0,n默认s.size()-pos。 示例：\n1 2 std::string str{“hello world!\u0026#34;}; std::string substr=str.substr(0,5); /* hello */ 如果开始位置超过string大小，抛出out_of_range。如果开始位置加上计数值大于string大小，则substr函数会调整计数值，让其只能拷贝到string的末尾。\n改变string的其他方法 总结来说：\n修改string的操作 解释 s.insert(pos,args) 在pos之前插入args指定的字符。pos可以是一个下标或者迭代器。接受下标的版本返回一个指向s的引用；接受迭代器的版本返回指向第一个插入字符的迭代器 s.erase(pos,len) 删除从位置pos开始的len个字符。如果len被省略，则删除从pos开始直至s末尾的所有字符。返回一个指向s的引用 s.assign(args) 将s中的字符替换为args指定的字符。返回一个指向s的引用 s.append(args) 将args追加到s.返回一个指向s的引用 s.replace(range,args) 删除s中范围range内的字符，替换为args指定的字符。range可以是一个下标和一个长度，或者是一对迭代器。返回一个指向s的引用 args可以是下列形式之一，append和assign可以使用下列所有形式。\nstr不能与s相同，迭代器b和e不能指向s。\n形式 解释 str 字符串 str,pos,len str中从pos开始最多len个字 cp,len 从cp指向的字符数组的前（最多）len个字符 cp cp指向的以空字符结尾的字符数组 n,c n个字符c b,e 迭代器b和e指定的范围内的字符 初始化列表 花括号包围的，以逗号分隔的字符列表 replace和insert所允许的args形式依赖于range和pos是如何指定的。\nreplace replace insert insert args可以是 (pos,len,args) (b,e,args) (pos,args) (iter,args) 是 是 是 否 str 是 否 是 否 str,pos,len 是 是 是 否 cp,len 是 是 否 否 cp 是 是 是 是 n,c 否 是 否 是 b2,e2 否 是 否 是 初始化列表 string类型除了常规的操作外，还定义了额外的insert和erase版本。\nstring支持接受下标版本：\n1 2 s.insert(s.size(),5,\u0026#39;!\u0026#39;); /* 在s末尾插入5个！*/ s.erase(s.size()-5,5); /* 从s末尾倒数删除5个字符 */ 当然也接受C风格字符数组：\n1 2 3 const char *cp=\u0026#34;hello\u0026#34;; s.assign(cp,2); /* he */ s.insert(s.size(),cp+2); /* hello */ 同时可以插入其他string：\n1 2 3 string s1=\u0026#34;some string\u0026#34;,s2=\u0026#34;some other string\u0026#34;; s.insert(0,s2); /* 在s[0]之前插入s2的拷贝 */ s.insert(0,s2,0,s2.size()); /* 在s[0]之前插入s2[0]开始的s2.size()个字符 */ 结果：\n1 2 some other string some other stringsome other string 总的来说，参数一为目标string下标开头，参数二为内容string开头，在目标string前插入string。\nappend和replace函数 append函数是在string末尾进行插入操作的简写方式。\n常规在string末尾插入string，使用：s.insert(s.size,\u0026quot;this\u0026quot;);，而append简写为：s.append(\u0026quot;this\u0026quot;);。\nreplace操作则是调用erase和insert的简写方式：\n1 2 3 4 5 // 将hello.world! 修改为hello,world! s.erase(5,1); s.insert(5,\u0026#34;,\u0026#34;); // 简写方式 s.replace(5,1,\u0026#34;,\u0026#34;); /* 位置5,删除字符数1,插入“,” */ 改变string的多种重载函数 根据前文的表格总结来说，\nassign和append函数无须指定要替换string中哪个部分：assign总是替换string中的所有内容，append总是将新字符追加到string末尾。\nreplace函数提供了两种指定删除元素范围的方式。可以通过一个位置和一个长度来指定范围，也可以通过一个迭代器范围来指定。insert函数允许我们用两种方式指定插入点：用一个下标或一个迭代器。在两种情况下，新元素都会插入到给定下标（或迭代器）之前的位置。\n可以用几种方式来指定要添加到string中的字符。新字符可以来自另一个string,来自一个字符指针（指向的字符数组），来自一个花括号包围的字符列表，或者是一个字符和一个计数值。当字符来自一个string或一个字符指针时，我们可以传递一个额外的参数来控制是拷贝部分还是全部字符。\n并不是每个函数都支持所有形式的参数。\nstring搜索功能 string操作 解释 s.find(args) 查找s中args第一次出现的位置 s.rfind(args) 查找s中args最后一次出现的位置 s.find_first_of(args) 在s中查找args中任何一个字符第一次出现的位置 s.find_last_of(args) 在s中查找args中任何一个字符最后一次出现的位置 s.find_first_not_of(args) 在s中查找第一个不在args中的字符 s.find_last_not_of(args) 在s中查找最后一个不在args中的字符 搜索操作返回指定字符出现的下标，如果未找到则返回npos。\n其中，args必须是一下形式之一：\nargs 解释 c,pos 从s中位置pos开始查找字符c。pos默认为0 s2,pos 从s中位置pos开始查找字符串s2。pos默认为0 cp,pos 从s中位置pos开始查找指针cp指向的以空字符结尾的C风格字符串。pos默认为0 cp,pos,n 从s中位置pos开始查找指针cp指向的数组的前n个字符。pos和n无默认值 总结来说，string类一共提供6个搜索函数，每个函数有4个重载版本。每个搜索操作返回一个string::size_type值，用于表示匹配位置下标，如果失败，则返回一个string::npos的static成员。\n标准库将npos定义为const string::size_type类型，且初始值为-1。同时由于npos是一个unsigned类型，所以该初始值意味着npos等于任何string最大的可能大小。\n示例：\n1 2 3 4 string name(\u0026#34;Tom Li1\u0026#34;); auto pos_1=name.find(\u0026#34;Tom\u0026#34;); // pos_1=0 string numbers(\u0026#34;0123456789\u0026#34;); auto pos_2=name.find_first_not_of(numbers); //pos_2=0 注意：搜索函数以及其他string操作对大小写敏感。\n从上述的args可选列表中，我们可以发现在前三项都存在一个pos参数，用于指定从哪个位置进行搜索。存在一个常见的程序设计模式，其便是运用该可选参数进行循环搜索子字符串出现的所有位置。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 std::string::size_type pos=0; std::string name(\u0026#34;Tom II is Tom father\u0026#34;); std::string find_string(\u0026#34;Tom\u0026#34;); while ((pos=name.find(find_string,pos))!=std::string::npos) { std::cout\u0026lt;\u0026lt;\u0026#34;found number at index: \u0026#34;\u0026lt;\u0026lt;pos \u0026lt;\u0026lt;\u0026#34; element is \u0026#34;\u0026lt;\u0026lt;name[pos]\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; ++pos; } // 结果为： // found number at index: 0 element is T // found number at index: 10 element is T 除了从左向右的搜索方式外，也可以使用函数rfind、find_last_of和find_last_not_of实现从右向左的搜索方式。\n示例：\n1 2 3 4 5 6 7 std::string::size_type pos = 0; std::string name(\u0026#34;Tom II is Tom father moT\u0026#34;); std::string find_string(\u0026#34;Tom\u0026#34;); pos = name.rfind(find_string); std::cout \u0026lt;\u0026lt; \u0026#34;found number at index: \u0026#34; \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; \u0026#34; element is \u0026#34; \u0026lt;\u0026lt; name[pos] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 结果为： // found number at index: 10 element is T compare函数 compare函数与C标准库中strcmp函数类似，根据string对象是否等于、大于或者小于参数指定的字符串，返回0、正数或者负数。\ncompare函数有六个参数版本：\ns.compare的参数形式 解释 s2 比较s和s2 pos1,n1,s2 将s中从pos1开始的n1个字符与s2进行比较 pos1,n1,s2,pos2,n2 将s中从pos1开始的n1个字符与s2中从pos2开始的n2个字符进行比较 cp 比较s与cp指向的以空字符结尾的字符数组 pos1,n1,cp 将s中从pos1开始的n1个字符与cp指向的以空白字符结尾的字符数组进行比较 pos1,n1,cp,n2 将s中从pos1开始的n1个字符与cp指向的地址开始的n2个字符进行比较 数值转换 字符串中包含数值的字符可以通过标准库函数转换为整数或者浮点数，即为数值转换。\nstring和数值之间的转换 解释 to_string(val) 一组重载函数，返回数值val的string表示。val可以是任何算术类型，其均有相应的to_string。同时，小整型将会被提升 stoi(s,p,b)stol(s,p,b)stoul(s,p,b)stoll(s,p,b)stoull(s,p,b) 返回s的其实字串（表示整数内容）的数值，返回值类型分别是int、long、unsigned long、long long、unsigned long long。b表示转换所有的基数，默认值为10。p是size_t指针，用来保存s中第一个非数值字符的下标，p默认为0,即，函数不保存下标 stof(s,p)stod(s,p)stold(s,p) 返回s的起始字串（表示浮点数内容）的数值，返回值类型分别是float、double或者long double。参数p的作用与整数转换函数中一样 string参数中第一个非空白符必须是符号（+或者-）或者是数字。当然它也可以是用0x或者0X开头表示十六进制数。\n对于将字符串转换为浮点数的函数，string参数也可以以“.”开头，同时可以使用e或者E表示指数部分。\n对于将字符串转换为整数的函数，根据基数的不同，string参数可以包含字母字符，对应大于数字9的数。\n最后，如果string无法转换为一个数值，函数将会抛出invalid_argument异常，如果转换得到的数值无法用任何类型表示，则抛出out_of_range异常。\n9.6 容器适配器 适配器（adaptor）是一种标准库的通用概念。\n容器、迭代器和函数都有适配器。本质上，适配器作为一种机制，能够使某事物行为看起来像另一种事物一样。\n容器适配器所做的便是：接受一种已有的容器类型，使其行为看起来像一种不同的类型。如：stack适配器接受一个顺序容器（除array和forward_list之外），让其看起来像stack（堆），实际上标准库种并没有stack容器。\n下表显示容器适配器通用操作与类型：\n所有容器适配器均支持的操作和类型 解释 size_type 无符号整数类型，足以保存当前类型的最大对象的大小 value_type 元素类型 container_type 实现适配器的底层容器类型 A a; 创建一个名为a的空适配器 A a(c); 创建一个名为a的适配器，带有容器c的一个拷贝 关系运算符 每个适配器都支持所有关系运算符：==、!=、\u0026lt;、\u0026lt;=、\u0026gt;和\u0026gt;=，这些运算符返回底层容器的比较结果 a.empty() 若a包含任何元素，返回false,否则返回true a.size() 返回a中的元素数目 swap(a,b)a.swap(b) 交换a和b的内容，a和b必须有相同类型，包括底层底层容器类型也必须相同 定义一个适配器 每个适配器存在两种构造函数：\n默认构造函数，接受一个容器的构造函数拷贝该容器来初始化适配器，创建一个空对象。 1 2 deque\u0026lt;int\u0026gt; deq; stack\u0026lt;int\u0026gt; stk(deq); // 从deq拷贝元素到stk 将一个命名的顺序容器作为第二个类型参数进行重载默认容器类型。 1 2 3 4 5 // 在vector上实现的空栈 stack\u0026lt;string,vector\u0026lt;string\u0026gt;\u0026gt; str_stk; // str_stk2在vector上实现，初始化时保存vector\u0026lt;string\u0026gt;的拷贝 vector\u0026lt;string\u0026gt; svec; stack\u0026lt;string,vector\u0026lt;string\u0026gt;\u0026gt; str_stk2(svec); 标准库中定义了三种顺序容器适配器：stack、queue和priority_queue。不同的适配器对已有的容器存在限制。\n所有的适配器都要求容器具有添加、删除和访问为元素的能力。排除array、forward_list stack要求具有push_back、pop_back和back操作。对除上述排除容器，其他容器均可。 queue要求具有back、push_back、front和push_front操作。排除vector，仅能构造于list或者deque之上。 priority_queue要求除了front、push_back和pop_back之外，还需要具有随机访问能力。排除list，仅能够构造于vector或者deque之上。 注意\n在接下来介绍栈和队列适配器时，均需要注意的是每个容器适配器会基于底层容器类型的操作定义自己的特殊操作，我们在使用过程中可以使用这些特殊操作，但是无法直接使用底层容器类型的操作。 如：\n1 2 stk.push(item); // 压栈元素item stk.push_back(item); // 错误，无法直接调用底层容器操作 栈适配器 栈适配器定义自傲stack头文件中。\n除了上述通用适配器操作外，栈适配器还具有：\n未列出的栈操作 解释 s.pop() 删除栈顶元素，但是不返回该元素值 s.push(item)s.emplace(args) 创建一个新元素压入栈顶，该元素通过拷贝或者移动item而来，或者由args构造 s.top() 返回栈顶元素，但是不将元素弹出栈 栈默认基于deque实现，也可以在list或者vector之上实现。\n队列适配器 queue和priority_queue定义在queue头文件中。\n除去通用的适配器操作，队列适配器还具有：\n未列出的queue和priority_queue操作 解释 q.pop() 弹出queue的首元素或priority_queue的最后优先级元素，但是并不返回此元素 q.front()q.back() 返回首元素或者尾元素，但不删除此元素。只适用于queue q.top() 返回最后优先级元素，但不删除该元素。只适用于priority_queue q.push(item)q.emplace(args) 在queue末尾或priority_queue中恰当位置创建一个元素，其值为item，或者由args构造 queue默认基于deque实现，priority_queue默认基于vector实现。\nqueue也可以用list或者vector实现，priority_queue也可以用deque实现。\n双端队列（deque）区别于一般的队列，只能从队尾入队，从队首出队。双端队列是可以同时从队首入队和出队，也可以同时从队尾入队和出队的队列。\n标准库中queue采用的则是先进先出（first-in,first-out,FIFO）的存储和访问策略，这便是常规的队列。\npriority_queue则在常规的队列基础上增加优先级策略，新加入的元素会排在所有优先级比它低的已有元素之前。\n总结 标准容器库是模板类型（这是无疑的），其元素安装顺序存放，通过位置访问。且顺序容器具有公共接口。\n所有的容器都具有高效的动态内存管理，其中vector和string提供更为精细的内存管理控制，其通过reserve（分配指定内存空间）和capacity（内存至少可以保存元素数）实现。\n容器本身定义的操作很少。\n对容器进行添加或者删除元素操作时，可能会导致迭代器、指针和引用失效。特别实在循环情况下，需要注意迭代器、指针和引用的使用。\n","date":"2025-04-06T00:00:00Z","image":"https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg","permalink":"https://Free-Aaron-Li.github.io/p/c-%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/","title":"C++ 基础： 第九章 顺序容器"},{"content":"第六章 函数 前言 何谓函数？\n函数就是命了名的代码块😄。通过调用函数执行对应代码，实现目标效果。函数可以通过重载的方式，实现同一个名字多种实现。\n介绍：\n函数的定义 函数的声明 重载函数 编译器如何选择与之匹配的函数版本 6.1 函数基础 典型的函数：\n1 2 3 4 5 6 7 8 9 void test(int n){ /* ... */ } int main(){ int x; /* 实参 */ test(x); /* 调用函数 */ return 0; /* 返回值 */ } void，返回类型（return type）；test函数名；(int n)，括号内存放形参（parameter），一个函数可以有0个或多个形参；{}，函数体（function body）。\n通过使用调用运算符（call operator）来执行函数。调用运算符形式为一对括号，其作用于一个表达式（可以是函数也可以是指向函数的指针）；括号内用于存放实参（argument）列表，用于初始化函数的形参。调用表达式的类型就是函数的返回类型。\n函数调用 函数调用有两项任务：\n实参初始化函数对应的形参 将控制权转移给被调函数 在函数中，return语句也有两项任务：\n返回return语句中的值（如果有） 将控制权从被调函数转移到主调函数 函数的返回值一般用于初始化调用表达式的结果。\n形参和实参 实参是形参的初始值 没有规定实参的求值顺序，所以编译器能够以任意可行顺序对实参求值 实参的类型必须与形参类型匹配（不一定一致） 实参的数量必须与形参数量一致 函数形参列表 函数的形参列表可以为空，但不能没有。😀\n1 2 3 4 5 /* 隐式定义空形参列表 */ void test_1(){ /* ... */} /* 显式定义空形参列表 */ void test_2(void){/* ... */} 在通常情况下，直接写一个空的空格表示空形参列表。当然，为了与C语言兼容，也可以写一个void显式定义空形参列表。\n每个形参都是含有一个声明符的声明，所以哪怕两个形参类型一致，都需要分开写出来。当然也保证每个形参名字都是独一无二的，且函数最外层作用域中的局部变量也不能和函数形参名一致。\n1 void test_3(int a,int b){ /* ... */} 函数返回类型 如果返回类型为void，则表示不返回任何值。\n函数无法返回数组类型或函数类型，但是可以返回数组指针或函数指针。\n局部对象 补充\n名字有作用域，对象有生命周期。\n名字的作用域是程序文本的一部分，名字在其中可见。 对象的生命周期是程序执行过程中该对象存在的一段时间。 函数体本质上是一个语句块，其自构成一个作用域。形参和函数体内定义的变量称为局部变量（local variable）。局部变量自身具有“隐藏性”，对局部变量而言，在外层作用域的同名的所有声明都是隐藏的。\n关于局部变量的生命周期，其依赖于定义方式。\n自动对象 对当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。只存在与块执行期间的对象称为自动对象（automatic object）。当块执行结束后，块中创建的自动对象的值就变成未定义的。\n对于局部变量对应的自动对象来说，分为两种情况：\n如果变量定义本身含有初始值，就使用该初始值初始化 如果变量定义不含初始值，执行默认初始化 那么存在这种情况：内置类型的未初始化局部变量就会产生未定义的值。\n局部静态变量 对于哪些希望函数结束，函数内定义的变量依旧有效，那么便可以使用局部静态对象（local static object）。\n如果局部静态变量没有显式的初始值，那么该对象将使用默认值作为初始值。\n函数声明 函数名字必须在使用前声明（这似乎是常理😉）。\n函数的声明用于函数的定义类似，唯一区别在于函数无需函数体，用分号代替。\n函数声明可以不用写形参的名字（笔者我之前就经常忽略形参的名字，但这并不是个好习惯。现在使用CLion编写时，一般编写函数声明，再由CLion自动生成函数定义头部），但是，写上形参的名字还是有好处的，它可以帮助使用者更好地理解函数的功能。\n函数三要素:\n返回类型 函数名 形参类型 函数的三要素已经可以描述函数的接口了，能够说明该函数所需的全部信息。因此，函数声明也被称为函数原型（function prototype）。\n在头文件中进行函数声明 函数声明应该存放在头文件中，同时函数定义应该在源文件中。\n含有函数声明的头文件应该被包含到定义函数的源文件中。\n分离式编译 分离式编译（separate compilation），其编译允许我们把程序分割到几个文件中去，每个文件独立编译。\n这里使用Linux平台下的GCC下的g++（GUN C++ Compiler）编译器完成分离式编译：\n首先创建三个文件：fact.cpp、factMain.cpp和Chapter6.hpp，fact.cpp文件用于存放fact函数的定义;factMain.cpp 文件用于存放main函数并调用fact函数；Chapter6.hpp文件用于存放fact函数声明和导入iostream库。\n下面给出文件内容：\nChapter6.hpp\n1 2 3 4 5 6 7 8 #ifndef CHAPTER6_HPP #define CHAPTER6_HPP #include \u0026lt;iostream\u0026gt; int fact(int value); #endif // !CHAPTER6_HPP fact.cpp:\n1 2 3 4 5 #include \u0026#34;Chapter6.hpp\u0026#34; int fact(int value){ return value; } factMain.cpp:\n1 2 3 4 5 6 7 8 #include \u0026#34;Chapter6.hpp\u0026#34; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;iostream\u0026gt; int main(){ int value=10; std::cout\u0026lt;\u0026lt;fact(value)\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } 编译过程：\n①、使用g++编译器编译fact.cpp和factMain.cpp生成中间代码文件：\n1 $ g++ -c fact.cpp \u0026amp;\u0026amp; g++ -c factMain.cpp ②、使用g++将中间代码文件链接在一起形成可执行文件：\n1 $ g++ fact.o factMain.o -o main ③、执行可执行文件，得到结果：\n1 2 $ ./main 10 这个时候，查看当前文件夹下，应该存在如下文件：\n1 2 $ ls Chapter6.hpp fact.cpp factMain.cpp factMain.o fact.o main* 其中，.hpp表示C++头文件，.cpp表示C++源文件，.o表示Linux平台下的中间代码文件（Windows下为.obj），mian* 表示Linux平台下的可执行文件（Windows下为main.exe）\n6.2 参数传递 形参初始化的机理和变量初始化一致。\n形参的类型决定了形参和实参交互的方式。如果形参是引用类型，那么它将被绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。\n由此，我们可以说如果形参是引用类型，那么其对应的实参被引用传递（passed by reference）或者说函数被传引用调用（called by reference）。如果实参的值被拷贝给形参，那么说这样的实参被值传递（passed by value）或者函数被传值调用（called by value）。\n传值参数 在之前我们使用变量的初始化时，如果不使用引用类型的变量，其初始化仅是将变量值拷贝给被初始化对象，其本身并未变化。\n1 2 3 int i=10; int j=i; j=1; /* j的值发生改变，为1，但是i的值并未改变。*/ 传值参数类似，函数对形参所做的所有操作并不会影响到实参。\n指针形参 指针的行为和其他非引用类型一致。当执行指针拷贝操作时，拷贝的是指针的值（也就是指针指向对象的地址）。拷贝后，两个指针是不同的指针。\n1 2 3 4 5 6 7 8 9 10 void reset(int *ip){ *ip=0; /* 指针所指向的对象值改为0 */ ip=0; /* 仅能改变ip的局部拷贝，其实参并未发生改变 */ } int main(){ int i=42; reset(\u0026amp;i); /* 改变的是i的值，i的地址并未改变 */ cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; /* 输出0 */ 补充\n对于熟悉C的程序员来说，其常常使用指针类型的形参来访问函数外部的对象。建议在C++中，使用引用类型的指针来代替指针。\n传引用参数 引用实际上是为对象起别名。\n所以在函数形参中使用引用方式，这样可以利用形参改变实参，同时使用引用方式还可以避免拷贝。\n实际开发\n使用引用参数时，如果函数无须改变形参的值（例如读取形参内容），最后将其声明为常量引用。\n虽然函数仅能够返回一个值，但是可以通过引用参数的方式返回额外的值。\nconst 形参和实参 在前文提到过，顶层const和底层const，其中顶层const作用于对象本身，同样和其他初始化过程一样，当实参初始化形参时会忽略掉顶层const。也就是说形参的const忽略掉了。\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; void functinon(int a){ a=20; /* 我们可以修改a的值，但是如果形参为 const int a，则函数仅能够读取a，无法向a写值 */ } void functinon(); int main(){ const int b=10; functinon(b); } 由于形参的初始化具有这种特性，所以如果形参为const，那么传给它的实参无论是否是const都可以。但是，这种特性也会出现一种意想不到的效果：\n1 2 void function(const int a){ ... } void function(int a){ ... } /* 错误：重复定义function(int) */ 因为，形参中的const被忽略，那么传入它的实参可以为const也可以为普通对象，那么对于上述两个函数，其本质是一样的。所以第二个函数会报重复定义错误。\n关于指针或引用的底层const，提到过可以使用非常量初始化一个底层const对象，但是不能使用一个底层const对象初始化一个非常量对象。\n1 2 3 4 5 6 7 int i=42; const int *ip=\u0026amp;i; //true const int \u0026amp;ir=i; //true const int \u0026amp;ir_2=42; //true int *ip_2=ip; //false int \u0026amp;ir_3=ir; //false int \u0026amp;ir_4=42; //false 这样的规则同样适用于形参的参数传递上：\n1 2 3 4 5 6 7 8 9 int i=0; const int ci=i; // 顶层const string::size_type str=0; reset(\u0026amp;i); // 形参类型是int指针类型 reset(\u0026amp;ci); // 错误，无法使用const int 对象的指针初始化int * reset(i); // 调用形参类型为int\u0026amp;的reset对象 reset(ci); // 错误，无法将普通引用绑定到const对象ci上 reset(42); // 错误，无法引用字面值 reset(ctr); // 错误，类型不匹配，ctr属于无符号类型 在实际开发中，我们应该尽量使用常量引用，将函数不会改变的形参定义为常量引用是一个很好的习惯，这样不会误导调用者认为该值可以被修改。\n同时，使用普通引用而非常量引用也会极大地限制函数所能够接受的实参类型，例如：无法将const对象、字面值或者需要类型转换的对象传递给普通地引用形参。\n除此之外，还存在一个问题，如果在一个形参为const对象的函数中调用将该形参作为实参传给普通引用的函数，那么编译则会失败：\n1 2 3 4 5 void function_1(string \u0026amp;s){ ... } void function(const string \u0026amp;s){ function_1(s); /* 编译失败 */ } 数组形参 数组相较于我们之前看到的对象具有两个特殊性：\n不允许拷贝数组 使用数组（通常）会将其转换为指针（且该指针指向数组首元素） 因此，使用数组参数时，无法使用值传递的方式使用数组参数、传递数组时，实际上传递的是指向数组首元素的指针。\n1 2 3 void print(const int *); void print(const int[]); void print(const int[10]); 虽然C++中无法直接将数组进行拷贝，但是可以写成类型形式（如上式）方便调用者理解。上述的三种方式函数均是等价的，其函数的形参都是const int *类型。我们写成const int[]或者const int[10]形式只是我们的意图和期望。 在编译器处理过程中，只检查传入的参数是否是const int *类型。\n由于我们使用数组作为形参，那么我们也要考虑将数组的越界问题。\n针对这种情况，管理指针形参有三种常见的技术：\n使用标记指定数组长度\n1 2 3 4 5 void print(const char *point_array){ if(point_array) /* 判断是否是空指针 */ while(*point_array) /* 判断指针所指向的对象是否为空 */ cout\u0026lt;\u0026lt;*point_array++; /* 输出 */ } 这种方式要求数组的末尾存在一个结束标记，典型便是：C风格字符串，C风格字符串在结尾处包含一个空字符。\n使用标准库规范\n1 2 3 4 5 6 7 8 9 void print(const int *begin,const int *end){ while(begin!=end) cout\u0026lt;\u0026lt;*begin++\u0026lt;\u0026lt;endl; } int main(){ int array[2]={1,2}; print(begin(array),end(array); } 通过使用数组的首元素指针和尾元素指针来确定数组的大小\n显式传递一个表示数组大小的形参\n1 2 3 4 void print(const int array[],size_t size){ for(size_t i=0;i!=size;++i) cout\u0026lt;\u0026lt;array[i]\u0026lt;\u0026lt;endl; } 这种方式在C程序中很常见，笔者开始也是从这种方式描述数组大小。当然，为了方便直接确定数组大小，也可以将size_t size的实参写为end(array)-begin(array)。\n在之前介绍引用的时候，提到过数组引用。数组本身是对象，所以可以对数组进行引用：\n1 2 3 4 void print(int (\u0026amp;arr)[10]){ for(auto elem:arr) cout\u0026lt;\u0026lt;elem\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } 其相当于为数组起一个别名，但是注意一定要将引用名括起来。如果不括起来相当于将arr声明成了引用的数组。\n但是这种引用本身包含数组的维度，也就是大小。所以当调用者输入的实参数组的维度不等于10时，编译错误。\nmain：处理命令行选项 在大多数时候，我们在之前的练习中main()函数只有空形参列表。\n在某些时候，我们确定需要给main传递实参，一种常见的情况是用户通过设置一组选项来确定函数所要执行的操作，那么我们通过两个可选形参传递给main() 函数：\n1 2 int main(int argc,char *argv[]){ ... } int main(int argc,char **argv){ ... } 第一个形参argc表示数组中字符串的数量，第二个形参argv是一个数组，其元素指向C风格字符串的指针。\n由于argv是一个数组，所以也可以写成第二种方式。\n假设存在一个可执行文件print，其main函数在其可执行文件之内，其存在下面命令：\n1 print -o -x hello home 那么，根据上面命令，我们可以通过代码：\n1 2 3 4 5 6 7 8 9 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; int main(int argc,char *argv[]){ if (argv) while (*argv++) std::cout\u0026lt;\u0026lt;*argv; return 0; } 得到argc等于5，argv为：\n1 2 3 4 5 6 argv[0]=\u0026#34;print\u0026#34;; argv[1]=\u0026#34;-o\u0026#34;; argv[2]=\u0026#34;-x\u0026#34;; argv[3]=\u0026#34;hello\u0026#34;; argv[4]=\u0026#34;home\u0026#34;; argv[5]=0; 其可选的参数便是从argv[1]开始到argv[4];\n含有可变参数的函数 函数的参数在某些时候，我们并不能够准确预知正确数目，或者某些时候，我们需要输出特定的但是并未明确写出的参数。这种使用环境下，我们就可以使用可变参数的函数。\n可变参数函数在C++11标准下提供两种主要的方法：\ninitializer-list 如果传入的所有实参类型相同 可变参数模型 实参类型不同 除此之外，C++还存在一种特殊的形参类型：省略符。但请注意：该类型一般只用于与C函数交互的接口程序。\ninitializer_list形参 该类型定义在同名头文件下，其具体用法：\n1 2 3 4 5 6 7 initializer_list\u0026lt;T\u0026gt; list; /* 默认初始化：T类型的空列表 */ initializer_list\u0026lt;T\u0026gt; list{a,b,c ... }; /* list的元素数量和初始值一样多；list的元素是对应初始值的副本；列表中的元素是const */ list_2(list) /* 拷贝或赋值一个initializer_list对象不会拷贝列表中的元素。拷贝后，原始列表和副本共享元素 */ list_2=list /* 与上述一致 */ list.size() /* 获得列表中的元素 */ list.begin() /* 返回指向list中首元素的指针 */ list.end() /* 返回指向list中尾元素下一位置的指针 */ initializer_list本身也是模板类型，所以其和vector类型一致，在定义该类型时，必须说明列表中所含元素的类型：\n1 initializer_list\u0026lt;int\u0026gt; list; /* 其元素类型为int */ 与vector不同是，initializer_list中所有元素都为常量！\n当然，initializer_list可以通过使用begin()和end()方法获得其内参数：\n1 2 3 4 5 void print(initializer_list\u0026lt;int\u0026gt; list){ for(auto begin=list.begin();begin!=list.end();++begin) cout\u0026lt;\u0026lt;*begin\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } 在使用initializer_list形参时，我们可以这样使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 /* 打印信息 */ void print(ID id，initializer_list\u0026lt;string\u0026gt; list){ /* 假设存在一个类ID，其中meg()函数用于输出id值 */ cout\u0026lt;\u0026lt;id.meg()\u0026lt;\u0026lt;\u0026#34;: \u0026#34;; for(auto \u0026amp;elem : list) cout\u0026lt;\u0026lt;elem\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } void error(ID id,const int i,const int j){ if(i!=j) print(id,{\u0026#34;hello\u0026#34;,\u0026#34;well\u0026#34;}); /* 使用大括号包住值序列 */ else print(id,{\u0026#34;okay\u0026#34;}); 注意点：\n如果想要在initializer_list形参中传入值序列，那么必须使用大括号括起来。 由于列表中的元素为const，所以只能读取initializer_list对象中元素，无法修改。 initializer_list队形中只能传入同一类型元素 省略符形参 我们需要注意的是：省略符形参是为了便于C++程序能够访问某些特殊C代码而设定的（这些代码使用varargs的C标准库功能）。所以，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。\n省略符形参只能出现在形参列表的最后一个位置：\n1 2 void print_1(List list,...); void print_2(...); 其无外乎只有上述两种形式。省略符形参所对应的实参无需进行类型检查。\n6.3 返回类型和return语句 在前面我们提到过，return语句实际上是终止当前正在执行的函数并将控制权返回到调用该函数的地方。 return语句的形式有两种：\n1 2 return; return expression; 无返回值函数 只有在返回类型为void的函数中才能实现没有返回值的return语句，返回类型为void的函数非必须添加return语句，该函数会在最后一条语句后隐式执行return。\n如果想要使用return expression形式，则expression必须为返回类型为void的函数，否则编译失败。\n有返回值函数 只要函数的返回类型不是void，那么必须在该函数中存在return语句且必须返回一个值。（但是有例外：main函数可以不写return语句，编译器会隐式插入一条返回值为0的return语句）\n注意：在含有return语句的循环中也必须存在一条结尾return语句，也就是说：必须考虑所有情况下return语句都能够被执行。\n不要返回局部变量的引用或指针：在函数完成后，其所占的存储空间也被释放掉。因此，函数终止意味着局部变量所占的内存区域不再有效，使用局部变量的引用则是无效的，使用局部变量的指针则是“野指针”。\n函数的返回类型决定函数调用是否是左值：调用返回引用的函数得到左值，其他类型得到右值。特别的，我们能够将非常量引用的函数结果赋值：\n1 2 3 4 5 6 7 char \u0026amp; get_value(string \u0026amp;str,string::size_type i){ return str[i]; } int main(){ string str=\u0026#34;hello\u0026#34;; get_value(str,0)=b; /* str变为bello */ 列表初始化返回值 C++11 规定，函数可以返回花括号包围的值的列表。此处的列表用来对表示函数返回的临时量进行初始化。\n1 2 3 4 vector\u0026lt;string\u0026gt; print(const string \u0026amp;str1,const string \u0026amp;str2){ if(str1.size()!=str2.size()) return {\u0026#34;no\u0026#34;}; else return {\u0026#34;yes\u0026#34;,\u0026#34;equal\u0026#34;,\u0026#34;size\u0026#34;}; } 在这个例子中，使用vector对象来存储返回信息。\n当然，列表初始化返回值其实也是有条件的，如果函数返回的是内置类型，那么列表中仅存在一个值，且该值所占空间不应该大于目标类型的空间：\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; int print(const int \u0026amp; i){ return {i}; /* 不能返回return {i,10} */ } int main(){ std::string str=\u0026#34;hello\u0026#34;; int i=10; std::cout\u0026lt;\u0026lt;print(i); } 如果返回类型为类类型，则根据类本身定义初始值如何使用。\n返回数组指针 数组并不支持拷贝，所以函数本身并不能够返回数组。但是函数能够返回数组的指针或者引用。根据这种思路，我们就可以得到：\n1 2 3 4 /* 使用类型别名方式 */ typedef int array[10]; /* array为类型别名，表示含有10个整数的数组 */ using array=int[10]; /* array的等价声明 */ array* functinon(int i); /* function则返回一个指向含有10个整数的数组的指针 */ 我们通过将返回类型定义成数组的指针。\n上述我么通过类型别名方式声明，除此之外还有三种方式得到数组指针：\n声明一个返回数组指针的函数\n格式：Type (*function(parameter_list))[dimension]，Type表示元素类型，dimension表示数组大小。 注意点：函数两端的括号必须存在，例如：int (*f(int i))[10]。\n使用尾置返回类型\n尾置返回类型跟在形参列表后面并以-\u0026gt;符号开头。例如： auto f(int i) -\u0026gt; int(*)[10]，表示f函数返回的是一个指针，且该指针指向含有10个int类型元素的数组\n使用decltype\n如果我们知道函数返回的指针指向哪个数组，那么我们就可以根据decltype关键字声明返回类型。例如：\n1 2 3 4 5 int array_1[10]; int array_2[10]; decltype(array_1) *select(int i){ return (i%2)? \u0026amp;array_1:\u0026amp;array_2; } 由于decltype并不会将数组类型转换为相应指针，所以还需要手动添加。\n6.4 函数重载 函数重载：在同一作用域内的几个函数名字相同但形参列表不同。\n当存在多个形参不同的函数名相同的函数时，编译器根据传递的实参类型推断应该选择哪个函数。函数名仅仅是让编译器知道它调用的是哪个函数。\n注意\nmain函数不能够重载\n对于重载的函数来说，它们应该在形参数量或形参类型上有所不同\nconst与函数重载的讨论：\n如果const为顶层const，则两个函数是相同。\n1 2 int print(int i); int print(const int i); /* 二者相同 */ 如果const为底层const，那么通过区分指向的是常量对象还是非常量对象可以实现函数重载：\n1 2 int print(const int \u0026amp;); int print(int \u0026amp;); 函数匹配（也叫重载确定），是指在一个过程中我们把函数调用与一组重载函数中的某一个关联起来。编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪一个函数。\n函数匹配在某些情况下是十分容易的，但是往往有些是不尽人意的。例如：函数列表中形参数量一样，参数类型又可以相互转换。😵\n所以，在我们调用重载函数时需要掌握三种可能：\n编译器能够找到最佳匹配 编译器找不到任何函数能够匹配，编译器将会报错，返回无匹配 存在多个可能匹配的函数，且没有最佳匹配，编译器将会报错，二义性调用 6.5 特殊用途语言特性 在这里介绍三种与函数相关的语言特性：\n默认实参 内联函数 constexpr函数 默认实参 默认参数作为形参列表中形参的初始值，当某个形参具有默认值，其后的所有形参都必须有默认值。\n函数调用实参时按照位置进行解析，默认实参填补空位。（这也就解释了为什么当某形参具有默认值，其后所有形参都必须具有默认值）\n开发\n在实际开发中，对形参顺序我们应该进行合理考虑，对那些经常使用默认值的形参应该出现在后面。\n同时需要注意的是，默认形参的默认值仅能够存在一个。当我们声明多个同一函数时（尽管建议函数只申请一个，但是多个申请是合法的），在同一作用域下，形参仅能够被赋予一次默认值。\n内联函数和constexpr函数 内联函数 我们常常使用函数来封装一些规模较小的操作，这样做的好处多多😆，但是相较于直接将操作写核心代码上，不进行封装效率会慢一些（函数调用包括一系列工作：调用前保存进寄存器、拷贝实参、程序转向新位置等等）。\n所以，在C++中可以通过内联函数（inline）避免函数调用的开销。\n只需要在函数前添加关键字inline，该函数就成为内联函数。内联机制一般用于优化规模较小/流程直接/频繁调用的函数，同时需要注意的是：内联说明仅仅只是向编译器发送一个内联请求，编译器可以选择忽略。\nconstexpr函数 constexpr函数是指哪些能够用于常量表达式的函数。\n函数的返回类型及所有形参的类型都得是字面值类型 函数体中必须且仅能够存在一条return语句 我们还需要注意：如果使用非常量表达式调用constexpr函数时，返回值也是一个非常量表达式。\n调试帮助 有时候，我们在开发过程中进行一些调试工作，但是并不希望在发布时这些调试代码被使用。这个时候就需要使用到两种预处理功能：assert和NDEBUG。\nassert预处理宏 预处理宏（preprocessor marco）其实就是一个预处理变量。其行为类似于内联函数。格式为：\n1 assert(expr); 首先对expr求值，如果为假则assert输出信息并终止程序执行，反之，assert什么也不做。\nassert宏常用于检查“不能发生”的条件。\n同时，assert只有在Debug版本中才有效，如果编译为Release版本则会被忽略。\n使用assert的最大原因是其能够在编写程序时进行逻辑断言，使得程序逻辑严密。所以，我们一般将其放在函数的开头部分用来对外界传入的参数进行限制，如果是调用其他函数出现的错误，我们应该进行异常处理，而不是断言。\n开发\n在使用中，\n应该注意函数开始处传入的参数的合法性；\n每个assert只能检验一个条件，因为同时检验多个条件，如果断言失败，无法直观判断哪个条件失败。 \u0026gt; \u0026gt; cpp \u0026gt; assert(times\u0026gt;=10 \u0026amp;\u0026amp; sizes\u0026lt;=20); // 不好 \u0026gt; assert(times\u0026gt;=10);assert(sizes\u0026lt;=20); // 好 \u0026gt; 不能使用能够改变环境的语句，因为assert仅在没有定义NDEBUG下生效。 \u0026gt; \u0026gt; cpp \u0026gt; assert(i++\u0026lt;100); // 错误，当i=100时，i++命令并未执行。 \u0026gt; assert(i\u0026lt;100);i++; // 正确 \u0026gt; assert和后面语句应该空一行，保证逻辑和视觉上的一致性。\n注意：assert是用来避免显而易见的错误，而非处理异常。注意这一点！错误是不应该出现的，异常是不可避免的。assert一般都是在方法或者函数的最开始使用，如果在一个功能过程执行中出现的问题几乎都是异常。\nNDEBUG预处理变量 assert行为依赖于预处理变量NDEBUG的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义DEBUG，此时assert将执行运行时检查。（即当将“#define NDEBUG”定义在#include \u0026lt;cassert\u0026gt;之前，assert宏的定义为空）。\nassert在为假的时候，输出调试信息，类似于：\n1 Primer_ChapterSix: 6_5.cpp:38: void exercise_47_sub(std::vector\u0026lt;int\u0026gt;::const_iterator, std::vector\u0026lt;int\u0026gt;::const_iterator): Assertion `0\u0026#39; failed. 当然，我们也可以自己定义调试信息，编写自己的条件调试代码，例如：\n1 2 3 4 5 /* 输出vector的大小 */ #ifndef NDEBUG std::cerr \u0026lt;\u0026lt; iterator_end - iterator_begin \u0026lt;\u0026lt; \u0026#34; function: \u0026#34; \u0026lt;\u0026lt; __func__ \u0026lt;\u0026lt; \u0026#34; file: \u0026#34; \u0026lt;\u0026lt; __FILE__ \u0026lt;\u0026lt; \u0026#34; on \u0026#34; \u0026lt;\u0026lt; __DATE__ \u0026lt;\u0026lt; \u0026#34; at \u0026#34; \u0026lt;\u0026lt; __TIME__ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; #endif 如果DEBUG没有定义，那么将会输出#ifndef和#endif中的语句，其中我们可以使用编译器定义的一些局部静态变量：\n__func__ ：存放函数名的字符串字面值 __FILE__ ：存放文件名的字符串字面值 __LINE__ ：存放当前行号的字符串字面值 __TIME__ ：存放文件编译时间的字符串字面值 __DATE__ ：存放文件编译日期的字符串字面值 例如，上述自定义的条件调试代码便会输出：\n1 2 3 4 5 6 5 function: exercise_47_sub file: 6_5.cpp on Jun 30 2023 at 14:32:26 4 function: exercise_47_sub file: 6_5.cpp on Jun 30 2023 at 14:32:26 3 function: exercise_47_sub file: 6_5.cpp on Jun 30 2023 at 14:32:26 2 function: exercise_47_sub file: 6_5.cpp on Jun 30 2023 at 14:32:26 1 function: exercise_47_sub file: 6_5.cpp on Jun 30 2023 at 14:32:26 0 function: exercise_47_sub file: 6_5.cpp on Jun 30 2023 at 14:32:26 6.6 函数匹配 前文我们提到重载函数，在其中我们对函数匹配做了简略地说明。在那次说明中，我们提到：在大多数情况下，我们都能够很容易地理解哪次调用该用那个重载函数，但是，万物皆有但是[doge]。当存在几个重载函数其形参数量相同且某些形参的类型可以由其他类型转换得到，啊欧，这样进行函数匹配就变得复杂起来。\n所以，在这里介绍如何对上述的复杂情况进行函数匹配。\n在此之前，我们进行以下内容补充\n补充\nC++函数重载的实现，依靠的是编译器使用了命名倾轧的技术，以此实现同名函数依靠参数列表的不同进行特化区分：\n其命名规则为：命名空间+函数名长度+函数名+参数列表\n但是，仅仅做到这样是不够的，无法考虑到重载函数的全部情况。例如：\n1 2 3 4 5 6 7 8 void f(); void f(int a); void f(int a,int b); void f(double a,int b); void p(); void p(int a); void q(int a); void q(double a); 如果按照上面的判断调用f函数，其结果存在二义性。\n函数匹配的第一步是选定本次调用对应的重载函数集，其集合中的函数称为候选函数（candidate function）。候选函数存在以下特征：\n与被调用的函数同名，其函数名相同 其声明在调用点可见，与被调函数处在同一作用域下 按照上面的例子，我们可以得到三个重载函数集：{{f},{p},{q}}，其中f的候选集为：{f,fi,fii,fdi}\n第一步完成，我们便开始第二步：选出可行函数。\n第二步目的就是从候选集中选择出能够被实参调用能够的函数。称为可行函数（viable function）。其存在以下特征：\n形参数量与调用提供的实参数量一致 每个实参的类型与对应的形参类型能够相同，或者能够转化成形参的类型 例如，我们调用f函数：f(3.14,3)，那么我们便可以得到以下可行函数：\n1 2 void f(int a,int b); void f(double a,int b); 当然，如果没有找到可行函数，那么编译器将报告无匹配函数的错误。\n如果可行函数不止一个，进行第三步，寻找最佳匹配。\n编译器会依次检查可行函数，检查其形参与实参之间的“差距”。其匹配核心为，实参类型与形参类型越接近，它们匹配得越好。\n匹配最优函数可以简述为：\n可行函数每个实参的匹配都不劣于其他可行函数需要的匹配 至少有一个实参的匹配优于其他可行函数提供的匹配 如果依旧选择不出最优匹配，那么编译器则认为该调用存在二义性，报错并给出信息。\n在上面的例子中，我们就可以看出调用f重载函数：f(3.14,3)显然是void f(double a,int b)最佳。\n实参类型转换 为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，具体如下：\n精确匹配\n实参类型和形参类型相同 实参从数组类型或函数类型转换成对应的指针类型 向实参添加顶层const或者从实参中删除顶层const 通过const转换实现的匹配\n通过类型提升实现的匹配\n通过算术类型转换或者指针转换实现的匹配\n通过类类型转换实现的匹配\n注意\n类型提升转换和算术类型转换的匹配在某些时候往往会有着出乎意料的结果，在实际开发中，我们应该避免。\n类型提升转换：\n我们都知道当我们使用小整型（例如：short）时都会自动转换为int类型或者更大的整数类型。那么假设存在一下两个函数：\n1 2 3 void f(short); void f(int); f(\u0026#39;1\u0026#39;); // char类型提升为int类型 即使是很小的一个数也直接提升为int类型，那么此刻使用short类型版本反而导致类型转换。\n算术类型转换：\n由于所有的算术类型转换的等级都是一样的，那么存在这种情况：int向unsigned int的转换并不会比int向double转换的级别更高，例如：\n1 2 3 void f(unsigned int); void f(double); f(12); // 二义性错误 由于，二者转换等级一致，那么便存在二义性。\n当然，我们也需要考虑const的影响，这在开发中常常会被程序员忽略。\n如果重载函数的区别在于它们的引用类型的形参是否引用了const，或者指针类型的形参是否指向const，则当调用发生时编译器通过实参是否是常数来决定选择哪个函数：\n1 2 3 4 5 6 7 void f(int \u0026amp;); void f(const int \u0026amp;); int a; const int b; f(a); // 调用f(int \u0026amp;); f(b); // 调用f(const int \u0026amp;); 6.7 函数指针 函数指针，如其名指针指向函数而非对象。同时，函数指针与其他指针一样，函数指针指向某种特定类型，函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：\n1 2 int print(const string \u0026amp;); /* 其函数类型为int print(const string \u0026amp;) */ 如果想要使用声明一个指向该函数的指针，只需要将函数名改为指针即可。如上：int (*p)(const string \u0026amp;)。\n当我们将函数名作为一个值使用，那么该函数自动转换为指针：\n1 2 p=print; /* p为指向print函数的指针 */ p=\u0026amp;print; /* 等价赋值语句 */ 同时，我们也可以直接通过使用函数的指针调用该函数：\n1 2 3 int c=print(\u0026#34;hello\u0026#34;); int a=p(\u0026#34;hello\u0026#34;); int b=(*p)(\u0026#34;hello\u0026#34;); /* 三者等价 */ 了解了函数指针的具体用法，我们看看如何函数指针的其他应用。\n重载函数下的应用：\n如果我们定义指向重载函数的指针，那么必须清晰地写出指针类型：\n1 2 3 4 5 6 7 void f(const int \u0026amp;); /* 一 */ void f(const string \u0026amp;); /* 二 */ double f(const double \u0026amp;); /* 三 */ void (*p1)(const int \u0026amp;)=f; /* f指向一函数 */ void (*p2)(const string \u0026amp;)=f; /* f指向二函数 */ void (*p3)(const double \u0026amp;)=f; /* f与p3的返回类型不匹配，错误 */ 函数指针形参的应用：\n如同数组指针，我们无法定义函数类型的形参，就像无法定义数组类型的形参一样，但是我们可以使用指向函数的指针作为形参。\n1 2 3 4 void print(const string \u0026amp;,string view(const string \u0026amp;)); void print(const string \u0026amp;,string (*p)(const string \u0026amp;)); /* 二者等价 */ print(\u0026#34;hello\u0026#34;,view(\u0026#34;world!\u0026#34;)); /* 调用时实参为函数的实参将会自动转换为指针 */ 如果形参是函数类型，那么将自动转换为指向函数的指针。\n显然，上面写的颇为复杂，我们可以通过类型别名和decltype方式简化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 std::string view(const std::string \u0026amp;str) { return str + \u0026#34;~~\\n\u0026#34;; } // typedef decltype(view) name; // typedef decltype(view) *name; // typedef std::string name(const std::string \u0026amp;); // typedef std::string (*name)(const std::string \u0026amp;); // using name=std::string(const std::string \u0026amp;); // using name=std::string(*)(const std::string \u0026amp;); std::string print(const std::string \u0026amp;str, name name1) { return str + name1(\u0026#34; world\u0026#34;); } 以上的简化方式作用在形参上都是等价的，可以看出无论形参如果是单纯的函数类型，会在使用时自动转换为函数指针。\n函数指针作为返回值的应用：\n同样的道理，函数虽然不能返回函数，但是可以返回指向函数类型的指针（注意：必须是指针，编译器不会将函数返回类型当成对应的指针处理）。\n在前面我们介绍返回类型的时候，提到过几种方式，这里一一列举：\n1 2 3 4 5 6 7 8 9 10 /* 最简单的方式，使用类型别名 */ using F=std::string(const std::string \u0026amp;); F *print(std::string); /* 由于F是函数类型，所以需要手动添加指针符号 */ /* 尾置返回类型 */ auto print(std::string)-\u0026gt;std::string (*) (const std::string \u0026amp;); /* 直接声明 */ std::string (*print(std::string))(const std::string \u0026amp;); 总结 函数，其可以是命名的计算单元、命名的快，也可以看作程序结构体。其本身必须包含返回类型、名字、（可为空的）形参列表以及函数体。\n函数可以重载，在绝大多数情况下，编译器都能容易地找到最佳匹配函数，但是我们需要注意特殊情况，如果忘记请重看6.6 函数匹配。\n","date":"2025-04-06T00:00:00Z","image":"https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg","permalink":"https://Free-Aaron-Li.github.io/p/c-%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/","title":"C++ 基础： 第六章 函数"},{"content":"第七章 类 前言 基本数据类型有时候并不能解决某些特定问题，而通过自定义的类就可以通过理解问题概念，使得程序更加容易编写、调试和修改。\n类的基本思想是数据抽象（data abstraction）和封装（encapsulation）。 数据抽象是一种依赖于接口（interface）和实现 （implementation）分离的编程（以及设计）技术。类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。\n可以说，封装实现了类的接口和实现的分离。封装后的类隐藏类它的实现细节。\n介绍：\n定义抽象数据类型 访问控制与封装 类其他特性及作用域 构造函数 类静态成员 7.1 定义抽象数据类型 设计Sales_data类 其类接口包括：\n一个isbn成员函数，用于返回对象的ISBN编号 一个combine成员函数，用于将一个Sales_data对象加到另一个对象上 一个add函数，执行两个Sales_data对象的加法 一个read函数，将数据从istream中读入到Sales_data对象中 一个print函数，将Sales_data对象的值输出到ostream 开发\n优秀的类设计者除了充分了解并实现用户的需求，还应该密切关注哪些有可能使用该类的程序员的需求。\n一个设计良好的类，既要有易于使用的接口，也必须具备高效的实现过程。\n注意\n定义在类内部的函数是隐式的inline函数\n定义改进的Sales_data类 定义成员函数\n所有类成员必须在类内部声明，但是可以自由选择在类内或类外定义。\nthis使用\n当我们调用成员函数时，实际上是替某个对象调用它。例如：\n1 2 /* 某个成员函数 */ std::string isbn() const { return bookNo; } 当我们调用isbn成员函数时，返回的bookNo数据成员，那么其隐式的返回的应该是total.bookNo（假设该函数的对象为total）。可以这样理解：使用this是将对象作为一个整体访问，而非直接访问对象的某个成员。\n成员函数通过一个名为this的额外隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。例如：\n1 2 3 4 /* 如果调用 */ total.isbn(); /* 编译器将会把total的地址传递给isbn的隐式形参this,等价于下面这个伪代码 */ Sales_data::isbn(\u0026amp;total); 注意\n在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无须通过成员访问运算符，因为this所指的正是这个对象。任何对类成员的直接访问都被看作this的隐式引用。\n因为this的目的总是指向“这个”对象，所以this是一个常量指针。\n引入const成员函数\n在成员函数中，存在这种写法：\n1 std::string isbn() const {return bookNo}; 其中，const关键字作用于修改隐式this指针的类型。\n在默认情况下，this的类型是指向类类型非常量版本的常量指针。对使用这种const方式的函数成为常量成员函数（const member function）。\n我们可以将上述写法想象成：\n1 2 3 std::string Sales_data::isbn(const Sales_data * const this){ return this-\u0026gt;bookNo; } 类作用域和成员函数\n类本身就是一个作用域，类的成员函数的定义嵌套在类的作用域之内。\n如果在类的外部定义成员函数，其定义必须与它的声明匹配，同时外部定义的成员的名字必须包含它所属的类名。\n定义一个返回this对象的函数\n定义类相关的非成员函数 类作者常常需要定义一些辅助函数，例如：add、read、print等等。这些辅助函数从概念上讲属于是类的接口的一部分，但是实际上其并不属于类。虽然实际上不属于类，但是概念上属于，所以一般将这些非成员函数写在同一个头文件中。\n构造函数 构造函数（constructor）用于初始化类对象的数据成员，无论何时只要类被创建，就会执行构造函数。\n构造函数名字与类名相同，与其他函数不同的是，构造函数没有返回类型；同时类可以包含多个构造函数，但是与重载函数不同的是，构造函数之间必须在参数列表或者参数类型上有所区别；同时构造函数不能被声明为const。\n当我们没有显式声明并定义构造函数，那么类将会通过一个默认构造函数（default constructor）来控制默认初始化过程。编译器创建的构造函数同时又被称为合成的默认构造函数（synthesized default constructor）。但是合成的默认构造函数仅适合非常简单的类，对于一个普通的类，必须定义一个它自己的默认构造函数，因为：\n编译器只有在类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。 含有内置类型或者复合类型成员的类在类的内部初始化时采用默认初始化很有可能其初始化值为未定义的。 有些时候编译器并不能为某些类合成默认的构造函数。 这里，使用一个示例进行分析：\n1 2 3 4 SalesData()=default; /* 默认构造函数，希望这个函数的作用等同于合成默认构造函数 */ SalesData(const std::string \u0026amp;str):_bookNo(str){} SalesData(const std::string \u0026amp;str,unsigned number,double price):_bookNo(str),_units_sold(number),_revenue(price*number){} SalesData(std::istream \u0026amp;); =default，在C++标准中，使用SalesData()=default;方式要求编译器生成构造函数。该定义既可以在声明处，也可以在类外部。与其他函数一致，如果在类内部，则默认为内联方式，如果在类外部，默认不使用内联方式。\n构造函数初始值列表\n首先我们可以看看后两个定义的构造函数，在冒号和大括号之间存在的部分成为构造函数初始值列表（constructor initialize list）。其负责为新创建的对象的一个或者几个数据成员赋初值。如果某个数据成员被构造函数初始值列表忽略，那么其将会以合成默认构造函数相同的方式初始化。\n通常情况下，构造函数使用类内初始值不失为一种好的选择，因为只要这样的初始值存在那么我们就确保了为成员赋予了一个正确的值。但是，如果编译器不支持类内初始值，那么所有的构造函数都应该显式地初始化每一个内置类型的成员。\n在类的外部定义构造函数\n构造函数没有返回类型，同时在类外部定义构造函数时必须明确构造函数是哪个类的成员。\n拷贝、赋值和析构 在实际开发中，我们除了需要知道如何对对象进行初始化，还需要知道如何控制拷贝、赋值和销毁对象时发生的行为。\n拷贝操作常见于：初始化变量并且采用值传递方式或者返回一个对象；赋值操作见于使用赋值运算符时发生对象的赋值操作；销毁对象，常见的示例比如：当我们将vector对象销毁时，其存储的对象也一并被销毁。\n如果，我们不主动控制或者说是定义这些操作，那么编译器将会替我们合成它们。\n但是，某些类其实不能够依赖于合成的版本，我们更加希望自定义这些操作。这些知识需要到第13章进行详细描述。\n7.2 访问控制与封装 在我们之前对Sales_data类进行编写时，我们并没有任何机制强制使用我们在该类中写下的接口，用户可以随时的直达Sales_data类的内部并控制其具体实现细节。也就是说，该类还没有被封装。\n没有对类进行封装其内部细节相当于直接暴露出来，这是不安全的！。所以，在C++中，我们可以通过使用访问说明符（access specifiers）加强类的封装：\n定义在public说明符之后的成员在整个程序中都是可以被访问的，例如：public定义类的接口 定义在private说明符之后的成员仅可以被类的成员函数访问，所以private封装了类的部分实现细节。 常用的格式是：\n部分成员函数和构造函数在public说明符之后，而数据成员和作为实现部分的函数则在private说明符之后。 一个类可以存在0个或者多个访问说明符，每个访问说明符指定了接下来的成员的访问级别，其有效范围知道出现下一个访问说明符或者类的结尾为止。\n补充\n使用class和struct关键字，二者均是用于表示类的定义，其唯一区别就是对默认访问权限的不同。\n类可以在其出现第一个访问说明符之前定义成员，这些成员的访问权限依赖于类定义的方式。如果是struct，则默认权限为public，如果是class，则默认权限为private。\n友元 如果想要其他类或者函数访问某个类的非公有成员，只需要令其他类或者函数成为这个类的友元（friend）即可。\n例如，如果想要把某个函数作为这个类的友元，只需要在该类中增加一条以friend关键字开始的函数声明语句即可。\n注意\n友元的声明仅仅指定了访问的权限，并不是一个通常意义的声明。所以，如果希望类的用户能够调用某个友元函数，那么我们必须在友元声明之外再专门对函数进行一次声明。也就是说，除了在类的内部进行友元声明，在类的外部也需要提供独立的函数声明。\n但是一些编译器允许在没有友元函数的初始声明的情况下调用函数，但是最好的情况下还是提供一个独立的函数声明。\n建议\n虽然友元只能声明在类定义的内部，但是友元的出现在类内部的位置是不限的。同时友元不是类的成员所以也不受其所在区域的访问控制级别的约束。但是，建议最好是在类定义开始或者结束前的位置声明友元，保证类内部的成员位置的整齐。\n补充\n封装的好处\n封装的两个重要的优点：\n保证用户代码不会修改、删除等操作封装对象中的内容 被封装的类，其具体实现细节可以随时改变，而无须调整用户级别的代码 一旦把数据成员定义成private的，类的作者就可以比较自由地修改数据了。当实现部分改变时，我们只需要检查类的代码本身以确定这次改变有什么影响；也就是说，只要类的接口不变，用户代码就无需改变。\n如果数据是public的，则所有使用了原来数据成员的代码都有可能失效（例如，我们在前面编写的练习7.3，如果我们将Sales_data中的数据成员设定为private的，那么将会报出许多错误，需要一个个修改）， 这时我们必须定位并且重写所有依赖于老版本实现的代码，之后才能重新使用该程序。\n把数据成员的访问权限设成private还有一个益处，这么做能够防止用户的原因造成数据被破坏。如果我们发现有程序缺陷破坏了对象的状态，则可以在有限的范围内定位缺陷：因为只要实现部分的代码可能产生这样的错误。因此，将差错限制在有限范围内将能够极大地降低维护代码及修正程序错误的难度。\n7.3 类的其他特性 在前面的章节我们基本上完成了Sales_data类，也了解和学习类一些类的特性，但是还有一些特性还没有从Sales_data类中体现出来。所以，接下来我们将了解类的其他特性，例如：类型成员、类的成员的类内初始值、可变数据成员、内联成员函数、从成员函数返回*this、关于如何定义并使用类类型及友元类的更多知识。\n在此之前，为了展示类的其他特性，我们创建一对相互关联的类，分别是Screen和Window_manager\n类成员再探 Screen类用于表示显示器的一个窗口。每个Screen包含一个保存Screen内容的string成员和三个string:: size_type类型的成员，用于表示光标的位置以及屏幕的宽高。\n这里，写下完整的Screen类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Screen { public: typedef std::string::size_type pos; public: Screen() = default; Screen(pos height, pos width, char c) : _height(height), _width(width), _contents(height * width, c) {} public: char get() const { return _contents[_cursor]; } /* 读取光标处的字符 */ char get(pos height, pos width) const; Screen\u0026amp; move(pos height, pos width); /* 移动光标 */ private: /* 光标位置 */ pos _cursor = 0; pos _height = 0, _width = 0; /* 保存Screen内容 */ std::string _contents; }; inline Screen\u0026amp; Screen::move(Screen::pos height, Screen::pos width) { pos row = height * _width; _cursor = row + width; return *this; } inline char Screen::get(Screen::pos height, Screen::pos width) const { Screen::pos row = height * _width; return _contents[row + width]; } 类可以自定义某种类型在类中别名（且同样具有访问控制）。\n同时，在写Screen类时需要注意：用来定义类型的成员必须先定义后使用。\n想要使得我们的Screen类更加实用，则需要添加构造函数使得用户能够自定义屏幕的尺寸和内容，同时需要两个成员函数来负责移动光标和读取给定位置的字符。\n内联函数再探 定义在类内中的成员函数都是自动inline的，但这些成员函数规模一般比较小。例如：用来作为返回数据成员值。\n同时，除了可以在类内进行隐式内联外，还可以进行显式内联：\n1 2 char get() const { return _contents[_cursor]; } /* 隐式内联 */ inline char get(pos height, pos width) const; /* 显式内联 */ 对于某些函数规模较大，我们可以在类外进行成员函数定义，那么可以通过inline关键字修饰类外定义的成员函数。\n虽然我们无须在类内和类外同时说明inline，但是这是合法的。同时，建议在类外成员函数的定义处说明inline，这样便于类的理解。\n建议\n成员函数应该与相应的类定义在同一个头文件中。\n成员函数的重载 成员函数的重载与非成员函数一致，只需要函数之间在参数和/或者类型上有所区别即可。例如，在Screen函数中的两个get()函数。\n可变数据成员 存在这种情况，我们希望能够修改某个数据成员，即便是在一个const成员函数内。那么我们可以通过关键字mutable。\n一个可变数据成员（mutable data member)永远都不会是const，即便是作为const对象的成员。示例：\n1 2 3 4 5 6 7 public: void some_member() const; private: mutable size_t _access_times; /* Screen的成员函数被调用次数 */ inline void Screen::some_member() const { ++_access_times; } 虽然some_member函数是一个const成员函数，但是其仍然能够改变_access_times成员的值。\n类数据成员的初始值 在完成Screen类后，我们希望存在一个类用于管理窗口，所以我们设定一个Window_manager类，该类存在一个vector，用于包含Screen。当然在默认情况下，我们希望存在一个默认的Screen。在C++11标准下，最好的方式是将这个默认值声明成一个类内初始值。\n1 2 3 4 class Window_manager { private: std::vector\u0026lt;Screen\u0026gt; screens{Screen(24, 80, \u0026#39; \u0026#39;)}; }; 注意\n当我们提供一个类内初始值时，必须以符号=或者大括号表示。\n返回*this的成员函数 1 2 3 4 5 6 7 8 9 10 11 12 Screen\u0026amp; Screen::set(Screen::pos height, Screen::pos width, char character) { _contents[height * _width + width] = character; return *this; } inline Screen\u0026amp; Screen::move(Screen::pos height, Screen::pos width) { pos row = height * _width; _cursor = row + width; return *this; } myScreen.move(4,0).set(\u0026#39;#\u0026#39;); 在我们定义set()函数时其返回值是调用set的对象的引用。返回引用的函数是左值的，意味着函数返回的是对象本身而非对象的副本。假如我们定义的返回类型不是引用，那么move的返回值将会是*this的副本，那么调用set只能临时改变副本，并不能改变myScreen的值。\n基于const的重载 通过区分成员函数是否是const的，我们可以进行重载。存在一种情况，非常量版本的函数对常量对象是不可用的，所以我们只能在一个常量对象上调用const成员函数。另一方面，虽然可以在非常量对象上调用常量版本或者非常量版本，但是显然此时非常量版本是一个更好的匹配。\n例如，display函数，我们通过定义一个do_display的私有成员，由它负责打印Screen操作（保证安全性），重载display函数，实现常量版本和非常量版本。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Screen{ public: Screen\u0026amp; display(std::ostream\u0026amp; ostream); const Screen\u0026amp; display(std::ostream\u0026amp; ostream) const; private: void do_display(std::ostream\u0026amp; ostream) const { ostream \u0026lt;\u0026lt; _contents; } } inline Screen\u0026amp; Screen::display(std::ostream\u0026amp; ostream) { do_display(ostream); return *this; } inline const Screen\u0026amp; Screen::display(std::ostream\u0026amp; ostream) const { do_display(ostream); return *this; } /* ****************** */ Screen myScreen(5,3); const Screen replica(5,3); myScreen.set(\u0026#39;#\u0026#39;).display(cout); /* 调用非常量版本 */ blank.display(cout); /* 调用常量版本 */ 当一个成员调用另一个成员时，this指针在其中隐式地传递。当display调用do_display时，它的this指针隐式地传递给do_display。而当display的非常量版本调用do_display时，他的this指针将隐式得从指向非常量的指针转换为指向常量的指针。\n而当do_display完成后，display函数各自返回解引用this所得的对象。在非常量版本中，this指向一个非常量对象，因此display返回一个普通引用；而const成员返回一个常量引用。\n也就是说，我们将do_display封装起来，不影响display的工作。\n建议\n对于公共代码使用私有功能函数\n原因：\n避免在多出使用同样的代码 随着预期发展，公共代码可能愈加复杂，那么将操作进行模块化处理显得非常有必要 在某些时候，为某些模块添加调试信息，那么在最终版本中，对于调试信息的位置有个明确的概念 通过使用内联的方式，额外的函数调用不会增加任何开销 出于安全考虑，隐藏实现细节 类类型 每个类定义类唯一的类型。即便类与类之间的成员完全一致，类与类也是不同类型。\n根据类的唯一性，我们就可以把类名作为类型的名字使用，从而直接指向类类型。\n1 2 Sales_data obj_1; class Sales_data obj_2; /* 继承于C语言，等价于上一条 */ 类的声明 类似于函数的声明与定义可以分离，类也可以仅声明而暂时不定义它。\n1 class Screen; /* 仅声明 */ 这种声明称作前向声明（forward declaration），其仅向程序表明引入了名为Screen的类。对于该类类型来说，它在声明以后定义之前是一个不完全类型（incomplete type），表明：我们已知Screen是一个类类型，但是不清楚其包含什么成员。\n不完全类型的使用场景非常有限：\n可以定义指向这种类型的指针或者引用 可以声明以不完全类型作为参数或者返回类型的函数，但是不能够定义。 对于编译器来说，只有定义了类类型，那么我们在创建这个类类型对象时才能够知道需要划分多少的存储空间。所以只有类被定义了，才能够使用引用或者指针访问其成员。\n额外情况：\n1 2 3 4 5 class Link_Screen{ Screen window; /* 必须Screen类被定义了，才能声明这种类类型 */ Link_Screen *next; Link_Screen *prev; }; 直到类被定义之后，数据成员才能被声明成这种类类型。也就是说，我们必须首先完成类的定义，然后编译器才能知道存储该数据成员需要多少空间。因为只有当类全部完成后类才算被定义，所以一个类的成员类型不能是该类自己。然而，一旦一个类的名字出现后，他就被认为是声明过了，因此类允许包含指向它自身类型的引用或者指针。\n友元再探 在之前，我们仅将定义类相关的非成员函数设定为友元，除此之外，还可以将其他类、其他类的成员函数定义为友元。当然，友元函数可以定义在类内部，这样的函数与上述的一致都是隐式内联的。\n类之间的友元关系 类之间的友元关系只需要在需要被访问的类中为提出类设定友元即可。例如，Window_manager类想要访问Screen类，则：\n1 2 3 class Screen{ friend class Window_manager; } 这样Window_manager成员就可以访问Screen类的私有部分。\n总体上来说，如果一个类指定类友元类，那么友元类的成员函数就可以访问此类包括非公有成员在内的所有成员。\n注意\n友元关系不存在传递性，也就是说，如果Window_manager类有它自己的友元，但是这些友元没有访问Screen的特权。\n每个类负责控制自己的友元类或者友元函数。\n令成员函数作为友元 当把一个成员函数声明为友元时，我们必须明确指出该成员函数属于哪个类。\n但是需要注意的是，想要某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。所以，需要按照一下方法设计程序：\n假设存在两个类：Window_manager和Screen，其中Window_manager类存在一个Clear函数，Clear函数想要成为Screen类的友元。\n首先需要定义Window_manager类，同时必须声明Clear函数，但是这个时候还不能定义它。在Clear函数使用Screen成员前必须先声明Screen类。（注意，Window_manager类必须写在Screen类前面） 定义Screen类，包括对Clear的友元声明（所以建议友元写在类内的最前面）。 定义Clear函数，这个时候该函数才能使用Screen中的成员。 函数重载和友元 如果一个类想要将一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明（尽管重载函数名一致）。\n友元声明和作用域 类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中。\n也就是说，就算是在类内部定义该函数，那么我们也必须在类外提供相应的声明从而使得函数可见。\n7.4 类的作用域 对类类型成员必须使用作用域运算符进行访问。不论那种情况，跟在运算符后面的名字必须是对应类的成员。\n作用域和定义在类外部的成员 一个类便是一个作用域，当我们在类的外部使用类成员，该成员将会被隐藏。\n当我们使用了类名，那么定义的剩余部分（包括参数列表、函数体）就已经在类的作用域内了，所以不需要再次授权类作用域。因为编译器在处理参数列表之前已经明知我们位于Screen类的作用域之中。\n1 2 3 4 5 inline Screen\u0026amp; Screen::move(pos height, pos width) { /* pos类型属于Screen */ pos row = height * _width; /* _width属于Screen */ _cursor = row + width; /* _cursor属于Screen */ return *this; } 注意\n函数的返回类型通常出现在类名之前，所以如果返回类型中使用的名字属于类成员，那么则需要单独为返回类型添加类名。因为如果不添加，返回类型中使用的名字在类的作用域之外。\n1 2 3 4 5 6 7 8 9 class Window_manager{ public: screen_index addScreen(const Screen \u0026amp;); } Window_manager::screen_index Window_manager::addScreen(const Screen \u0026amp;screen) { screens.push_back(screen); return screens.size() - 1; } 名字查找与类的作用域 寻找与所用名字最匹配的声明的过程称为名字查找（name lookup）。截至目前，编写的程序名字查找还比较直截了当：\n在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明。 如果没有找到，继续查找外层作用域。 最终没有找到匹配的作用域，程序报错。 与之不同的成员函数名字查找，类的定义处理过程：\n首先，编译成员的声明 直到类全部可见后才编译函数体 所以，在此类定义的方式下，因为成员函数体直到整个类都可见才会被处理，所以成员函数可以使用类中定义的任何名字。这也是与普通函数不同之处。\n❗ 用于类成员声明的名字查找 上述的类定义处理过程这针对成员函数中 使用的名字，但是如果是声明中使用的名字（包括返回类型、参数列表）那么必须确保其可见。如果某个成员使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。\n1 2 3 4 5 6 7 8 typedef double Money; string bal; class Account{ public: Money balance(){return bal;} private: Money bal; } 在这个示例中，\n编译器首先看到balance函数的声明，那么它先在类内寻找对Money的声明。且只会考虑Account类中在使用Money之前的声明，没有找到，那么编译器会到Account类的外层作用域寻找。 找到Money的typedef语句，那么Money将会被认为是double类型作为balance函数的返回类型以及私有成员bal的类型。 因为类的两步处理过程，那么balance函数体将会在整个类可见后处理，那么该函数的return语句返回的是名为bal的成员，其类型为double而非string。 类型名要特殊处理 一般来说，内层作用域可以重新定义外层作用域中的名字（这个我们在学习函数的时候理解过）。然而在类中，如果成员使用了外层作用域中的某个名字，且该名字代表一种类型，则该类不能在之后 重新定义该名字。\n1 2 3 4 5 6 7 8 9 typedef double Money; string bal; class Account{ public: Money balance(){return bal;} /* 已经使用类外层作用域的Money */ private: typedef double Money; /* 无法再次定义，即使类型一致 */ Money bal; } 尽管重新定义类型的名字是一种错误行为，但是编译器并不会负责🤨。所以一些编译器能够顺序通过这个代码，并且忽略有错误的事实。（g++ 11.2.0 会报错😜）\n❗ 成员定义中的普通块作用域的名字查找 如题，成员函数使用名字按照一下方式解析：\n在成员函数内部查找该名字的声明，只有在函数（注意：不是成员函数）使用之前出现的声明才会被考虑。（这个时候还在成员函数内） 如果在成员函数内没有找到，则在类内继续查找，这个时候类的所有成员都可以被考虑。（这个时候在类内） 如果类内也没有找到该名字的声明，那么在成员函数定义之前的作用域内继续查找。（这个时候在类外） 建议\n不建议使用其他成员的名字作为某个成员函数的参数。 1 2 3 4 5 6 7 8 9 10 int height; class Test(){ public: void test_1(int height){ result=height*2; /* 这里的height使用的是参数声明 */ } } private: int result=0; 不建议成员函数中的名字隐藏同名的成员。 1 2 3 4 5 6 7 8 9 10 11 int height; class Test(){ public: void test_1(int height){ result=height*2; /* 隐藏了同名的成员，使用的是形参 */ } } private: int result=0; int height=10; 可以显式的使用this指针强制访问成员或者加上类名的方式，将result=height*2;修改为result=this-\u0026gt;height*2或者result=Test::height*2以此绕过上述的名字查找规则\n建议我们在使用成员函数中给形参起一个不会重名的名字。 1 2 3 4 void test_1(int ht){ /* 起一个不会冲突的形参名 */ result=ht*2; // result=height*2; /* 使用的是成员height，而非形参ht */ } 类作用域之后，在外围的作用域中查找 如果编译器并没有在成员函数和类的作用域中找到名字的声明，那么便会从外围的作用域中接着查找。 例如，我们想要Screen外层的height对象：\n1 2 3 void test_1(int ht){ result=::height*2; /* 通过显式作用域运算符进行请求 */ } 建议，无论是类外名字、类内的数据成员还是成员函数形参名都不要重名，防止隐藏作用域中可能被用到的名字造成认知逻辑模糊。\n在文件中名字的出现处对其进行解析 当成员定义在类外时，名字查找的第三步不仅需要考虑类定义之前的全局作用域中的声明，还需要考虑在成员函数定义之前的全局作用域中的声明。\n1 2 3 4 5 6 7 8 9 10 11 12 int height; class Screen{ public: int pos; void setHeight(pos); pos height=0; /* 隐藏了外层作用域中的height */ }; Screen::pos verify(Screen::pos); /* 全局函数声明 */ Screen::setHeight(pos var){ /* 参数var */ height=verify(var); /* height是类成员，verify是全局函数 */ } 全局函数的声明在Screen类的定义之前是不可见的。然而，名字查找的第三步包括类成员函数出现之前的全局作用域，因为verify的声明位于成员函数setHeight的定义之前，所以能够被正常使用。\n7.5 构造函数再探 在之前我们了解类构造函数的基本知识，接下来将会对构造函数的一些其他功能进行分析与学习。\n构造函数初始值列表 类似于我么定义变量时（直接进行初始化，而不是先定义、再赋值），对于对象的数据成员，如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化。\n1 2 3 4 5 Test::Test(const string \u0026amp;s){ _str=s; }; Test::Test(const string \u0026amp;s):_str(s){}; /* 上述与本表达式一致 */ 如示例，二者构造函数的定义效果一致，只不过上面那个版本进行赋值，而下面那个版本直接进行初始化。两种版本的区别的深层次影响完全依赖于数据成员的类型。\n构造函数的初始值有时必不可少 有时候我们可以忽略数据成员初始化与赋值之间的差距，但是并非总能够这样。如果成员是const或者引用必须进行初始化。类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。\n❗ 初始化const或者引用类型的数据成员的唯一机会就是通过构造函数进行初始化。\n建议\n使用构造函数初始值\n在很多类中，初始化和赋值的区别主要是底层效率问题：前者直接初始化数据成员，后者则先初始化再赋值。\n除了效率问题外，一些数据成员必须被初始化。所以建议养成使用构造函数初始值的习惯，这样能够避免某些意想不到的编译错误，特别是遇到有的类含有需要构造函数初始值的成员时。\n成员初始化的顺序 构造函数中函数初始值对每个成员只能够出现一次（多次出现没有意义😂），但是值得注意的一点是：在构造函数中成员的初始化执行顺序 并不会被限制，但是成员的初始化顺序会与其在类中定义出现的顺序一致。\n一般情况下，构造函数初始化列表中初始值的顺序并不会影响到实际的初始化顺序，but（又来🤣）当我们尝试使用一个成员去初始化另一个成员时便会出现问题。\n1 2 3 4 5 6 7 class Test{ private: int i; int j; public: Test(int val):j(val),i(j){}; } 在上述例子中，我们想要的顺序是：首先将通过val初始化j，然后通过j初始化i。但是实际上确是：先将通过j初始化i，再通过val初始化j。这就导致一个问题，试图通过未定义的值初始化i。\n建议\n通过上述示例，相信明白了初始化顺序的意义，所以建议令构造函数的初始化列表遵循类成员声明顺序，同时尽可能地避免使用某些成员初始化其他成员，使其我们不必考虑成员的初始化顺序。\n默认实参和构造函数 如果一个构造函数为所有参数都提供了默认实参，那么其实际上也就定义了默认构造函数\n例如：我们为SalesData类的默认构造函数重写为使用默认实参方式：\n1 2 //SalesData() = default; SalesData(std::string s = \u0026#34;\u0026#34;) : _bookNo(std::move(s)){}; /* 形式等同默认构造函数 */ 建议\n为构造函数中所有参数提供默认实参应该从实际出发，在某些时候我们就是希望user提供初始化值，这个时候就不应该为参数添加默认实参。\n委托构造函数 在C++新标准下扩展了构造函数初始化值的功能，使得可以定义委托构造函数（delegating constructor）。何谓委托构造函数，其函数可以使用它所属类的其他构造函数执行它自己的初始化过程，也就是说，这类函数可以将自己的一些（或者全部）职责由其他构造函数代劳。（听起来是不是方便了开发者😄）。\n1 2 3 4 5 6 /* 非委托构造函数 */ SalesData(std::string str, unsigned number, double price) : _bookNo(std::move(str)), _units_sold(number), _revenue(price * number) {} /* 委托构造函数 */ SalesData() : SalesData(\u0026#34;\u0026#34;, 0, 0.0){}; SalesData(std::istream \u0026amp;istream) : SalesData() { read(istream, *this); } 当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被一次执行，最后将控制权返回给委托者，委托者这个时候执行函数体。\n❓ 默认构造函数的作用 在《C++ primer 》中详细描述了使用细节：\n当对象被默认初始化或者值初始化时自动执行默认构造函数。其发生于：\n默认初始化下：\n当我们在块作用域内不使用任何初始值定义一个非静态变量或者数组时 当一个类本身含有类类型的成员且使用合成的默认构造函数时 当类类型的成员没有在构造函数初始值列表中显式地初始化时 值初始化下：\n在数组初始化的过程中如果我们提供的初始值数量小于数组的大小时 当我们不使用初始值定义一个局部静态变量时 当我们通过书写形如T()的表达式显式地请求值初始化时、 在上述情况下，我们必须在类中包含一个默认构造函数用于上述使用。\n建议\n在编写类的其他构造函数时，习惯性的编写一个默认构造函数\n隐式的类类型转换 在内置类型中，某些类型存在自动转换机制（或者说是规则），同样，类中也存在，称为类定义隐式转换规则。如果构造函数只接受一个实参，则它实际上定义了转换为类类型的隐式转换机制，这种构造函数称为转换构造函数（converting constructor）。可以这样说：通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。\n1 2 3 4 Sales_data item; string str=\u0026#34;123\u0026#34;; /* combine: Sales_data \u0026amp;combine(Sales_data \u0026amp;); */ item.combine(str); /* 执行隐式的类类型转换 */ 上述中，str为string类型， 编译器类受到str通过构造函数Sales_data(String \u0026amp;) 自动创建一个Sales_data对象，这个对象传递给combine函数。（注意：这个对象是一个临时量）\n需要注意的是，类类型转换仅允许一次转换，或者这样说，编译器只会自动执行一步的类型转换。\n1 2 3 4 5 Sales_data item; string str=\u0026#34;123\u0026#34;; /* combine: Sales_data \u0026amp;combine(Sales_data \u0026amp;); */ item.combine(str); /* 合法 */ item.combine(\u0026#34;123\u0026#34;); /* 不合法，进行了两步隐式类型转换 */ 类类型转换不是总有效 类类型转换依赖于用户的选择与使用，在某些时候进行转换可能得到的是一个不存在的东西。同时类类型转换过程中我们会创建一个临时对象，当转换结束该对象也将会被销毁！\n抑制构造函数定义的隐式转换 某些情况下，我们希望构造函数不能进行隐式转换，那么可以通过在函数前添加explicit关键词。\n注意点：\n关键词explicit仅对具有一个实参的构造函数有效（毕竟只有一个实参的构造函数才能执行隐式转换） 仅能够在类内部声明构造函数时使用（类外部的定义不应该重复使用该关键字） explicit构造函数只能够用于直接初始化 发生隐式转换的情况有很多种，其中一种是当我们执行拷贝形式的初始化时，那么此时不能够使用explict构造函数。\n1 2 3 string str=\u0026#34;123\u0026#34;; Sales_data item_1(str); /* 合法 */ Sales_data item_2=str; /* 非法 */ 为转换显式地使用构造函数 在内置类型中我们可以显式地强制执行类型转换（虽然非常不建议使用），同理，在类类型中也可以使用显式地强制转换。\n1 2 item.combine(Sales_data(str)); /* 合法 */ item.combine(static_cast\u0026lt;Sales_data\u0026gt;(cin)); /* static_cast可以强制转换，使之执行explicit构造函数 */ 标准库中含有显式构造函数的类 在标准库中的一些类含有单参数的构造函数，其中部分函数具有explicit关键字：\n接受一个单参数的const char*的string构造函数不是explicit。 1 2 3 4 5 6 7 8 basic_string(const _CharT* __s, const _Alloc\u0026amp; __a = _Alloc()) : _M_dataplus(_M_local_data(), __a) { const _CharT* __end = __s ? __s + traits_type::length(__s) // We just need a non-null pointer here to get an exception: : reinterpret_cast\u0026lt;const _CharT*\u0026gt;(__alignof__(_CharT)); _M_construct(__s, __end, random_access_iterator_tag()); } 接受一个容量参数的vector构造函数是explicit的。 1 2 3 4 explicit vector(size_type __n, const allocator_type\u0026amp; __a = allocator_type()) : _Base(_S_check_init_len(__n, __a), __a) { _M_default_initialize(__n); } 聚合类 何谓聚合类？聚合类指的是：\n所有成员都是public的 没有定义任何构造函数 没有类内初始值 没有基类，也没有virtual函数 这种类的所有成员都可以被访问，并且具有特殊的初始化语法形式称为聚合类。\n例如：\n1 2 3 4 5 6 7 class Data{ /* 这就是一个聚合类 */ int _number; string _statement; }; /* 特殊的初始化语句 */ Data data={0,\u0026#34;123\u0026#34;}; 注意：\n初始化的顺序必须与声明的顺序一致。 初始值列表中元素个数不能多于类的数据成员数量。 如果初始值列表中元素个数少于类的数据成员数量，则靠后的成员被值初始化。 补充\n显式地初始化类的对象的成员存在三个明显缺点：\n要求类的所有成员都是public的 将正确初始化每个对象的每个成员的重任交给了类的用户。如果用户忘记某个初始值或者提供一个不恰当的初始值，那么这样的初始化过程将会冗长乏味且易出错 添加或者删除一个成员后，所有的初始化语句都需要更新 字面值常量类 数据成员都是字面值类型的聚合类即为字面值常量类。如果一个类不是聚合类，如果符合下面条件，也是一个字面值常量类：\n数据成员都必须是字面值类型 类必须至少含有一个constexpr构造函数 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数 类必须使用析构函数的默认定义，该成员负责销毁类的对象 补充\n在6.5.2节中解释过constexpr函数的参数和返回值必须是字面值类型。\nconstexpr构造函数 构造函数不能为const，但是字面值常量类的构造函数可以是constexpr函数。\n一个字面值常量类必须至少提供一个constexpr构造函数。\nconstexpr构造函数可可以声明为“=default”形式或者是删除函数形式。否则constexpr构造函数必须既要符合构造函数规则又要符合constexpr函数的要求。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Test{ private: bool hw; /* 硬件错误 */ bool io; /* io错误 */ bool other; /* 其他错误 */ public: constexpr Test(bool b=true):hw(b),io(b),other(b){} constexpr Test(bool h,bool i,bool o):hw(h),io(i),other(o){} constexpr bool any(){return hw || io||other;} public: void set_io(bool b){io=b;} void set_hw(bool b){hw=b;} void set_other(bool b){other=b;} } constexpr构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数，或者是一条常量表达式。\nconstexpr构造函数用于生成constexpr对象以及constexpr函数的参数或者返回类型\n1 2 3 4 5 6 7 constexpr Test io_sub(false,true,false); if(io_sub.any()) /* 调试IO */ cerr\u0026lt;\u0026lt;\u0026#34;print appropriate error messages\u0026#34;\u0026lt;\u0026lt;endl; constexpr Test prod(false); /* 无调试 */ if (prod.angy()) cerr\u0026lt;\u0026lt;\u0026#34;print an error message\u0026#34;\u0026lt;\u0026lt;endl; 7.6 类的静态成员 我们有一种需求：希望某些类成员与类相关而非与类的对象相关，这个时候我们就可以使用类的静态成员。\n声明类的静态成员 通过在成员的声明前加上关键字static使得其与类关联在一起。当然，静态成员可以是public或者是private的。静态数据成员的类型可以是常量、引用、指针、类类型等。\n类的静态成员存在于任何对象之外，对象中不包含任何与静态成员有关的数据。类似的，静态成员函数也不与任何对象绑定在一起，所以其不包含this指针。\n使用类的静态成员 我们使用作用域直接访问静态成员：\n1 2 double r; r=Account::rate(); 虽然静态成员不属于类的某个对象，但是我们任然可以使用类的对象、引用或者指针来访问静态成员。至于成员函数则可以不用通过作用域运算符就可以直接使用静态成员。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Account{ public: void calculate(){ amount +=amount*interestRate;} /* 可以直接访问静态成员 */ static void rate(double); private: std::string owner; double amount; static double interestRate; static double initRate(); }; Account a_1; Account *a_2=\u0026amp;a_1; double r; r=Account::rate(); /* 使用作用域运算符来访问静态成员 */ r=a_1.rate(); /* 通过Account的对象或者引用 */ r=a_2-\u0026gt;rate(); /* 通过指向Account对象的指针 */ 定义静态成员 与其他成员函数一致，静态成员函数也可以在类外部定义但是不能重复使用static关键字（也就是说该关键字只能够在类内使用）。\n因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能够定义一次。\n开发\n想要确保静态对象只被定义一次，最好的办法是把所有静态数据成员的定义与其他非内联函数的定义放在同一个文件中。\n静态成员的类内初始化 通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的。\n1 2 3 4 class Account{ private: static constexpr int period = 30; /* period是常量表达式 */ } 建议\n即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。\n特别的点，静态数据成员的类型可以就是它所属的类类型，但是非静态成员受到限制，只能声明成它所属类的指针或者引用。\n1 2 3 4 5 6 class Bar{ private: static Bar item_1; /* 正确 */ Bar *item_2; /* 正确 */ Bar item_3; /* 错误 */ } 静态成员和普通成员的另外一个区别就是我们可以使用静态成员作为默认实参。非静态数据成员则不行，因为它的值本身属于对象的一部分，这么做将会导致无法真正提供一个对象以便从中获取成员的值，从而导致错误。\n总结 类允许我们为自己的应用定义新类型，从而使得程序更加简洁易于修改。\n类具备两项基本能力：一是数据抽象，二是封装。\n类中的构造函数用于控制初始化对象。\n类可以定义可变或者静态成员。\n","date":"2025-04-06T00:00:00Z","image":"https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg","permalink":"https://Free-Aaron-Li.github.io/p/c-%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/","title":"C++ 基础： 第七章 类"},{"content":"第三章 字符串、向量和数组 前言 标准库是C++必不可少的一部分，作为C++的延伸，标准库的优雅令人陶醉。\n如标题所言，在这一章我们将要学习数组、字符串和向量。若学习过其他编程语言，相信对数组并不陌生。其作为固定存储序列，能够为我们提供很多数据结构的解决思路，但是其在灵活性方面的不足使之诞生向量：向量，给定类型对象的可变长序列。\n同时，也会对字符串做一些解释。\n3.1 命名空间的using声明 在之前的编写代码的过程中，对std并不陌生：\n1 2 std::cin; std::cout; “std”属于是命名空间，“::”作用域操作符则表明：编译器应该从操作符左侧名字所示的作用域中寻找右侧名字。\n由于每次使用命名空间中的成员都需要显式添加“std::”，较为繁琐。所以C++提供一种方式：使用“using”声明（using declaration）。\n其具体形式：using namespace::name;，例如：\n1 using std::cin; /* 当我们声明后，之后使用cin无需再添加std:: */ 注意\n头文件不应当包含using声明\n3.2 标准库类型 string string，字符串类型，是一种可变长的字符序列。\n具体示例：\n1 2 3 4 5 6 string str_1; /* 默认初始化，为空串 */ string str_2(str_1); /* str_2为str_1的副本 */ string str_3=str_1; /* 等价于str_2(str_1) */ string str_4(\u0026#34;this\u0026#34;); /* str_4是字面值“this”的副本（删去字面值最后那个空字符）*/ string str_5=\u0026#34;this\u0026#34;; /* 等价于str_4(\u0026#34;this\u0026#34;) */ string str_6(n,\u0026#34;this\u0026#34;); /* 将str_6初始化为由n个“this”组成的串 */ 由上面示例可以看出，在string初始化上分为两种：\n“string str_1=\u0026ldquo;1\u0026rdquo;”的方式称为拷贝初始化（copy initialization） “string str_1(\u0026ldquo;1\u0026rdquo;)”的方式称为直接初始化（direct initialization） 在设计类的时候，我们不光需要规定其初始化对象的方式，还需要定义对象上能够执行的操作。\n在这方面，string有如下操作：\n操作 作用 os\u0026laquo;s 将s写到输出流os中，返回os is\u0026raquo;s 从is中读取字符串赋给s，字符串以空白分隔，返回is getline(is,s) 从is中读取一行赋给s，返回is s.empty() s为空返回true，反之返回false s.size() 返回s中字符个数 s[n] 返回s中第n个字符的引用，n从0开始 s1+s2 返回s1和s2的字符串合并的字符串 s1=s2 将s2的副替换s1中原本的字符 s1==s2,!=,\u0026lt;,\u0026lt;=,\u0026gt;,\u0026gt;= s1与s2字符串做比较，大小写敏感 我们曾通过使用iostream中的标准输出/输出来读写内置类型，同样其也能用于对string类型的读写。\n例如：\n1 2 3 std::string str; std::cin\u0026gt;\u0026gt;str; std::cout\u0026lt;\u0026lt;str; 需要注意的是：从标准输入流中读取到string对象时，string对象会删除开头空白，同时遇到空白结束读取。\n参考上述代码，若输入流为：“ this ”，那么str的内容将是“this”。\n若想要读取到空白字符，有两种方式：\n1 2 3 4 5 6 7 8 9 std::string str; while (std::cin\u0026gt;\u0026gt;str){ /* 方式① */ std::cout\u0026lt;\u0026lt;str; if (std::cin.get()==\u0026#39;\\n\u0026#39;)break; } while (getline(std::cin, str)){ /* 方式② */ std::cout\u0026lt;\u0026lt;str; } 补充\n关于“size()”函数，其返回值类型为“string::size_type”类型，可以将其理解为无符号整型数。\n注意关键点：无符号。所以“str.size()\u0026lt;n”，n为负整数，那么其结果判断几乎是true，因为n将自动转换一个较大的无符号值。（可以查看第二章的基本内置类型）\n同时注意，如果一个表达式中已经存在size()函数就不要再使用int，这样避免混用int和unsigned可能带来的问题。\n关于string对象的对比规则，注意点：\nstring对象的对比依赖于对大小写敏感的字典顺序 在对比两对象大小时，若二者字符相同，则进行串长度对比；若二者字符不同，则对比二者第一处相异字符大小。 例如：\n1 2 3 string str_1=\u0026#34;this\u0026#34;; string str_2=\u0026#34;this is good!\u0026#34;; string str_3=\u0026#34;thity\u0026#34;; 在上述例子中，str_1小于str_2，而str_3比str_1和str_2都大。 原因：\n对比str_1和str_2，二者对比所有字符序列，满足较短者与较长者相同则比较长度，明显str_2更长。 将str_3与前两者做对比，“thi”序列都相同，比较“s”和“t”的大小，显然“t”更大，所以str_3大于前两者。 关于将字面值与string对象相加，存在一个注意事项：\n我们运行将string对象与字面值相加，但是不允许仅存在字面值：string str=\u0026quot;this\u0026quot;+\u0026quot; is world\u0026quot; 这种方式是错误的！究其原因，“this”和“is world”都不是string对象，不允许相加。\n同时，我们也不允许这样的用法：\n1 2 string str_1=\u0026#34;word\u0026#34;; string str_2=\u0026#34;this\u0026#34;+\u0026#34; is \u0026#34;+str_1; /* 错误 */ 其原因和上述的注意一样，我们可以这样看str_2的相加过程：str_2=(\u0026quot;this\u0026quot;+\u0026quot; is \u0026quot;)+str_1;，这与上述错误一样！\n补充\n或许在其他程序设计语言，例如python上可以使用字面值相加的方式为string类型赋值。但是由于历史原因：为了和C兼容，C++的字符串字面值并不是string对象。也就是说：字面值和string是两种类型！，这也就解释上述的注意点。\n当我们想要处理string对象中单个字符时，其往往需要库来处理它们。\n例如：cctype库：\n函数名 解释 isalnum(c) 当c为字母或数字时，返回true isalpha(c) 当c为字母时，返回true iscntrl(c) 当c是控制字符时，返回true isdigit(c) 当c是数字时，返回true isgraph(c) 当c是可见字符(即不是空格且可打印）时，返回true islower(c) 当c是小写字母时，返回true isprint(c) 当c是可打印字符时，返回true ispunct(c) 当c是标点符号时，返回true isspace(c) 当c是空白时，返回true isupper(c) 当c是大写字母时，返回true isxdigit(c) 当c是十六进制字符时，返回true tolower(c) 当c是大写字母时，转换为小写字母 toupper(c) 当c是小写字母时，转换为大写字母 补充\ncctype头文件与C语言的ctype.h头文件内容一致，只不过使用了C++版本的C标准头文件。在C++版本下：将会将.h删除且在文件名前加上c。\n在使用这些C语言标准库时，应该遵循C++标准下的头文件名，而非使用C语言的头文件名。使用C++标准下的C标准库名，其库中名字总能够在命名空间std下找到，而使用C标准头文件命名则不一定。\n对于想要处理每一个字符，在这里介绍一种新的遍历方式：范围for（range for）语句\n具体的语法形式为：\n1 2 for (declaration:expression) statement; 解释：\ndeclaration，声明。用于定义一个变量，该变量用于访问序列中的基础元素。一般情况下，使用auto定义该变量。 expression，表达式。表示目标对象，一般为一个序列。 statement，称述。对对象进行操作。 示例：\n1 2 3 string str = \u0026#34;Hello World!\u0026#34;; for(auto i: str) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt;\u0026#34; \u0026#34;; 当然，我们也可以写一个较复杂的语句：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;string\u0026gt; int main(){ /** * 统计语句中的标点符号数目 */ std::string str_1=\u0026#34;Hello,World!\u0026#34;; std::string str_2(\u0026#34;你好，世界！\u0026#34;); /* 定义number用于统计数目，使用decltype保证其类型与string对象长度类型一致 */ decltype(str_1.size()) number_1=0; decltype(str_2.size()) number_2=0; for(auto i:str_1) if(std::ispunct(i)) /* ispunct函数检测是否为标点符号，位于cctype库，注意：检测中文则需要单独设置locale */ ++number_1; for(auto c:str_2) if(std::ispunct(c)) ++number_2; std::cout\u0026lt;\u0026lt;\u0026#34;The str_1 is \u0026#39;\u0026#34;\u0026lt;\u0026lt;str_1\u0026lt;\u0026lt;\u0026#34;\u0026#39; and the str_2 is \u0026#39;\u0026#34;\u0026lt;\u0026lt;str_2\u0026lt;\u0026lt;\u0026#34;\u0026#39;\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34;The number of punctuation marks for the string str_1 is \u0026#34;\u0026lt;\u0026lt;number_1 \u0026lt;\u0026lt;\u0026#34; and str_2 is \u0026#34;\u0026lt;\u0026lt;number_2\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } 其结果为：\n1 2 The str_1 is \u0026#39;Hello,World!\u0026#39; and the str_2 is \u0026#39;你好，世界！\u0026#39; The number of punctuation marks for the string str_1 is 2 and str_2 is 0 上式的注意点：使用decltype关键字来声明number变量，是由于string的size()函数返回类型是特殊的：string::size_type\n，这样做到保证能够极限接受string对象中的字符数。\n相信对如何操作string对象和如何使用范围for语句有一定了解，那么接下来我们尝试去操作一下如何改变字符串的字符：\n将字符串的字母大写：\n1 2 3 4 5 string str_1=\u0026#34;hello,world!\u0026#34;; for(auto \u0026amp;c:str_1) c=std::toupper(c); cout\u0026lt;\u0026lt;\u0026#34;The string is now: \u0026#34;\u0026lt;\u0026lt;str_1\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; 注意点：如果想要改变string对象中字符的值，必须将循环变量（也就是 declaration）定义为引用类型。\n芜湖，是不是很简单🤩\n上式我们尝试将整个字符串大写，但是我们想要对部分字符修改该怎么办呢🧐\n有两种方法：使用下标或使用迭代器。\n注意\n使用下标时，注意其字符串范围（[0,size()-1)），使用超出此范围的下标将引发不可知后果。所以在使用下标时必须判断string对象是否为空以及判断其是否超过string对象的范围。\n1 2 3 4 5 6 7 8 9 string str=\u0026#34;hello,world!\u0026#34;; if(!str.empty()){ /* 使用下标方式 */ s[0]=std::toupper(s[0]); } if(decltype(str.size()) index=0; /* 使用下标方式进行迭代 */ index!=str.size() \u0026amp;\u0026amp; !std::isspace(str[index]));++index) s[index]=std::toupper(s[index]); 3.3 标准库类型vector 标准库类型vector表示对象的集合，其中所有对象的类型都是相同的。通常我们也会称其为容器（container）。\n需要注意的是：vector是模板而非类型，所以由vector生成的类型必须包含vector中元素的类型。\n初始化vector对象 方法 解释 vector\u0026lt;T\u0026gt; v1 v1表示一个空vector，其潜在元素为T，执行默认初始化 vector\u0026lt;T\u0026gt; v2(v1) v2中包含v1的副本 vector\u0026lt;T\u0026gt; v3(n,val) v3中包含n个重复的元素，每个元素的值都是val vector\u0026lt;T\u0026gt; v2=v1 等价于vector\u0026lt;T\u0026gt; v2(v1) vector\u0026lt;T\u0026gt; v4(n) v4包含了n个重复地执行了值初始化的对象 除此之外，还有这两种方式：\nvector\u0026lt;T\u0026gt; v5{a,b,c\u0026hellip;} v5包含了初始值个数的元素，每个元素被赋予了相应的初始值 vector\u0026lt;T\u0026gt; v5={a,b,c\u0026hellip;} 等价于上式 在C++ 11标准下，还有新的初始化方式：vector\u0026lt;T\u0026gt; v6={\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;c\u0026rdquo;}\n注意\n对vector初始化需要考虑初始化方式：\n例如：vector\u0026lt;int\u0026gt; v1(10)就表明我初始化10个元素，每个元素的值都是默认值0。但是当我们不采用标准的方式初始化那么编译器则会尝试使用默认值初始化vector对象。例如：\n1 2 vector\\\u0026lt;string\u0026gt; v1{10}; /* v1具有10个默认初始化的元素 */ vector\\\u0026lt;string\u0026gt; v1{10,\u0026#34;hi\u0026#34;}; /* v1具有10个值为“hi”的元素 */ 向vector对象添加元素 有些时候，我们并不能获知vector对象的所有值，所以在这个时候我们就需要使用push_back功能来为对象添加元素。\npush_back的运作方式：\n将一个值当做vector对象的尾元素“压入”到vector对象的尾部中。形象的来讲就是push to back。\n例如：\n1 2 3 4 5 std::vector\u0026lt;int\u0026gt; v; for(int i=0;i\u0026lt;10;i++){ v.push_back(i); /* v对象中将存在0~9共10个依次排列元素 */ } 补充与注意\n在我们使用其他程序设计语言时，也许会在一开始便为存储对象赋予其大小。但是这在使用vector对象上是没必要的更甚可以说是有损性能的。\n在C++的标准下：vector能够在运行时高效的添加元素。这样就显得在初始化时设定其大小是无意义的。（当然也有例外：vector中所有元素值都是一样的）\n所以，建议在使用vector时，应该在开始阶段仅创建空的vector对象，在运行时才动态添加元素。\n同时还需要注意一点：无法通过使用范围for循环为vector添加元素，因为范围for针对已经确定其容器大小的对象进行遍历，无法改变遍历对象本身的大小。\n注意点： 不能通过下标方式为vector添加元素\n其他vector操作与技巧 vector作为C++中常用的容器，当然不仅仅只存在push_back这一个操作，还有：\n操作名 解释 v.empty() 如果v不含有任何元素，则返回真 v.size() 返回v中个数（而不是下标数） v.push_back(t) 在v的尾部压入值t v[n] 返回v中第n个位置上元素的引用 v1=v2 将v2中元素拷贝替换v1中元素 v1==v2 比较v1和v2相等，其元素数目和对应位置元素值皆相等 \u0026lt;,\u0026lt;=,\u0026gt;,\u0026gt;= 以字典顺序比较 在C++中还提供一种方式：使用列表方式替换vector对象中列表内容：v1={a,b,c\u0026hellip;}\n补充\n缓冲区溢出（buffer overflow），指通过下标访问不存在元素的行为所导致的错误后果。由于其无法被编译器所发现,且运行时会产生一个不可预知值（即垃圾值），导致运行在应用程序上出现严重安全错误。\n示例：\n1 2 vector\\\u0026lt;int\u0026gt; array(10,0); std::cout\u0026lt;\u0026lt;array[10]; /* buffer overflow */ 在本书中提到：确保下标合法的一种有效手段就是尽可能使用范围for语句\n当然，可以使用不固定容器的大小的vector对象来存储元素（这是较优解），那么访问不存在元素的下标返回值便为默认设定值。例如：vector\u0026lt;int\u0026gt; array默认返回值为0\n3.4 迭代器 在此之前，我们通过下标运算符访问string或vector对象元素，但是下标运算符并不通用（指只有少数几种标准库容器才支持该运算符）。对此我们可以使用“迭代器”这一通用机制（所有的标准库容器均支持迭代器），迭代器类似于指针类型，其本身支持对对象的间接访问。\n使用迭代器 这里介绍两个成员：begin和end：\nbegin用于返回容器中第一个元素，end用于返回容器最后一个元素的下一个位置。当容器为空时，其begin和end为同一值。\n迭代器运算符 运算符 解释 *iter 返回迭代器iter所指元素的引用，解引用 iter -\u0026gt;mem 解引用iter并获取该元素的名为mem的成员，等价于(*item).mem ++iter 令iter指示容器的下一个元素 \u0026ndash;iter 令iter指示容器中的上一个元素 iter1==iter2 判断两个迭代器是否相等，如果两个迭代器指示的是同一个元素或者它们是同一个容器的尾后迭代器，则相等 类似于指针类型，可以通过解引用的方式获取其迭代器所指示的元素，但是试图解引用尾后迭代器是非法的！\n通过使用“\u0026ndash;”递减运算符和“++”递增运算符实现迭代器的移动，但是需要注意的是无法对尾后迭代器进行递增操作。\n示例：\n1 2 3 for(auto iter=str.begin(); iter!=str.end(); ++iter){ *iter = toupper(*iter); } 补充\n在C++开发中，我们常用!=来对for循环条件进行判断，虽然使用“\u0026lt;”依旧可行，但是究其原因与“相较于使用下标运算符，更原因使用迭代器”原因一样，这种编码风格在标准库中所有容器上都能生效。为了方便与安全，使用这种风格方式更为可靠。\n迭代器类型 关于迭代器类型其实与指针类型类似：\n1 2 string::iterator iter1; /* iter1能够读写string对象中的元素 */ string::const iterator iter2; /* iter2能够读string对象中的元素，但是不能够写；常量仅能使用该迭代器 */ 在上面的示例中，我们可以明确的看到迭代器（iterator）的两个类型：iterator和const iterator。\n迭代器其本身有三种含义：\n迭代器概念本身 迭代器类型 迭代器对象 根据具体使用场景即可分辨。\nbegin和end运算符 在上文中，我们已经了解了begin和end所指定的对象，但是其返回类型我们可以聊聊：\n根据所指向的对象类型，这两个运算符均可返回iterator和const iterator类型，但是我们通常使用auto来承担迭代器类型，导致在某些情况下，无法具体得知其对象返回类型。同时，在某些操作下：比如某个对象仅需要读操作而不需要写操作，这个时候为了安全考虑：我们必须将其返回值设定为const类型。\n这个时候，C++ 11引入两个新的运算符：cbegin和cend，这两个运算符决定其指示对象的对象类型是否是常量，返回值类型均为const iterator。\n某些对vector对象的操作会使得迭代器失效 在前文中我们提到：无法在范围for语句中对vector对象添加元素。在此，我们也需要注意到的是任何一种能够改变vector对象容器的操作都会使得该对象的迭代器失效！\n注意\n但凡改变了迭代器的循环体，都不要向迭代器所属的容器添加元素。\n迭代器运算 类似之前我们提到的vector和string对象所具有的如：!=、==，迭代器也同样提供了一些支持特定功能的运算符，称为“迭代器运算”（iterator arithmetic）\n运算符 解释 iter+n/iter-n 迭代器加上一个整数仍然得到一个迭代器。其表示相比原来向后（向前）移动若干个元素。 iter+=n/iter-=n 将iter加上（减去）n的结果赋值给iter iter1-iter2 两个迭代器之间距离（仅表示迭代器距离，非实际距离） \u0026gt;、\u0026gt;=、\u0026lt;、\u0026lt;= 比较两个迭代器距离大小，若为真返回1，否则返回0 注意\n无论是对两迭代器进行相减还是比较，其迭代器所指向的容器必须为同一个。\n补充\n两迭代器相减距离指的是被减迭代器需要移动x位到达iter1的位置所需要的值。该值是类型名为“difference_type”的带符号整型数。\n在使用自增与自减运算时，iter++与++iter效率却是不同的：\n++itr（或–itr）返回引用 itr++（或itr–）返回临时对象 究其原因，由于iterator是类模板，使用iter++这种方式会返回一个临时的对象，同时iter++方式进行的是函数重载，编译器无法进行优化。\n所以在实际遍历下，每使用一次iter++，就会创建一个临时对象并销毁。在效率上有差距。所以建议在使用自增自减运算符时使用“++i/\u0026ndash;i”的方式。\n3.5 数组 数组类似于vector的数据结构，其本质还是容器。只不过相较于vector在性能和灵活上做了权衡，数组的大小是固定的，所以假如你并不知道需要存入容器的元素的确切个数，应当选择vector。\n定义、初始化数组 数组本质上是一种复合类型。\n1 array[i]; /* array表示数组名，i表示数组的维度 */ 数组的维度说明了数组中元素的个数，所以维度必须大于0。同时由于数组的大小是固定的，所以元素的维度必须预先确定，即维度应当为常量。\n1 2 3 4 5 unsigned i=12; constexper unsigned j=12; /* 常量表达式 */ int array_1[j]; /* 合法 */ int *array_2[j]; /* 合法 */ int array_3[i]; /* 不合法 */ 补充\nint *array[n]表示含有n个int类型指针的数组，int (*array)[n]表示含有n个int值的数组指针\n说完定义，我们再来谈一谈初始化。与之前的数据结构初始化类似：\n当我们不指明维度的个数时，编译器会根据初始值数量进行推算；但是，若编译器指明了维度，如果初始值个数超过了指定大小则会报错。\n同时，我们需要注意到一种特殊的数组：字符数组，其除了常规的初始化方式外，字符数组还可以使用字符串字面值进行初始化。例如：\n1 char array_1[]=\u0026#34;this\u0026#34;; /* array_1:\u0026#39;t\u0026#39;、\u0026#39;h\u0026#39;、\u0026#39;i\u0026#39;、\u0026#39;s\u0026#39;、\u0026#39;\\0\u0026#39; */ 需要注意的点：使用字符串字面值进行初始化,字面值结尾处的一个空字符“\\0”也会被添加入数组中。\n在某些时候，我们认为数组作为对象，应该可以进行赋值、拷贝操作。但这是严禁的！不允许将数组的内容拷贝给其他数组作为其初始值，也不能使用数组为其他数组进行赋值操作。\n补充\n也许你在其他编译器上进行数组的赋值、拷贝操作并未出现问题，但是不能够保证使用其他编译器编译你的程序时不会出现问题。编译器是否能够支持该操作取决于编译器扩展（compiler extension），一般来讲，我们最好是选择避免使用非标准特性。\n有些时候，对数组的声明看起来有些不友好，例如你能区分指向数组的指针和存放指针的数组吗？\n这里我们遵循一个阅读语句的规律：从内向外，从右向左\n例子：\n1 2 3 4 5 int *array_1[10]; int \u0026amp;array_2[10]=array; int (*array_3)[10]=\u0026amp;array; int (\u0026amp;array_4)[10]=array; int *(\u0026amp;array_5)[10]=array; 我们一一解答：\n第一个，遵循从右向左读，那么首先定义一个大小为10的数组，其名字叫array_1，同时根据“int *”明白其存放的是int类型指针。所以，该语句解释为：存放10个int类型指针的数组。 第二个，依照上述，首先定义一个大小为10的数组，名字为array_2，根据“\u0026amp;”明白该数组中元素为引用，但是数组的元素应当为对象，不存在引用情况，所以第二个是错误的。 第三个，如果我们仅依靠从右向左读的方式理解有些模糊，所以这个时候我们就要借用从内向外读的方式：首先我们先读括号内部，“*array_3”表明一个名为array_3的指针，之后从右向左读，定义一个大小为10的数组，其指针array_3指向该数组。所以，该语句解释为：一个指向存放了10个int类型值的数组的指针。 第四个，同样的道理，我们可以得出该语句解释为：一个存放10个int类型值的数组的引用对象。 第五个，本质上就是第三个和第四个的结合，应当解释为：一个存放10个int类型指针数组的引用对象。 访问数组元素 同vector和string数据结构，数组也可以通过下标的方式访问数组元素，其下标定义为size_t类型。（size_t是一种与机器相关的无符号类型，其被设计得足够大）。该类型在cstddef头文件中被定义。\n指针和数组 在C++中，指针和数组关系非常密切，例如：编译器通常将数组转换为指针。\n由于数组和数组中的元素本身就是对象，所以我们可以使用指针来指向数组或数组中的元素：\n1 2 int num[]={1,2,3}; int *p=\u0026amp;num[0]; 同时，数组还具有一个特性：在很多用到数组名字的地方，编译器都会将其自动替换为指向数组首元素的指针。所以在大多数表达式中，使用数组类型的对象实际上是使用一个指向该数组首元素的指针。\n综上所述，在一些情况下，我们对数组的操作其实是对指针的操作，例如：\n1 2 int i[]={1,2,3}; auto i2(i); /* i2其实是“int *” */ 注意\n使用decltype关键字并不会发生上述转换，而是依照下面的转换规则：\n1 2 int i[]={1,2,3}; decltype(i) i2={1,2,3}; /* decltype(i)转换为：int[3] */ decltype关键字会按照实际情况进行转换：i为存放3个int类型元素的数组，那么decltype关键字按照i的类型转换为“int[3]”。\n指针也是迭代器 我们在之前了解了迭代器，其实会发现迭代器与指针工作方式相似。\n其实指针也是迭代器，在之前提及的迭代器操作，数组指针全部支持。\n我们之前使用到的begin和end方法，在C++ 11中得到，例如：\n1 2 3 int i[]={1,2,3}; int *begin=begin(i); /* 指向i首元素的指针 */ int *end=end(i); /* 指向i尾元素下一位置元素的指针 */ 由于这两个函数在“iterator”头文件中被定义，所以与上述我们对vector进行迭代操作使用迭代器的方式不相同。\n在C++ 17中还定义有cbegin和cend两个函数。\n当两个指向同一个数组的指针相减时，其结果是它们二者之间的距离：\n1 2 int arr[]={1,2,3}; auto distance=end(arr)-begin(arr); /* distance的值为3 */ 得到的distance的类型为ptrdiff_t的标准库类型，和size_t类型，ptrdiff_t也是被定义在cstddef头文件中的机器相关的类型，只不过该类型是带符号类型，而size_t为无符号类型。\nC风格字符串 注意\n虽然C++支持C风格字符串，但是最好不要使用！\n何为C风格字符串（C-style character string）？\nC风格字符串是为了表达和使用字符串而形成的一种约定俗成的写法。此写法习惯于将书写的字符串存放在字符数组中并以空字符结束（null terminated）。即在字符串的最后一个字符后面添加一个“\\0”。\n首先，先了解“cstring”头文件，在此C++版本的string.h头文件中：\n函数 解释 strlen(p) 返回p的长度，空字符不在计算内 strcmp(p1,p2) 比较p1和p2的想等性，若等于，返回0；若p1\u0026gt;p2，返回正值；若p1\u0026lt;p2，返回负值 strcat(p1,p2) 将p2附加到p1后，返回p1 strcpy(p1,p2) 将p2拷贝给p1，返回p1 需要注意的是：传入此类函数的指针必须指向一空字符结尾的数组，若字符数组未以空字符结尾，那么函数将有可能继续沿着数组所在内存中的位置不断查找，直到遇见空字符。\n与旧代码的接口 由于C++诞生与1983年8月，而C++标准则诞生与1999年1月，所以为了与过去的C++程序进行连接，于是诞生了与旧代码的接口。\n混用string对象和C风格字符串 在前文介绍string时，我们提到过使用字符串常量初始化string对象：\n1 string str(\u0026#34;this time\u0026#34;); 为了与之前的C风格字符串做连接，这种方式更为一般：\n允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值。（准确来讲，假如字符数组中没有空白字符，初始化string对象时会从数组中依次查找空白字符直到找到，所以哪怕字符数组中最后结尾的不是空白字符也能成功初始化，只不过string对象的字符串可能多了些不确定值） 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能够两个都是）；在string对象的复合赋值运算中允许使用以空白字符结束的字符数组作为右侧的运算对象。 示例：\n1 2 3 4 5 6 7 8 9 10 const char str_1[] = {\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;\\0\u0026#39;}; const char str_1_c[] = {\u0026#39;9\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;7\u0026#39;}; std::string str_2; str_2 = str_1; std::cout \u0026lt;\u0026lt; str_2 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; /* 123 */ std::string str_3 = str_1 + str_2; std::cout \u0026lt;\u0026lt; str_3 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; /* 123123 */ std::string str_4 = str_3; str_4 += str_1; std::cout \u0026lt;\u0026lt; str_4 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; /* 123123123 */ 但是，这种对旧代码的连接只适合以字符数组初始化、赋值string对象，不能反过来。为了实现反过来的功能，string提供名为“c_str”的成员函数。\nc_str函数的返回值是一个C风格的字符串。\n示例：\n1 2 3 std::string str_5 = \u0026#34;this is good time\u0026#34;; const char *str_6 = str_5.c_str(); for (auto i = str_6; *i != \u0026#39;\\0\u0026#39;; ++i) { std::cout \u0026lt;\u0026lt; *i; } /* this is good time */ 因为c_str函数会创建一个以空白字符结束的内容与string对象一致的字符数组并返回该数组的首元素指针。所以我们通过const保存该首元素指针用来读取该字符数组。\n但是我们无法保证c_str函数返回的数组一致有效，也就是说只要后续我们修改了string对象，那么返回数组就可能会失效。所以最好的方式还是需要拷贝一份数组。\n使用数组初始化vector对象 实际上，用数组初始化vector对象的方式，我们应该遇见过：\n1 2 int array[]={1,2,3}; vector\u0026lt;int\u0026gt; vector(begin(array),end(array)); 是不是很简单😆\n建议\n虽然我们可以通过对于旧代码的接口、下标和数组的方式对容器进行操作，但是建议尽量使用标准库类型而非数组。\n指针常用于底层操作，当你对指针不熟练时常常会引发未知的、难以查找、难以调试测试的错误😅。同时你也可能因为对语法的不熟悉或疏忽导致错误，特别是对指针的声明。\n现如今，我们应当输入使用迭代器和vector来替代数组，避免使用内置数组和指针。 同时我们也因当尽量使用string，而非C语言风格字符串。\n多维数组 从本质上来讲，多维数组其实是数组的数组，并不存在多维之说。\n在使用范围for语句处理多维数组时，需要注意到对循环控制变量应当采用引用类型：\n1 2 3 4 5 6 7 8 constexpr size_t rowCnt=3,colCnt=4; int cnt=0; int array[rowCnt][colCnt]; for(auto \u0026amp;row: rowCnt) for(auto \u0026amp;col:colCnt){ col=cnt; ++cnt; } 这里使用引用的原因是编译器可能会将控制变量自动转化为指针，例如，若row不设置为引用类型，那么row将转化为第二维数组的首元素指针。那么，内层范围for语句就无法执行。\n注意\n如果使用范围for语句处理多维数组，除了最内层的循环外，其他循环的控制语句都应该是引用类型。\n关于指针和多维数组 遍历多维数组，如果使用下标的方式遍历往往会导致我们对多维的数组不清晰，通过使用C++ 11的新特性auto来解决此问题：\n1 2 3 4 for(auto p=ia;p!=ia+3;++p) for(auto q=*p;q!=*p+4;++q){ cout\u0026lt;\u0026lt;*q\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } 当然，我们可以使用迭代器来解决指针复杂的问题：\n1 2 3 for(auto p=begin(ia);p!=end(ia);++p) for(auto q=begin(*p);q!=end(*p);++q) cout\u0026lt;\u0026lt;*q\u0026lt;\u0026lt;\u0026#34; \u0026#34;; 如果厌倦指针，那么我们还可以使用类型别名的方式让遍历简单一些：\n1 2 3 4 5 6 7 8 using int_array=int[4]; typedef int int_array[4]; for(int_array *p=ia;p!=ia+3;++p){ for(int *q=*p;q!=*p+4;++q){ cout\u0026lt;\u0026lt;*q\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } } 总结 学习到两类标准库类型：string和vector，string用于存放可变长的字符序列，vector用于存放同类型对象。\n通过迭代器我们可以间接访问容器，特别是对string和vector还可以在元素之间移动。\n一般来讲，我们应该尽量少用数组，对于旧C++代码（标准库出现之前）我们可以使用与旧代码的接口使用vector和string替代数组和C风格字符串。\n","date":"2025-04-06T00:00:00Z","image":"https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg","permalink":"https://Free-Aaron-Li.github.io/p/c-%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/","title":"C++ 基础： 第三章 字符串、向量和数组"},{"content":"第十二章 动态内存 前言 在此之前，我们使用的程序中对象都有着严格定义的生存期：\n全局对象，在程序启动时分配，在程序结束时销毁。 局部自动对象，当进入定义所在程序时创建，在离开块时销毁。 局部static对象，在第一次使用前分配，在程序结束时销毁。 显然这存在限制，为此C++支持动态分配对象。动态分配对象的生存期与它们在哪里创建无关，只有当显式地被释放时，这些对象才会被销毁。\n动态对象的正确释放是编程中极其容易出错的地方。那么为了更安全释放，标准库定义了两个智能指针来管理动态分配的对象。当一个对象应该被释放时，指向它的智能指针可以确保自动地释放它。\n静态内存：局部static对象、类static数据成员以及定义在任何函数之外的变量\n栈内存：定义在函数内的非static对象\n分配在静态或栈内存的对象由编译器自动创建和销毁。除了静态内存和栈内存，每个程序还拥有一个内存池。称为自由空间或堆，程序用堆来存储动态分配（dynamically allocate）的对象——即那些在程序运行时分配的对象。\n动态内存和智能指针 在C++中，动态内存的管理通过一对运算符完成：\nnew，在动态内存中为对象分配空间并返回一个指向对象的指针，可以选择对对象初始化 delete，接受一个动态对象的指针，销毁该指针指向的对象，并释放与之关联的内存 但是动态内存的使用容易出问题，难以确保在正确时间释放内存，那么就可能出现“内存泄露”、“引用非法指针”等。对此，标准库引入两种智能指针（smart pointer）：\nshared_ptr，允许多个指针指向同一个对象 unique_ptr，独占所指向的对象 智能指针的行为类似常规指针，区别在于智能指针负责自动释放所指向的对象。上述的两种指针区别在于管理底层指针的方式不同。\n同时，标准库还定义了一个weak_ptr的伴随类，其是一个弱引用，指向shared_ptr所管理的对象。三者均定义在memory头文件中。\nshared_ptr类 智能指针为模板，在创建时需要提供额外的信息表明指针可以指向的类型。\n1 2 shard_ptr\u0026lt;string\u0026gt; p_1; shard_ptr\u0026lt;list\u0026lt;int\u0026gt;\u0026gt; p_2; shared_ptr和unique_ptr都支持的操作 解释 shared_ptr\u0026lt;T\u0026gt; spunique_ptr\u0026lt;T\u0026gt; up 空智能指针，可以指向类型为T的对象 p 将p用作一个条件判断，若p指向一个对象，则为true *p 解引用p,获得它指向的对象 p-\u0026gt;member 等价于(*p).member p.get() 返回p中保存的指针。要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了 swap(p,q)p.swap(q) 交换p和q中的指针 shard_ptr独有的操作 解释 make_shared\u0026lt;T\u0026gt;(args) 返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化此对象 shared_ptr\u0026lt;T\u0026gt;p(q) p是shared_ptr q的拷贝。此操作会递增q中的计数器。q中的指针必须能转化为T* p=q p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0,则将其管理的原内存释放 p.unique() 若p.use_count()为1,返回true,否则返回false p.use_count() 返回与p共享对象的智能指针数量；可能很慢，主要用于调试 make_shared函数 最安全的分配和使用动态内存的方法是调用make_shared标准库函数，此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。\n1 2 3 shared_ptr\u0026lt;int\u0026gt; p_3=make_shared\u0026lt;int\u0026gt;(42); // 指向一个值为42的int shared_ptr\u0026lt;string\u0026gt; p_4=make_shared\u0026lt;string\u0026gt;(2,\u0026#39;9\u0026#39;); // 指向一个值为“99”的string shared_ptr\u0026lt;int\u0026gt; p_5=make_shared\u0026lt;int\u0026gt;(); // 指向一个值初始化的int shared_ptr的拷贝和赋值 当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：\n1 2 auto p=make_shared\u0026lt;int\u0026gt;(42); // p指向的对象只有p一个引用者 auto q(P); // p和q指向相同对象，此对象有两个引用者 我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数（reference count）。无论何时拷贝一个shared_ptr,计数器都会递增。例如，当用一个shared_ptr初始化另一个shared_ptr,或将它作为参数传递给一个函数以及作为函数的返回值时，它所关联的计数器就会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域）时，计数器就会递减。\n当一个shared_ptr的计数器变为0,它就会自动释放自己所管理的对象：\n1 2 3 4 5 auto p = make_shared\u0026lt;int\u0026gt;(42); // p指向的int只有一个引用者 p = q; // 给p赋值，令它指向另一个地址 // 递增q指向的对象的引用计数 // 递减p原来指向的对象的引用计数 // p原来指向的对象已经没有引用者，会自动释放 到底是用一个计数器还是其他数据结构来记录有多少指针共享对象，完全由标准库的具体实现来决定。关键是智能指针类能记录有多少个shared_ptr指向相同的对象，并能在恰当的时候自动释放对象。\nshared_ptr自动销毁所管理的对象 shared_ptr类会通过析构函数（destructor）完成销毁工作。shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数为0,shared_ptr的析构函数就会销毁对象，并释放它所占用的内存。\n如果将shared_ptr存放在一个容器中，而后不再需要某些元素，而只使用其中的一部分，要记得用erase删除不再需要的那些元素\n使用了动态生存期的资源的类 程序使用动态内存出于以下三种原因之一：\n程序不知道需要多少对象 程序不知道所需对象的准确类型 程序需要在多个对象间共享数据 直接管理内存 在前面我们知道C++定义了new和delete进行动态内存的分配和释放。相对于智能指针，这两个运算符管理非常容器出错。自己直接管理内存的类与使用智能指针的类不同，它们不能依赖于类对象拷贝、赋值和销毁操作的任何默认定义，因此，使用智能指针的程序更容易编写和调试。\n常见的new：\n1 int* pi =new int; // pi指向一个动态分配的、未初始化的无名对象 默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是为定义的，而类类型对象将用默认构造函数进行初始化。\n1 2 string *p_s=new string; int *pi=new int; 默认初始化\n如果定义变量时没有指定初值，则变量被默认初始化（default initialized），此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。\n如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0；定义在函数体内部的内置类型变量将不被初始化。一个未被初始化的内置类型变量的值是未定义的。如果试图拷贝或以其他形式访问此类值将引发错误。\n对动态分配的对象，我们可以采用直接初始化、传统的构造方式、列表初始化、值初始化的方式进行初始化。\n1 2 3 4 5 int* p_s0=new string; // 默认初始化 int* p_i1=new int(123); // 直接初始化 int* p_s1=new string(10,\u0026#34;1\u0026#34;); // 传统的构造方式 vector\u0026lt;int\u0026gt;* p_v1=new vector\u0026lt;int\u0026gt;{0,1,2,3}; // 列表初始化 string* p_s2=new string(); // 值初始化 对于定义了自己的构造函数的类类型（如string）来说，值初始化是没有意义的，但是对内置类型对象来说则有很大的意义：值初始化的的内置类型对象有着良好的值，而默认初始化的对象的值则是未定义的。\n同样，对于类中依赖于编译器合成的默认构造函数的内置类型成员，如果它们未在类内被初始化，那么它们的值也是未定义的。\n所以，出于与变量初始化相同的原因，对动态分配的对象进行初始化通常是个好主意\n这里就有一个“骚操作”：\n1 2 auto p_1 = new auto(obj); // 从obj那里推断想要分配的对象的类型 auto p_2 = new auto{a,b,c}; // 错误，括号中只能有单个初始化器 动态分配的const对象 类似其他任何const对象，一个动态分配的const对象必须进行初始化。对于一个定义了默认构造函数的类类型，其const动态对象可以隐式初始化。\n1 2 const int* P_c_i = new const int(1024); const string* p_c_s = new const string; 内存耗尽 如果自由空间（堆空间）资源耗尽，new表达式将会失败，并抛出bad_alloc异常。可以改变new方式阻止其抛出异常：\n1 int *p_1 = new (nothrow) int; // 如果分配失败，new返回一个空指针 对上述代码中形式的new称为定位new（placement new）。定位new表达式允许我们向new传递额外的参数。上述我们向new传递一个由标准库定义的nothrow对象，告诉它不能抛出异常。bad_alloc和nothrow都定义在new头文件中。\n释放动态内存 传递给delete的指针必须指向动态分配的内存，或者是一个空指针。释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为都是未定义的。\n虽然一个const对象的值不能被改变，但是其本身是可以被销毁的。\n由内置指针（而不是智能指针）管理的动态内存在会被显式释放前一直都会存在\n所以，动态内存的管理非常容易出错。\n使用new和delete管理动态内存存在三个常见问题：\n忘记delete内存。忘记释放动态内存会导致“内存泄露”问题，因为这种内存永远不可能被归还给自由空间。查找内存泄露错误是非常困难的，因为通常应用程序运行很长时间后，真正耗尽内存后，才能检测到这种错误。 使用已经释放掉的对象。即“空指针异常”。 同一块内存被释放两次。这种情况下自由空间可能被破坏掉。 相对于查找和修正这些错误来说，制造出错误简单很多。\n当delete一个指针后，其指针值无效，但是机器上指针仍然保存已释放动态内存的地址。即空悬指针（dangling pointer）。\n未初始化指针的所有缺点空悬指针一个不落。其中“在指针即将离开其作用域前释放掉它所关联的内存”可以作为一种解决方案，如果想要保留指针，需要在delete之后nullptr赋予它，这样清楚地指出指针不指向任何对象。\n但这仅仅做出一点小的修复，动态内存的另一个基本问题是存在多个指针指向相同内存的情况，仅解决其中一个指针，其他指针依旧存在问题。\n所以，对于动态内存请务必使用智能指针！\nshared_ptr和new的结合使用 如果不初始化一个智能指针，那么它就会被初始化为一个空指针。其实，还可以用new返回的指针来初始化智能指针。\n1 2 shared_ptr\u0026lt;double\u0026gt; p1; shared_ptr\u0026lt;int\u0026gt; p2(new int(42)); 接受指针参数的智能指针构造函数是explicit的，所以，不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式。相同的，不能将一个智能指针不能隐式转换为内置指针。\n1 shared_ptr\u0026lt;int\u0026gt; p1 = new int(1024); //false 内置指针隐式转换为智能指针 默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象。\n定义和改变shared_ptr的其他方法 解释 shared_ptr p(q) p管理内置指针q所指向的对象；q必须指向new分配的内存，且能够转换为T*类型 shared_ptr p(u) p从unique_ptr u那里接管了对象的所有权：将u置为空 shared_ptr p(q,d) p接管了内置指针q所指向的对象的所有权。q必须能转换为T*类型。p将使用可调用d来代替delete shared_ptr p(p2,d) p是shared_ptr p2的拷贝，唯一的区别是p将用可调用对象d来代替delete p.reset()p.reset(q)p.reset(q,d) 若p是唯一指向其对象的shared_ptr,reset会释放此对象。若传递了可选的参数内置指针q,会令p指向q,否则会将p置为空。若还传递了参数d,就会调用d而不是delete来释放q 不要混合使用普通指针和智能指针 shared_ptr可以协调对象的析构，但这仅限于其自身的拷贝（也是shared_ptr）之间。这就是推荐使用make_shared而不是new的原因。可以在分配对象的同时就将shared_ptr与之绑定，从而避免无意中将同一块内存绑定到多个独立创建的shared_ptr上。\n1 2 3 4 5 6 7 8 9 10 11 12 void process(shared_ptr\u0026lt;int\u0026gt; ptr){ // 值传递，ptr引用计数+1 // 使用ptr } // 销毁ptr shared_ptr\u0026lt;int\u0026gt; p(new int(42)); // 引用计数为1 process(p); // 在process中引用计数为2 int i = *p; // 正确，引用计数为1 int* x(new int(1024)); // 危险：x是一个普通指针 process(x); // 错误，无法隐式转换 process(shared_ptr\u0026lt;int\u0026gt;(x)); // 合法，临时shared_ptr，内存会被释放 int j = *x; //未定义：x是一个空悬指针！ 当将一个shared_ptr绑定到一个普通指针时，我们就将内存的管理责任交给了这个shared_ptr。一旦这样做了，我们就不应该再使用内置指针来访问shared_ptr所指向的内存了。\n使用一个内置指针访问一个智能指针所负责的对象是危险的，因为我们无法知道对象何时被销毁！\n不要使用get初始化另一个智能指针或为智能指针赋值 智能指针类型定义了一个get函数，用于返回一个指向“智能指针管理的对象”的内置指针。此函数设计的目的是：将指针的访问权限传递给代码。使用get返回的指针的代码不能delete此指针。\n将另一个智能指针绑定到get返回的指针上是错误的。\n1 2 3 4 5 6 shared_ptr\u0026lt;int\u0026gt; p(new int(42)); // 引用计数为1 int* q=p.get(); // 使用q时需要注意，不要让它管理的指针被释放 { shared_ptr\u0026lt;int\u0026gt;(q); } // 当程序块结束，q被销毁，它指向的内存被释放 int x = *p; // 错误，p指向的内存已经被释放 p和q指向相同的内存。由于二者相互独立，因此各自引用计数为1.当q所在程序块结束，q被销毁，这会导致q指向的内存被释放。从而导致p变成空悬指针，当意图使用p时，将发生为定义行为。同时，当p被销毁时，这块内存将会被二次delete。\n其他shared_ptr操作 可以使用reset来将一个新的指针赋予一个shared_ptr：\n1 2 p = new int(1024); // false p.reset(new int(1024)); // true 与赋值类似，reset会更新引用计数，如果需要的话，会释放p指向的对象。reset成员经常与unique一起使用，来控制多个shared_ptr共享的对象。在改变底层对象之前，需要检查是否是当前对象仅有的用户。如果不是，在改变之前需要进行一份拷贝。\n1 2 3 if(!p.unique()) p.reset(new string(*p)); // 分配新的拷贝 *p += newVal; // 是唯一的用户，可以改变对象的值 智能指针和异常 1 2 3 4 5 6 7 8 9 10 void f_v1(){ shared_ptr\u0026lt;int\u0026gt; pt(new int(42));// 分配一个新对象 // 如果在这里抛出异常，且在f中未被捕获 } // 函数结束时，shared_ptr仍然会自动释放内存 void f_v2(){ int* p=new int(42); // 动态分配一个新对象 // 如果在这里抛出异常，且f并未捕获异常 delete p; // 在此之前退出，内存无法被释放 } 智能指针确保了内存在不需要时将其释放，但是如果是内置指针则不一定能够正常释放。\n智能指针和哑类 包括所有标准库类在内的很多C++类都定义了析构函数，通过析构函数清理对象使用的资源。但是并不是所有的类都是这样良好的定义的，对于某些类需要用户显式地释放所使用的任何资源。对于这种类称为哑类。\n在使用哑类的过程中，如果程序员忘记释放资源或者在资源分配和释放之间发生异常，都会导致资源泄露。那么基于这种情况，可以使用智能指针管理动态内存的类似技术来管理哑类。\n1 2 3 4 5 6 7 8 9 10 11 12 // 假设存在一个网络库，其中connection没有析构函数 struct destination; // 表示需要连接什么 struct connection; // 连接所需信息 connection connect(destination*); // 打开连接 void disconnect(connection); // 关闭给定的连接 void f(destination \u0026amp;d){ // 获得一个连接，需要显式关闭它 connction c= connect(\u0026amp;d); // 使用连接 // 忘记调用disconnect函数关闭连接，那么f函数结束就无法关闭它。 } // 资源泄露 对于上述出现的情况，通过使用shared_ptr修改默认的删除器实现对connection的智能管理：\n1 2 3 4 5 void end_connection(connection* p){disconnect(*p)); void f(destination \u0026amp;d){ connection c=connect(\u0026amp;d); shared_ptr\u0026lt;connection\u0026gt; p(\u0026amp;c,end_connection); } // 当p被销毁时，调用disconnect函数确保连接关闭 注意：智能指针陷阱\n为了正确使用智能指针，必选坚持的一些基本规范：\n不使用相同的内置指针初始化（或reset）多个智能指针 不delete get()返回的指针 get函数仅是为了将智能指针访问内存的权力暂时给予内置指针\n不使用get()初始化或reset另一个智能指针 get()本质是某个智能指针的内置指针化，如果初始化或reset给另一个智能指针。将导致同一块动态内存被多个智能指针所管理，将导致出现空悬指针、多次delete等问题。\n如果你使用get()返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了 get()仅仅作为智能指针向内置指针传递权力的工具，当权力的源头失效了自然所对应的内置指针就变为空悬指针，需要将内置指针赋予nullptr\n如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器 智能指针默认调用delete操作销毁内存\nunique_ptr 一个“unique_ptr”“拥有”它所指向的一个对象。\nunique_ptr特有操作 解释 unique_ptr u1unique_ptr\u0026lt;T,D\u0026gt; u2 空unique_ptr,可以指向类型为T的对象。u1会使用delete来释放它的指针；u2会使用一个类型为D的可调用对象来释放它的指针 unique_ptr\u0026lt;T,D\u0026gt; u(d) 空unique_ptr,指向类型为T的对象，用类型为D的对象d代替delete u=nullptr 释放u指向的对象，将u置为空 u.release u放弃对指针的控制权，返回指针并将u置为空 u.reset() 释放u指向的对象 u.reset(q)u.reset(nullptr) 如果提供了内置指针q,令u指向这个对象；否则将u置为空 无法使用类似make_shared的标准库函数返回一个unique_ptr。所以当定义一个unique_ptr时，需要绑定到一个new返回的指针上。\n1 unique_ptr\u0026lt;int\u0026gt; p(new int(42)); 由于unique_ptr拥有它指向的对象，所以unique_ptr不支持普通的拷贝或赋值操作\n1 2 3 4 unique_ptr\u0026lt;int\u0026gt; p1(new int(42)); unique_ptr\u0026lt;int\u0026gt; p2(p1); // false unique_ptr\u0026lt;int\u0026gt; p3; p3=p1; // false 但是可以通过release或reset实现指针控制权的转移：\n1 2 3 4 5 // 将控制权从p1转移到p2 unique_ptr\u0026lt;int\u0026gt; p2(p1.release()); // release将p1置为空，且返回指针 unique_ptr\u0026lt;int\u0026gt; p3(new int(42)); // 将控制权从p3转移到p2 p2.reset(p3.release()); // reset释放p2原本指向内存 调用release函数会切断unique_ptr和它原本管理的对象间的联系。release返回的指针（一般为内置指针）通常被用来初始化另一个智能指针或给另一个智能指针赋值。这仅仅是简单的权力交接，但是，如果不用一个智能指针保存release返回的指针，则需要负责资源的释放。\n不能拷贝unique_ptr规则的一个例外：可以拷贝或赋值一个将要被销毁的unique_ptr：\n1 2 3 4 5 6 7 8 9 unique_ptr\u0026lt;int\u0026gt; clone(int p){ return unique_ptr\u0026lt;int\u0026gt;(new int(p)); // 从int*创建一个unique_ptr\u0026lt;int\u0026gt; } unique_ptr\u0026lt;int\u0026gt; clone(int p){ unique_ptr\u0026lt;int\u0026gt; ret(new int(p)); // ... return ret; } 编译器知道要返回的对象将要被销毁，所以在这种特殊的情况下，编译器执行一种特殊的“拷贝”。\n向unique_ptr传递删除器 类似于shared_ptr,unique_ptr默认情况下用delete释放其对象，也可以重载unique_ptr中的默认删除器。但是,unique_ptr管理删除器的方式与shared_ptr不同。\n重载一个unique_ptr中的删除器会影响到unique_ptr类型以及如何构造该类型的对象。所以必须在尖括号中unique_ptr指向类型之后提供删除器类型。在创建或reset一个这种unique_ptr类型的对象时，必须提供一个指向类型的可调用对象（删除器）：\n1 unique_ptr\u0026lt;objT,delT\u0026gt; p(new objT,fun); 例如：\n1 2 3 4 void f(Destination \u0026amp;d){ Connection c = connect(\u0026amp;d); unique_ptr\u0026lt;Connection, decltype(end_connection)*\u0026gt; p (\u0026amp;c,end_connection); } weak_ptr weak_ptr是一种不控制所指向对象生存周期的智能指针，它指向由一个shared_ptr管理的对象。其具有**“弱”共享对象**的特点：绑定到某个shared_ptr上并不会改变该shared_ptr引用计数；即使weak_ptr还指向某个对象，当指向该对象的shared_ptr被销毁时，该对象也会被释放。并不会因为weak_ptr关系而不释放。\nweak_ptr 解释 weak_ptr w 空weak_ptr可以指向类型为T的对象 weak_ptr w(sp) 与shared_ptr指向相同对象的weak_ptr。T必须能转换为sp指向的类型 w=p p可以是一个shared_ptr或一个weak_ptr。赋值后w与p共享对象 w.reset() 将w置为空 w.use_count() 与w共享对象的shared_ptr的数量 w.expired() 若w.use_count()为0,返回true,否则返回false w.lock() 如果expired为true，返回一个空shared_ptr；否则返回一个指向w的对象的shared_ptr 由于weak_ptr“弱”共享的特性，存在weak_ptr指向内存已经被释放情况。所以，weak_ptr不能直接访问对象，需要调用lock函数检查weak_ptr指向对象是否存在，如果存在返回指向共享内存的shared_ptr。\n12.2 动态数组 C++与标准库提供两种一次分配一个对象数组的方法。一种采用new表达式，可以分配并初始化一个对象数组；另一种采用allocator类，允许将分配和初始化分离。\n注意：尽管提供直接访问动态数组的方法，但是大多数应用应该使用标准库容器而不是动态分配数组。\nnew和数组 分配数组必须指明对象元素的数量：\n1 2 3 4 5 int *p_1 = new int[get_size()]; // 或者 typedef int arrT[42]; int *p_2 = new arrT; 分配一个数组会得到一个元素类型的指针。同时由于分配的内存并不是数组类型，所以不能调用begin或者end。\n初始化动态分配对象的数组，使用new分配的对象，不论是单个分配还是数组中的，都是默认初始化。可以对数组中的元素进行值初始化：\n1 int *p_3 = new int[10](); 也可以提供一个元素初始化器的花括号列表：\n1 string *p_4 = new string[10]{\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,string(3,\u0026#34;d\u0026#34;)}; 如果初始化器数目小于元素数目，剩余元素进行值初始化；如果大于，则new表达式失败，不会分配任何内存且抛出bad_array_new_length（定义在new中）的异常。\n动态分配一个空数组是合法的，但是指向该空数组的指针不能解引用。\n释放动态数组则采用特殊形式的delete：\n1 delete [] *p_5; // 空括号是必需的，其指示编译器此指针指向一个对象数组的第一个元素 该delete语句将销毁p_5指向的数组中元素并释放内存。数组中的元素按照逆序销毁。\n如果在delete一个数组指针时忘记方括号或者delete一个单一对象的指针时使用了方括号都是未定义的。编译器很可能不会给出警告。程序可能在执行过程中在没有任何警告的情况下行为异常。\n智能指针和动态数组 标准库提供可以管理new分配数组的unique_ptr版本：\n1 2 unique_ptr\u0026lt;int[]\u0026gt; up(new int[10]); up.release(); // 自动使用delete[]销毁其指针 由于unique_ptr指向的是一个数组而不是对象，所以不能使用点和箭头成员运算符。可以使用下标运算符来访问数组中的元素：\n1 2 for(size_t i = 0; i!=10; ++i） up[i]=i; 指向数组的unique_ptr 解释 unique_ptr\u0026lt;T[]\u0026gt; u u可以指向一个动态分配的数组，数组元素类型为T unique_ptr\u0026lt;T[]\u0026gt; u(p) u指向内置指针p所指向的动态分配的数组。p必须能转换为类型T* u[i] 返回u拥有的数组中位置i处的对象（u必须指向一个数组） shared_ptr不支持直接管理动态数组：\n需要自定义删除器 为定义下标运算符 所以，如果使用shared_ptr管理动态内存数组，需要这样：\n释放数组：\n1 2 shared_ptr\u0026lt;int\u0026gt; sp(new int[10],[](int *p){delete[] p;}); sp.reset(); // 使用提供的lambda释放数组 访问数组元素：\n1 2 for(size_t i=0; i!=10;++i) *(sp.get()+i = i; allocator类 new将内存分配和对象构造组合在一起，delete操作将对象析构和内存释放组合在一起。这带来一定的局限性。当分配单个对象时，通常希望上述操作合并起来，因为我们几乎肯定知道对象有什么值。但是当分配一大块内存时，我们通常需要事先计划，等到真正执行对象时才执行创建操作。\n标准库提供allocator类，其将内存分配和对象构造分离，通过提供一种类型感知的内存分配方法，其分配的内存是原始的、未构造的。\nallocator本身是一个模板，当分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对齐位置。\n1 2 allocator\u0026lt;string\u0026gt; alloc; auto const p=alloc.allocate(n); // 分配n个未初始化的string 标准库allocator类及其算法 解释 allocator a 定义了一个名为a的allocator对象，它可以为类型为T的对象分配内存 a.allocate(n) 分配一段原始的、未构造的内存，保存n个类型为T的对象 a.deallocate(p,n) 释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小。在调用deallocate之前，用户必须对每个在这块内存中创建的对象调用destroy a.construct(p,args) p必须是一个类型为T*的指针，指向一块原始内存；arg被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象 a.destroy(p) p为T*类型的指针，此算法对p指向的对象执行析构函数 allocator分配的内存是未构造的，按需要在此内存中构造对象。\n1 2 3 4 auto q = p; // q指向最后构造的元素之后的位置 alloc.construct(q++); // *q为空字符串 alloc.construct(q++,2,\u0026#39;c\u0026#39;); // *q为cc alloc.construct(q++,\u0026#34;hi\u0026#34;); // *q为hi 对未构造的对象使用原始内存是错误的！\n当用完对象后，必须使用每个构造的元素调用destroy销毁它们。当元素被销毁，那么可以选择重新使用这部分内存也可以通过调用deallocate释放内存。\n1 2 3 4 while(q!=p) alloc.destroy(--q); alloc.deallocate(p,n); 在标准库中还为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。\nallocator算法 解释 uninitialized_copy(b,e,b2) 从迭代器b和e指出的输入范围中拷贝元素到迭代器b2指定的未构造的原始内存中。b2指向的内存必须足够大，能容纳输入序列中元素的拷贝 uninitialized_copy_n(b,n,b2) 从迭代器b指向的元素开始，拷贝n个元素到b2开始的内存中 uninitialized_fill(b,e,t) 在迭代器b和e指定的原始内存范围中创建对象，对象的值均为t的拷贝 uninitialized_fill_n(b,n,t) 从迭代器b指向的内存地址开始创建n个对象。b必须指向足够大的未构造的原始内存，能够容纳给定数量的对象 例如：\n1 2 3 4 5 // vi为int的vector allocator\u0026lt;int\u0026gt; alloc; auto p = alloc.allocate(vi.size()*2); auto q = uninitialized_copy(vi.begin(),vi.end(),p); uninitialized_fill_n(q.vi.size(),42); 12.3 使用标准库：文本查询程序 实现一个简单的文本查询程序：允许用户在一个给定的文件中查询单词，查询结果为单词在文件中出现的次数及其所在行的列表。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Enter the file name to look up: QuotesInEnglish.txt Enter word to look for, or \u0026#39;q\u0026#39; to exit: the \u0026#34;the\u0026#34; occurs 17 times: (line 5) 2、Variety is the spice of life. (line 17) 5、Doubt is the key to knowledge. (line 49) 13、Life is the art of drawing sufficient conclusions form insufficient premises. (line 65) 17、Life is a great big canvas, and you should throw all the paint on it you can. (line 77) 20、The wealth of the mind is the only wealth. (line 105) 27、Wealth is the test of a man\u0026#39;s character. (line 109) 28、The best hearts are always the bravest. (line 117) 30、There\u0026#39;s only one corner of the universe you can be sure of improving, and that\u0026#39;s your own self. (line 125) 32、Death comes to all, but great achievements raise a monument which shall endure until the sun grows old. (line 133) 34、Suffering is the most powerful teacher of life. (line 149) 38、A fall into the pit, a gain in your wit. (line 153) 39、A guest should suit the convenience of the host. (line 161) 41、All rivers run into the sea. (line 169) 43、An apple a day keeps the doctor away. (line 181) 46、Behind the mountains there are people to be found. Enter word to look for, or \u0026#39;q\u0026#39; to exit: q 进程已结束，退出代码为 0 文本查询程序的设计 |源代码|\n开发一个程序在设计上的一种好方法是列出程序的操作，了解需要哪些操作会帮助我们分析出需要什么样的数据结构。\n当程序读取输入文件时，它必须记住单词出现的每一行。因此，程序需要逐行读取输入文件，并将每一行分解为独立的单词。 当程序生成输出时， 它必须能提取每个单词所关联的行号 行号必须按照升序出现且无重复 它必须能打印给定行号中的文本 对此，可以这样实现：\n使用一个vector来保存整个输入文件的一份拷贝。输入文件中的每行保存为vector中的一个元素。当需要打印一行时，可以用行号作为下标来提取行文本。 使用一个istringstream来将每行分解为单词 使用一个set来保存每个单词在输入文本中出现的行号。这保证了每行只出现一次且行号按照升序保存 使用一个map来将每个单词与它出现的行号set关联起来。这样我们就可以方便地提取任意单词的set 为了实现类之间共享数据，使用shared_ptr来反映数据结构中的共享关系 总结 分配动态内存的同时需要负责释放内存，在释放时存在空悬指针、多次delete等问题。智能指针是解决动态内存的好方式，在使用动态指针时，根据计数器会自动释放内存。\n现代C++程序应尽可能使用智能指针。\n","date":"2025-04-06T00:00:00Z","image":"https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg","permalink":"https://Free-Aaron-Li.github.io/p/c-%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/","title":"C++ 基础： 第十二章 动态内存"},{"content":"第十三章 拷贝控制 前言 类是如何控制类型对象的拷贝、赋值、移动和销毁的？类通过一些特殊的成员函数控制，包括：拷贝构造函数、移动构造函数、拷贝赋值运算符、移动赋值运算符以及析构函数。\n当定义一个类时，我们显式地或隐式的指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括： 拷贝构造函数（copy constructor），拷贝赋值运算符（copy-assignment operator）、移动构造函数（move constructor）、* 移动赋值运算符*（move-assignment operator）和析构函数（destructor）。\n拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么；拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么。我们称这些操作为拷贝控制操作（copy control）。\n如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它补全缺失操作。但是对于某些类来说，以来自动补全地默认操作会导致问题。\n在定义任何C++类时，拷贝控制操作都是必要部分。\n拷贝、赋值与销毁 拷贝构造函数 如果一个构造函数的第一个参数时自身类类型的引用，且任何额外参数都有默认值，则此构造函数时拷贝构造函数。\n1 2 3 4 5 class Function{ public: Function(); // 默认构造函数 Function(const Function \u0026amp;); // 拷贝构造函数 } 拷贝构造函数的第一个参数必须是一个引用类型。拷贝在几种情况下都会被隐式使用，因此拷贝构造函数通常不应该是explicit的。\n对某些类来说，**合成拷贝构造函数 **（synthesized copy constructor）用来阻止我们拷贝该类类型的对象。一般情况，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中。\n每个成员的类型决定其如何拷贝：\n对类类型成员，使用拷贝构造函数拷贝 对内置类型成员，直接拷贝 对数组类型，合成拷贝构造函数会逐个元素拷贝一个数组类型的成员 1 2 3 4 5 string a(10,\u0026#34;,\u0026#34;); // 直接初始化 string b(a); // 直接初始化 string c = b; // 拷贝初始化 string d = \u0026#34;123\u0026#34;; // 拷贝初始化 string e = string(1,\u0026#34;a\u0026#34;); // 拷贝初始化 当使用直接初始化，实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。\n函数匹配（重载确认）：指一个过程，在这个过程中将函数调用与一组重载函数中的某一个关联起来。编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。\n当使用拷贝初始化时，编译器将右侧运算符对象拷贝到正在创建的对象中，如果需要进行类型转换。拷贝初始化通常用拷贝构造函数完成。但如果类有移动拷贝函数，那么拷贝初始化有时会使用移动拷贝函数。\n拷贝初始化发生情况：\n用“=”定义变量时 将一个对象作为实参传递给一个非引用类型的形参时 从一个返回类型为非引用类型的函数返回一个对象 用花括号列表初始化一个数组中的元素或一个聚合类中的成员 某些类类型还会对它们所分配的对象进行拷贝初始化。例如：初始化标准库容器或调用其insert或push成员。注意到的是emplace成员创建的元素都进行直接初始化（emplace成员会直接在容器管理的内存空间中构造元素，而非像push_back般创建一个局部临时对象并压入容器中）。\n聚合类：\n所有成员都是public的 没有定义任何构造函数 没有类内初始值 没有基类，也没有virtual类 如：\n1 2 3 4 struct Data{ int ival; string s; } 初始化可以写成：Data val={0,\u0026quot;A\u0026quot;};，初始化顺序必须与声明顺序一致\n参数和返回值 拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。如果不是，那么将陷入死循环，调用永远不会成功。🤯\n拷贝初始化的限制 拷贝初始化一般要求构造函数不使用explicit，如果使用，那么是否是用拷贝初始化还是直接初始化显得无关紧要：\n1 2 3 4 5 vector\u0026lt;int\u0026gt; v1(10); // ok vector\u0026lt;int\u0026gt; v2 = 10; //false 因为构造函数为explicit void f(vector\u0026lt;int\u0026gt;); // ok void f(10); // false void f(vector\u0026lt;int\u0026gt;(10)); // ok 编译器可以绕过拷贝构造函数 拷贝初始化时，编译器可以（不是必须）跳过拷贝/移动构造函数，直接创建对象：\n1 2 3 string a = \u0026#34;a\u0026#34;; // 改写为： string b(\u0026#34;a\u0026#34;); // 编译器略过拷贝构造函数 虽然编译器可以略过，但是在此节点的拷贝/移动构造函数必须存在且可访问（即不是private）。\n拷贝赋值运算符 类可以通过拷贝赋值运算符控制对象如何赋值，同拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会自动合成。\n重载赋值运算符 重载运算符（overloaded operator）本质上是函数，其名字由operator关键字和要定义的运算符符号组成。类似其他函数，运算符函数也有一个返回类型和一个参数列表。\n如果一个运算符是一个成员函数，其左侧运算对象绑定到隐式this参数，对于一个二元运算符，其右侧运算对象作为显式参数传递。\n拷贝赋值运算符接受一个与其所在类相同类型的参数。\n1 Function\u0026amp; operator=(const Function\u0026amp;); 为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向左侧运算对象的引用。同时标准库通常要求保存在容器中的类型具有赋值运算符，其返回值是左侧的引用。所以，在设计赋值运算符时通常应该返回一个指向其左侧对象的引用。\n合成拷贝赋值运算符 合成拷贝赋值运算符（synthesized copy-assignment operator）。与合成拷贝构造函数类似：对于某些类，合成拷贝赋值运算符用来禁止该类型的对象的赋值（因为隐式生成的拷贝构造和赋值可能是delete的）。\n拷贝赋值运算符会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，这一工作通过成员类型的拷贝赋值运算符来完成。对于数组类型的成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。\n1 2 3 4 5 6 7 Sales_data\u0026amp; Sales_data::operator=(const Sales_data \u0026amp;rhs){ bookNo = rhs.bookNo; units_sold = rhs.units_sold; revenue = rhs.revenue; return *this; } 析构函数 析构函数执行与构造函数相反的操作：\n构造函数：初始化对象的非static数据成员，做一些其他工作 析构函数：释放对象使用的资源，并销毁对象的非static数据成员 析构函数作为类的成员函数，函数名由波浪号“~”和类名组成，不接受返回类型和参数。\n1 2 3 4 5 class A{ ~A(){ //…… }; } 析构函数不接受参数，所以不支持重载。一个给定类仅存在唯一析构函数\n在构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员（成员按照初始化顺序的逆序销毁）。\n析构部分是隐式的。成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数；销毁内置类型什么也不需要做。\n隐式销毁一个内置指针类型成员并不会delete它所指向的对象。\n但是销毁智能指针，智能指针是类类型，有自己的析构函数。\n无论何时一个对象被销毁，就会自动调用其析构函数：\n变量在离开其作用域时被销毁 当一个对象被销毁时，其成员被销毁 容器被销毁时，其元素被销毁 对于动态分配的对象，当对指向它的指针应用delete时被销毁 对临时对象，当创建它的完整表达式结束时被销毁 1 2 3 4 5 6 7 8 9 10 { Sales_data *p = new Sales_data; // 内置指针 auto p_2 = make_shared\u0026lt;Sales_data\u0026gt;(); // shared_ptr Sales_data p_3(*p); vector\u0026lt;Sales_data\u0026gt; vec; // 局部变量 vec.push_back(*p_2); delete p; } // 对 p_2、p_3和vec调用析构函数 // 销毁p_2会递减其引用计数 // 销毁vec会销毁其元素 同样，如果类未定义自己的析构函数，编译器会生成合成析构函数。\n认识到析构函数的函数体自身并不直接销毁成员非常重要。成员是在析构函数体之后隐式的析构阶段被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。\n","date":"2025-04-06T00:00:00Z","image":"https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg","permalink":"https://Free-Aaron-Li.github.io/p/c-%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/","title":"C++ 基础： 第十三章 拷贝控制"},{"content":"第十一章 关联容器 前言 关联容器和顺序容器有着本质的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。\n关联容器支持高效的关键字查找和访问。两个主要的关联容器（associative-container）类型是map和set。\nmap中元素以[关键字-值]（key-vale）方式存在，关键字起到索引的作用，值则表示与索引相关联的数据。\nset中元素仅包含一个关键字，其支持高效的关键字查询操作。\n标准库提供8个关联容器：\n按关键字有序保存元素 解释 map 关联数组：保存关键字-值对 set 关键字即值，即只保留关键字的容器 multimp 关键字可重复出现的map multiset 关键字可重复出现的set 无序集合 解释 unordered_map 用哈希函数组织的map unordered_set 用哈希函数组织的set unordered_multimap 用哈希函数组织的map：关键字可以重复出现 unordered_multiset 用哈希函数组织的set：关键字可以重复出现 以上的8个容器的不同体现在三个维度：\n每个容器要么是map,要么是set 容器要求要么是不重复的关键字，要么允许重复关键字 容器按照要么按照顺序存储，要么以无序存储 map与multimap定义在map头文件中；set和multiset定义在set头文件中；无序容器定义在unordered_map和unordered_set中。\n11.1 使用关联容器 简单举例：\nmap类型通常被称为关联数组（associative array）。与一般数组类似，只不过其下标为关键字。例如：给定一个名字到电话号码的map，我们可以使用一个人的名字作为下标来获取此人的电话号码。\nset本质就是关键字的简单集合。\n使用map 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; int main(){ std::map\u0026lt;std::string,std::size_t\u0026gt; word_count; std::string word; while(std::cin\u0026gt;\u0026gt;word) ++word_count[word]; cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; for(const auto\u0026amp; w : word_count) std::cout\u0026lt;\u0026lt;w.first\u0026lt;\u0026lt;\u0026#34; occurs \u0026#34;\u0026lt;\u0026lt;w.second\u0026lt;\u0026lt;((w.second\u0026gt;1)?\u0026#34; times\\n\u0026#34;:\u0026#34; time\\n\u0026#34;); return 0; } RUN\n1 2 3 4 5 6 7 8 9 10 11 12 13 $ g++ -o main -g main.cpp $ ./main hello world ! this is good ! this is bad ! ! occurs 3 times bad occurs 1 time good occurs 1 time hello occurs 1 time is occurs 2 times this occurs 2 times world occurs 1 time 在上述示例代码中，map保存的每个元素中，关键字类型为std::string，值类型为std::size_t。 该示例中，将一个string作为下标，与此string相关联的size_t类型作为计数器。\n当我们从map中提取一个元素时，会得到一个pair类型的对象。pair是一个模板类型，保存两个数据成员（first和second）。map所使用的pair用first成员保留关键字，second成员保存对应的值。\n使用set 对于上面的扩展：合理忽略一些常见单词，如“the”、“and”、“or”、“is”等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; int main(){ std::map\u0026lt;std::string,std::size_t\u0026gt; word_count{}; std::set\u0026lt;std::string\u0026gt; exclude{ \u0026#34;The\u0026#34;,\u0026#34;But\u0026#34;,\u0026#34;And\u0026#34;,\u0026#34;Or\u0026#34;,\u0026#34;An\u0026#34;,\u0026#34;A\u0026#34;,\u0026#34;Is\u0026#34;,\u0026#34;!\u0026#34;, \u0026#34;the\u0026#34;,\u0026#34;but\u0026#34;,\u0026#34;and\u0026#34;,\u0026#34;or\u0026#34;,\u0026#34;an\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;is\u0026#34;}; std::string word; while(std::cin\u0026gt;\u0026gt;word) if (exclude.find(word) == exclude.end()) ++word_count[word]; std::cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; for(const auto\u0026amp; w : word_count) std::cout\u0026lt;\u0026lt;w.first\u0026lt;\u0026lt;\u0026#34; occurs \u0026#34;\u0026lt;\u0026lt;w.second\u0026lt;\u0026lt;((w.second\u0026gt;1)?\u0026#34; times\\n\u0026#34;:\u0026#34; time\\n\u0026#34;); return 0; } RUN\n1 2 3 4 5 6 7 8 9 10 11 $ g++ -o main -g main.cpp $ ./main hello world ! this is bad ! this is good bad occurs 1 time good occurs 1 time hello occurs 1 time this occurs 2 times world occurs 1 time 调用find函数会返回一个迭代器，如果找到word迭代器指向该关键字，否则返回一个尾后迭代器。\n11.2 关联容器概述 常规的容器操作 关联容器能够支持，但是，对于顺序容器位置相关的操作（如：push_front、push_back）、插入操作等不支持。\n关联容器的迭代器都是双向的。\n定义关联容器 每个关联容器都定义了一个默认构造函数，它创建一个指定类型的空容器。\n初始化关联容器必须能够将初始化器转换为容器中元素的类型。特别的：初始化map,必须提供关键字类型和值类型，且将每个关键字——值对包围在花括号中。\n示例：\n1 2 3 4 5 6 7 8 9 // 空容器 std::map\u0026lt;std::string,std::size_t\u0026gt; word_count; // 列表初始化 std::set\u0026lt;std::string\u0026gt; filter = { \u0026#34;The\u0026#34;,\u0026#34;But\u0026#34;,\u0026#34;And\u0026#34;,\u0026#34;Or\u0026#34;,\u0026#34;An\u0026#34;,\u0026#34;A\u0026#34;,\u0026#34;Is\u0026#34;,\u0026#34;!\u0026#34;, \u0026#34;the\u0026#34;,\u0026#34;but\u0026#34;,\u0026#34;and\u0026#34;,\u0026#34;or\u0026#34;,\u0026#34;an\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;is\u0026#34;}; // map初始化 std::map\u0026lt;std::string,std::string\u0026gt; authors = { {\u0026#34;Joyce\u0026#34;,\u0026#34;James\u0026#34;}, {\u0026#34;Austen\u0026#34;,\u0026#34;Jane\u0026#34;}, {\u0026#34;Dickens\u0026#34;,\u0026#34;Charles\u0026#34;}}; 初始化multimap或multiset 对于map和set来说，对于一个给定的关键字，只能有一个元素的关键字等于它。但是，对于multimap和multiset则没有此限制。例如：在统计单词数量时，每个单词最多拥有一个元素。但在词典中，特定单词可能含有多重释义。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;vector\u0026gt; int main(){ std::vector\u0026lt;int\u0026gt; i_vec; for(std::vector\u0026lt;int\u0026gt;::size_type i=0;i!=10;++i){ i_vec.push_back(i); i_vec.push_back(i); } std::set\u0026lt;int\u0026gt; i_set(i_vec.cbegin(),i_vec.cend()); std::multiset\u0026lt;int\u0026gt; i_mset(i_vec.cbegin(),i_vec.cend()); std::cout\u0026lt;\u0026lt;\u0026#34;vector size: \u0026#34;\u0026lt;\u0026lt;i_vec.size()\u0026lt;\u0026lt;\u0026#34; set size: \u0026#34; \u0026lt;\u0026lt;i_set.size()\u0026lt;\u0026lt;\u0026#34; multiset size: \u0026#34;\u0026lt;\u0026lt;i_mset.size()\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } RUN\n1 2 3 $ g++ -o main -g main.cpp $ ./main vector size: 20 set size: 10 multiset size: 20 在上述示例中，multiset允许重复关键字。\n关键字类型的要求 关联容器对关键字类型有一些限制。对于有序容器（这里及以下均指代关联有序容器）来说关键字类型必须定义元素比较的方法，默认情况下，标准库使用关键字类型的\u0026lt;运算符来比较两个关键字。\n有序容器的关键字类型 与算法类似，有序容器也可以通过自定义操作替代关键字的\u0026lt;运算符。但是必须遵循**严格弱序 **（strict weak ordering）。可以将严格弱序看作“小于等于”，其必须具备如下性质：\n两个关键字不能同时“小于等于”对方；如果k1“小于等于”k2,那么k2绝不能“小于等于”k1。 如果k1“小于等于”k2,且k2“小于等于”k3,那么k1必须“小于等于”k3。 如果存在两个关键字，任何一个都不“小于等于”另一个，那么我们称这两个关键字是“等价”的。如果k1“等价于”k2,且k2“等价于”k3,那么k1必须“等价于”k3。 如果两个关键字是等价的，那么容器将它们视为相等来处理。\n在实际编程中，重要的是，如果一个类型定义了“行为正常”的\u0026lt;运算符，则它可以用作关键字类型。\n如果选择自定义操作，则必须在定义关联容器类型时提供此操作的类型，自定义操作类型必须在尖括号中紧跟着元素类型。\npair类型 pair：标准库类型，定义在utility头文件中\n一个pair保存两个数据成员，类似容器。pair作为一个模板用来生成特定类型。创建一个pair,必须提供两个类型名（不要求一致），pair的数据成员将具有对应的类型。\npair的默认构造函数对数据成员进行值初始化，当然可以手动提供初始化器。 示例：\n1 2 3 std::pair\u0026lt;std::string,std::string\u0026gt; a; std::pair\u0026lt;std::string,std::size_t\u0026gt; b; std::pair\u0026lt;std::string,std::string\u0026gt; c{\u0026#34;hello\u0026#34;,\u0026#34;world\u0026#34;}; pair的数据成员为public,其成员分别命名为first和second。\n详细操作：\npair上的操作 解释 pair\u0026lt;T1,T2\u0026gt; p; p是一个pair,两个类型分别为T1和T2的成员都进行了值初始化 pair\u0026lt;T1,T2\u0026gt; p(v1,v2) p是一个成员类型为T1和T2的pair；first和second成员分别用v1和v2进行初始化 pair\u0026lt;T1,T2\u0026gt; p={v1,v2}; 等价于p(v1,v2) make_pair(v1,v2) 返回一个用v1和v2初始化的pair。pair的类型从v1和v2的类型推断出来 p.first 返回p的名为first的（公有）数据成员 p.second 返回p的名为second的（公有）数据成员 p1==p2p1!=p2 当first和second成员分别相等时，两个pair相等。相等性判断利用元素的==运算符实现 11.3 关联容器操作 关联容器额外的类型别名 解释 key_type 此容器类型的关键字类型 mapped_type 每个关键字关联的类型；只适用于map value_type 对于set,与key_type相同对于map,为pair\u0026lt;const key_type,mapped_type\u0026gt; 需要注意到：对于value_type,我们不能改变一个元素的关键字，所以这些pair的关键字部分是const的。\n1 2 3 4 5 set\u0026lt;std::string\u0026gt;::key_type v1; // string set\u0026lt;std::string\u0026gt;::value_type v2; // string map\u0026lt;std::string,int\u0026gt;::key_type v3; // string map\u0026lt;std::string,int\u0026gt;::mapped_type v4; // int map\u0026lt;std::string,int\u0026gt;::value_type v5; // pair\u0026lt;const string,int\u0026gt; 关联容器迭代器 对于解引用一个关联迭代器时，我们会得到一个类型为容器的value_type的值的引用。\n1 2 3 4 5 6 map\u0026lt;std::string,std::size_t\u0026gt; word_count; auto map_iter=word_count.begin(); // 指向pair\u0026lt;const string,size_t\u0026gt;对象的引用 std::cout\u0026lt;\u0026lt;map_iter-\u0026gt;first; // string std::cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;map_iter-\u0026gt;second; // size_t map_iter-\u0026gt;first=\u0026#34;new key\u0026#34;; // error ++map_iter-\u0026gt;second; // true 虽然set类型同时定义了iterator和const_iterator类型，但是两种类型都只允许只读访问set中的元素。一个set中的关键字也是const。\n在进行常规编历时，使用迭代器进行遍历一个map、multimap、set和multiset时，迭代器按照关键字升序遍历元素。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;map\u0026gt; int main(){ std::map\u0026lt;std::string,int\u0026gt; word_count{{\u0026#34;c\u0026#34;,1},{\u0026#34;b\u0026#34;,2},{\u0026#34;a\u0026#34;,3}}; auto map_iter=word_count.cbegin(); while(map_iter!=word_count.cend()){ std::cout\u0026lt;\u0026lt;map_iter-\u0026gt;first\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;map_iter-\u0026gt;second\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; ++map_iter; } } RUN\n1 2 3 4 5 $ g++ main.cpp $ ./a.out a 3 b 2 c 1 通常来说，不会对关联容器使用泛型算法。在实际编程中，如果我们真要对一个关联容器使用算法，要么是将它当作一个源序列，要么当作一个目的位置。例如：使用泛型copy算符拷贝一个关联容器到另一个序列，或是使用inserter将一个插入器绑定到一个关联容器，依次将关联容器当作一个目的位置来调用另一个算法。\n添加元素 关联容器中insert成员会向容器中添加一个元素或一个元素范围。insert有两个版本，「1」接受一对迭代器，「2」接受一个初始化列表。\n1 2 set_1.insert(vec.cbegin(),vec.cend()); set_2.insert({1,2,3,4}); 对于map、set及其对应的无序列表来说，对于一个给定的关键字，只有第一个带此关键字的元素才能被插入到容器中。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;map\u0026gt; int main(){ std::map\u0026lt;std::string,int\u0026gt; word_count{{\u0026#34;c\u0026#34;,1},{\u0026#34;b\u0026#34;,2},{\u0026#34;a\u0026#34;,3}}; word_count.insert({\u0026#34;c\u0026#34;,4}); auto map_iter=word_count.cbegin(); while(map_iter!=word_count.cend()){ std::cout\u0026lt;\u0026lt;map_iter-\u0026gt;first\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;map_iter-\u0026gt;second\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; ++map_iter; } } RUN\n1 2 3 4 5 $ g++ main.cpp $ ./a.out a 3 b 2 c 1 向map添加元素 向map插入元素，注意元素类型为pair。\n1 2 3 4 map_1.insert({1,2}); map_2.insert(std::make_pair(1,2)); map_3.insert(std::pair\u0026lt;int,int\u0026gt;(1,2)); map_4.insert(std::map\u0026lt;int,int\u0026gt;::value_type(1,2)); 关联容器insert操作 解释 c.insert(v) v是value_type类型的对象；args用来构造一个元素 c.emplace(args) 对于map和set,只有当元素的关键字不在c中时才插入（或构造）元素。函数返回一个pair,包含一个迭代器，指向具有指定关键字的元素，以及一个指示插入是否成功的bool值。对于multimap和multiset，总会插入（或构造）给定元素，并返回一个指向新元素的迭代器 c.insert(b,e)c.insert(il) b和e是迭代器，表示一个c::value_type类型值的范围；il是这种值的花括号列表。函数返回void对于map和set,只插入关键字不在c中的元素。对于multimap和multiset,则会插入范围中的每个元素 c.insert(p,v) c.emplace(p,args) 类似于insert(v)（或emplace(args)），但将迭代器p作为一个指示，指出从哪里开始搜索新元素应该存储的位置。返回一个迭代器，指向具有给定关键字的元素 检测insert的返回值 insert（或emplace）返回的值依赖于容器类型和参数。\n对于不包含重复关键词的容器，添加单一元素返回pair,pair的first成员为迭代器，指向具有给定关键词的元素；second成员是一个bool值，指出元素是否插入成功。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;map\u0026gt; int main(){ std::map\u0026lt;std::string,int\u0026gt; word_count{{\u0026#34;c\u0026#34;,1},{\u0026#34;b\u0026#34;,2},{\u0026#34;a\u0026#34;,3}}; auto result_1=word_count.insert({\u0026#34;c\u0026#34;,4}); auto result_2=word_count.insert({\u0026#34;d\u0026#34;,4}); auto map_iter=word_count.cbegin(); while(map_iter!=word_count.cend()){ std::cout\u0026lt;\u0026lt;map_iter-\u0026gt;first\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;map_iter-\u0026gt;second\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; ++map_iter; } std::cout\u0026lt;\u0026lt;\u0026#34;result_1 is: \u0026#34;\u0026lt;\u0026lt;(result_1.second?\u0026#34;true\u0026#34;:\u0026#34;false\u0026#34;) \u0026lt;\u0026lt;\u0026#34;,result_2 is: \u0026#34;\u0026lt;\u0026lt;(result_2.second?\u0026#34;true\u0026#34;:\u0026#34;false\u0026#34;)\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } 1 2 3 4 5 6 7 $ g++ main.cpp $ ./a.out a 3 b 2 c 1 d 4 result_1 is: false,result_2 is: true 删除元素 关联容器定义了三个版本的erase。\n前两个版本与顺序容器的操作非常类似：都是通过一个迭代器或一个迭代器对进行删除一个元素或一个元素范围，函数返回迭代器。关联容器提供了一个额外的erase操作，其接受key_type参数。此版本删除匹配给定关键词的元素，返回实际删除的元素数量。\n从关联容器删除元素 解释 c.erase(k) 从c中删除每个关键字为k的元素。返回一个size_type值，指出删除的元素的数量 c.erase(p) 从c中删除迭代器p指定的元素。p必须指向c中一个真实元素，不能等于c.end()。返回一个指向p之后元素的迭代器，若p指向c中的尾元素，则返回c.end() c.erase(b,e) 删除迭代器对b和e所表示的范围中的元素。返回e 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; int main(){ std::multimap\u0026lt;std::string,int\u0026gt; word_count{{\u0026#34;c\u0026#34;,1},{\u0026#34;b\u0026#34;,2},{\u0026#34;a\u0026#34;,3},{\u0026#34;c\u0026#34;,4}}; std::string removeal_word=\u0026#34;c\u0026#34;; auto removeal_num=word_count.erase(removeal_word); if(removeal_num) std::cout\u0026lt;\u0026lt;\u0026#34;ok: \u0026#34;\u0026lt;\u0026lt;removeal_word\u0026lt;\u0026lt;\u0026#34; removed,removeal num is \u0026#34;\u0026lt;\u0026lt;removeal_num\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; else std::cout\u0026lt;\u0026lt;\u0026#34;oops: \u0026#34;\u0026lt;\u0026lt;removeal_word\u0026lt;\u0026lt;\u0026#34;no found!\\n\u0026#34;; } RUN\n1 2 3 $ g++ main.cpp $ ./a.out ok: c removed,removeal num is 2 map的下标操作 map和unordered_map容器提供下标运算符和对应的at函数。\nmap和unordered_map的下标操作 解释 c[k] 返回关键字为k的元素；如果k不在c中，添加一个关键字为k的元素，对其进行值初始化 c.at(k) 访问关键字为k的元素，带参数检查；若k不再c中，抛出一个out_of_range异常 需要注意到的是，如果关键字不再map中会创建一个元素并插入到map中，关联值将进行值初始化。\n1 2 map\u0026lt;string,size_t\u0026gt; word_count; // 空容器 word_count[\u0026#34;a\u0026#34;]=1; // 创建元素，关键字为a,值为1 详细流程：\n在word_count中搜索关键字为a的元素，未找到。 将一个新的关键字-值对插入到word_count中。关键字是一个const string，保存a。值进行值初始化，上述例子中为0 提取出新插入的元素，并将1赋予它。 注意：由于下标运算符可能插入一个新元素，所以仅可以对非const的map使用下标操作。\n通常情况，解引用一个迭代器所返回的类型与下标运算符返回的类型一样。但对map不然：当对一个map进行下标操作时，会获得一个mapped_type对象；但当解引用一个map迭代器时，会得到一个value_type对象。\n访问元素 关联容器提供多钟查找一个指定元素的方法。\n在一个关联容器中查找元素的操作 解释 c.find(k) 返回一个迭代器，指向第一个关键字为k的元素，若k不再容器中，则返回为后迭代器 c.count(k) 返回关键字等于k的元素的数量。对于不允许重复关键字的容器，返回值永远是0或1 c.lower_bound(k) 返回一个迭代器，指向第一个关键字不小于k的元素 c.upper_bound(k) 返回一个迭代器，指向第一个关键字大于k的元素 c.equal_range(k) 返回一个迭代器pair,表示关键字等于k的元素的范围。若k不存在，pair的两个成员均等于c.end()（准确来说：指向关键字可以插入的位置） 注意：lower_bound和upper_bound不适用于无序容器。下标和at操作只适用于非const的map和unordered_map。\n这么多查找方式，应该根据解决问题思考。如果我们关心只不过是一个特定元素是否已在容器中，可能find是最佳选择。对于count和find,如果不需要计数，最好使用find。\n对map使用find代替下标操作 由于下标操作的严重副作用，除非使用下标符合你的预期，最好使用find查找map中的元素。\n在multimap或multiset中查找元素 如果一个multimap或multiset中有多个元素具有给定关键字，而这些元素在容器中会相邻存储。\nlower_bound返回的迭代器指向第一个具有给定关键词的元素，upper_bound返回的迭代器指向最后一个匹配给定关键词的元素。\n如果关键字不再multimap中，则lower_bound和upper_bound会返回相等的迭代器——指向一个不影响排序的关键字插入位置。这两个操作返回的迭代器可能是容器的尾后迭代器。如果关键字不存在且大于容器中任何关键字，则lower_bound返回尾后迭代器；如果查找的元素最大，upper_bound返回的也是尾后迭代器。\n注意：lower_bound和upper_bound都不会报告关键字是否存在。如果不存在,lower_bound将会指向第一个关键字大于给定关键字的元素，有可能是尾后迭代器；upper_bound指向最后一个匹配给定关键字的元素之后的元素，有可能是尾后迭代器。\n如果lower_bound和upper_bound返回相同的迭代器，则给定关键字不存在容器中。\n一个单词转换的map 查看：test\n11.4 无序容器 C++11中定义了4个无序关联容器（unordered associative container)。这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数（hash function）和关键字类型的==运算符。在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。在某些应用中，维护元素的序代价非常高昂，此时无序容器也很有用。\n虽然理论上哈希技术能获得更好的平均性能，但在实际中想要达到很好的效果还需要进行一些性能测试和调优工作。因此，使用无序容器通常更为简单（通常也会有更好的性能）。\n如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希技术解决，就可以使用无序容器。\n无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。\n对于相同的参数，哈希函数必须总是产生相同的结果。理想情况下，哈希函数还能将每个特定的值映射到唯一的桶。但是，将不同关键字的元素映射到相同的桶也是允许的。当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在桶中搜索通常都是很快的操作。但是，如果一个桶中保存了很多元素，那么查找一个特定元素就需要大量比较操作。\n无序容器管理操作——桶接口 解释 c.bucket_count() 正在使用的桶的数目 c.max_bucket_count() 容器能容纳的最多的桶的数量 c.bucket_size() 第n个桶中有多少个元素 c.bucket(k) 关键字为k的元素在哪个桶中 无序容器管理操作——桶迭代 解释 local_iterator 可以用来访问桶中元素的迭代器类型 const_local_iterator 桶迭代器的const版本 c.begin(n),c.end(n) 桶n的首元素迭代器和尾后迭代器 c.cbegin(n),c.cend(n) 与前两个函数类似，但返回const_local_iterator 无序容器管理操作——哈希策略 解释 c.local_factor() 每个桶的平均元素数量，返回float值 c.max_local_factor() c试图维护的平均桶大小，返回float值。c会在需要时添加新的桶，以使得local_factor\u0026lt;=max_local_factor c.rehash(n) 重组存储，使得bucket_count\u0026gt;=n且bucket_count\u0026gt;size/max_load_factor c.reserve(n) 重组存储，使得c可以保存n个元素且不必rehash 无序容器对关键字类型的要求 默认情况下，无序容器使用关键字类型的==运算符来比较元素，它们还使用一个hash\u0026lt;key_type\u0026gt;类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）、string、智能指针类型提供了hash模板。所以对上述类型可以定义对应的无序容器。\n对于自定义的类类型必须定义自己的hash模板才能使用无序容器。\n总结 关联容器支持通过关键字进行高效查找和提取元素。对于关键字的使用将关联容器和顺序容器区分开来。\n标准库定义了8个关联容器，每个容器\n是一个map或者是一个set。map保存关键字-值对；set仅保存关键字 要求关键字唯一或不要求。 保持关键字有序或不保证有序。 有序容器使用比较函数来比较关键字，从而将元素按顺序存储。默认情况下，比较操作采用关键字类型的\u0026lt;运算符；无序容器使用关键字类型的==运算符和一个hash\u0026lt;key_type\u0026gt;类型的对象来组织元素。\n有序容器的迭代器通过关键字有序访问容器中的元素。无论在有序容器还是在无序容器中，具有相同关键字的元素都是相邻存储的。\n","date":"2025-04-06T00:00:00Z","image":"https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg","permalink":"https://Free-Aaron-Li.github.io/p/c-%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/","title":"C++ 基础： 第十一章 关联容器"},{"content":"第十章 泛型算法 前言 在前面我们学习容器的时候，是否发现标准库下的对容器的操作并不是太多（或许，初学时已经觉得好多了😅），其实C++将大量的功能操作集成在泛型算法中。泛型（generic），即通用，意为其独立于任何特定的容器，操作于不同类型的容器和不同类型的元素。 回想一下，在学习顺序容器的过程中，我们学习了哪些容器操作？ 添加、删除容器元素；容器是否为空；获取容器元素的迭代器；访问首尾元素；\n以上的操作仅仅只是对容器的基础操作，我们并不满足。有时候我们希望能够对容器进行排序、搜索、替换等等操作。如果对每个特定的容器都设置对应的操作算法，这显然会使得对容器的操作变得复杂、杂乱。所以，这就是为什么容器仅提供少量的操作，因为标准库将大量的操作进行集合，形成泛型算法。\n10.1 概述 大多数的算法都定义在algorithm中，其中在numeric头文件中定义了一组数值泛型算法。\n算法是如何独立于特定的容器的呢？回想一下，每个容器都存在迭代器，通过迭代器我们可以自由访问、操作容器。所以，实际上算法并不会直接操作容器，而是通过迭代器间接操作容器。\n例如，find算法（用于查找某项值），其算法便是通过迭代器指定一个元素范围，通过遍历范围进行查找。\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; int main(){ std::vector\u0026lt;int\u0026gt; vector{1,2,3,4,5,6,7}; int value=2; auto result=std::find(vector.cbegin(),vector.cend(),value); std::cout \u0026lt;\u0026lt; \u0026#34;The result \u0026#34;\u0026lt;\u0026lt; value \u0026lt;\u0026lt;\u0026#34; \u0026#34; \u0026lt;\u0026lt; (result==vector.cend()? \u0026#34;does not exist in this vector\u0026#34;:\u0026#34;does exist in this vector\u0026#34;) \u0026lt;\u0026lt; std::endl; } 从上例中，我们可以看出，find算法是直接操作迭代器，所以除了可以使用find算法查找vector中元素，我们还可以查找string中的元素，甚至是内置数组中元素。\n1 2 3 4 5 6 7 8 9 // find character std::string str(\u0026#34;hi good morning!\u0026#34;); char value(\u0026#39;h\u0026#39;); auto result=std::find(str.cbegin(),str.cend(),value); // find number int assemble[]={1,2,3,4,5,6,7}; int value=3; int *result=std::find(std::begin(assemble),std::end(assemble),value); find算法的工作原理 访问序列中的首元素 比较此元素与目标元素 与目标元素匹配，返回标识此元素的值 若没有匹配，find查找下一个元素，重复步骤2和3 若到达序列尾，find停止 若到达序列尾，依旧没有找到目标元素，返回指出元素未找到的值。且此值和步骤3中返回值具有相容类型 从上面步骤我们可以看出，find算法在所有步骤上都不依赖容器中所保存的元素类型。因此，只要通过迭代器访问元素，find算法就完全不依赖容器类型，甚至无需理会其是否是不是容器。\n但是，虽然通过迭代器算法不依赖于容器，但是算法依赖于元素类型的操作。这听起来挺奇怪的，为什么呢？正像上面例子一样，result==vector.cend()，find算法在实际运行中，使用==运算符对元素进行判断。类似于find，大多数算法都会使用到一个（或者多个）元素类型的操作，所以算法依赖于元素类型的操作，但并不依赖于容器。\n算法永远不会执行容器操作 泛型算法本身不会执行容器的操作，它们指挥运行于迭代器之上，执行迭代器的操作。\n正因为如此，算法永远不会改变底层容器的大小，算法可以删除、添加、移动容器中的元素，但其都是基于迭代器实现，算法本身并不会做出这样的操作。\n10.2 初识泛型算法 在标准库中存在100余种算法，想要通过死记的方式显然是困难的。但是这些算法都具有一致的结构（也就是统一原则），通过理解此结构无疑是事半功倍。\n大多数的标准库算法都是对一个范围的元素（即“输入范围”）进行操作。如前面所学的find算法，接受输入范围的算法总是通过前两个参数（一般是两个表示指向范围边界元素的迭代器）表示此范围。\n大多数标准库算法对输入范围的遍历类似（一般结构），只不过对范围内的元素操作不同。\n只读算法 如其名，某些算法仅读取输入范围中的元素，并不会改变元素，则成为只读算法。如我们在前面所学到的find和count算法。下面我们继续学习两个只读算法：用于求和的accumulate算法和用于比较两序列的equal算法。\naccumulate算法 该算法定义在numeric头文件中。其接受三个参数，前两个参数确定输入范围，第三个参数作为和的初值。第三个参数类型决定函数该使用哪种加法运算符以及返回值类型。\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;numeric\u0026gt; int main(){ std::vector\u0026lt;int\u0026gt; assemble{1,2,3,4,5,6,7}; int sum=std::accumulate(assemble.cbegin(),assemble.cend(),0); std::cout \u0026lt;\u0026lt; \u0026#34;the sum for assemble is :\u0026#34;\u0026lt;\u0026lt;sum \u0026lt;\u0026lt; std::endl; } accumulate算法中第三个参数作为求和起点，正如上面所描述的代码，其蕴含一个编程假设：该第三参数类型必须能够与输入范围内元素相加，也就是必须能与之匹配（或者转换）。如：输入范围内元素类型为int，那么第三参数类型可以为double、long long等等。\n另外一个例子：\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;numeric\u0026gt; int main(){ std::vector\u0026lt;std::string\u0026gt; assemble{\u0026#34;hello \u0026#34;,\u0026#34;world! \u0026#34;,\u0026#34;welcome \u0026#34;,\u0026#34;to \u0026#34;,\u0026#34;new \u0026#34;,\u0026#34;home!\u0026#34;}; std::string sum=std::accumulate(assemble.cbegin(),assemble.cend(),std::string(\u0026#34;\u0026#34;)); std::cout \u0026lt;\u0026lt; \u0026#34;the sum for assemble is :\u0026#34;\u0026lt;\u0026lt;sum \u0026lt;\u0026lt; std::endl; } 第三参数定义为string(\u0026quot;\u0026quot;)，那么其实就告诉accumulate算法我的初值是string类型的空串，我要将vector中string类型元素加起来，并且返回为string。\n那么为什么第三参数不直接写成\u0026quot;\u0026quot;，首先在学习string时我们知道\u0026quot;\u0026quot;是一个字符串字面值，其不能作为第一参数与其他string类型的字符串相加。因为字符串字面值其类型为const char*，该类型并没有“+”运算符，怎么能够相加呢？（但是我们可以这样string+const char*，这是为C做出的妥协）\nequal算法 equal，译为平等。该算法作用为比较两个序列是否相等。同样该算法具有三个参数，前两个参数用于确定第一个序列的输入范围，第三个参数则用于确定第二个序列的首元素。\n这里同样存在一个隐含编程假设：那就是假设第二序列的长度至少和第一序列长度一样长，或者更长，因为equal算法仅确定第二序列的首元素，并没有确定其尾元素。\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; int main(){ std::vector\u0026lt;int\u0026gt; vector_1{1,2,3}; std::vector\u0026lt;int\u0026gt; vector_2{1,2,3}; bool result=std::equal(vector_1.cbegin(),vector_1.cend(),vector_2.cbegin()); std::cout \u0026lt;\u0026lt; (result==true?\u0026#34;there two vector is equal\u0026#34;:\u0026#34;there two vector isn\u0026#39;t equal\u0026#34;) \u0026lt;\u0026lt; std::endl; } 迭代器参数\n算法仅要求能够比较两个序列中的元素，并不会对序列属于那种类型做出要求，同时也不会严格要求两比较序列中元素相同。 在操作两个序列的算法中，如果某些算法仅接受三个迭代器，那么默认前两个参数确定第一序列的元素范围，第三个参数确定第二个序列中的首元素。如果接受四个迭代器，则前两个参数确定第一个序列元素范围，后两个参数确定第二个序列的元素范围。 仅接受单一迭代器表示第二个序列的算法都假定第二个序列至少和第一个序列一样长，算法并不做出保证（这是程序员的责任）。 一个很有趣的现象是在完成10.5练习题时，会发现equal算法其实对“==”运算符做了重载，所以无论是对string还是C风格字符串进行比较都是可行的。\n在早些版本的标准库中，equal算法并不能对C风格字符串中元素进行比较，其比较的是指针位置。\n写容器元素的算法 一些算法会将新值赋予序列中的元素（注意：不是改变容器的大小，所以赋予新值数目必定会比原容器中元素数目小，或者相等）。\n这些算法本质上仅仅改变容器中已存在的元素，不会越界所以并不危险。\n例如，fill（填满）算法就是将第三参数替换输入范围内所有元素。\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;vector\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; int main(){ std::vector\u0026lt;int\u0026gt; vector{1,2,3,4,5,6,7}; std::fill(vector.begin(),vector.end(),0); for(auto const \u0026amp;c:vector) std::cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } 算法不检查写操作 如标题所言，算法在执行过程中都会假定参数是正确的，例如：fill_n算法（其接受一个目的位置，并向该序列中赋予指定数目的新值）。\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;vector\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; int main(){ std::vector\u0026lt;int\u0026gt; vector(10); // 向vector序列中赋予10个1 std::fill_n(vector.begin(),10,1); for(auto const \u0026amp;c:vector) std::cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } 在上面的代码中，我们写明了vector容器存在10个元素的空间，但是假如我们将vector设置为空呢？：\n1 \u0026#39;./main\u0026#39; terminated by signal SIGSEGV (Address boundary error) g++给出如上的提示，告诉我们越界了，说明fill_n算法已经执行（同样说明算法并不会检查写操作）。\n介绍back_inserter 在前面我们学习的迭代器都是为了指向一个确切元素，但是显然在某些情况下并不能满足实际需求，这个时候我们就需要使用到插入迭代器（insert_iterator）。插入迭代器的目的就是向容器中添加元素。\n使用插入迭代器，我们需要通过back_inserter函数，其定义在iterator文件中。\nback_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当向此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中。\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; int main(){ std::vector\u0026lt;int\u0026gt; vector; auto insert_iterator=std::back_inserter(vector); insert_iterator=12; for(auto const \u0026amp;c:vector) std::cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } 回到我们所讨论的fill_n算法，由于无法通过vec.begin()作为目的位置为空容器进行写操作，那么这个时候我们就需要通过back_inserter函数来创建一个迭代器，作为算法的目的位置使用。\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; int main(){ std::vector\u0026lt;int\u0026gt; vector; std::fill_n(back_inserter(vector),10,1); for(auto const \u0026amp;c:vector) std::cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } 每次迭代，back_inserter返回的插入迭代器都会调用push_back成员在容器末尾添加指定函数。\n拷贝算法 拷贝（copy）算法作用便是向另一个指定目的位置的迭代器所指向输出序列中的元素中写入数据。\n该算法接受三个迭代器，所以隐含被拷贝对象的长度至少比输入序列的长度长，或者相等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;list\u0026gt; int main(){ std::vector\u0026lt;int\u0026gt; vector{1,2,3,4,5}; std::list\u0026lt;int\u0026gt; list{0,9,8,7,6,5}; auto post_tail=copy(vector.cbegin(),vector.cend(),list.begin()); for(auto const \u0026amp;c:list) std::cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } copy算法返回其目的位置迭代器的值（当然，这个值是经过递增后的），即list的尾后迭代器。\n在有些算法中，其“拷贝”版本，并不会将其放在输入序列的末尾，而是创建一个新序列保存。\n如，replace算法，其本身是替换序列中元素。\n1 replace(vector.begin(),vector.end(),0,1); 将vector容器中所有值为0的元素替换为1\n如果我们希望原序列不变，那么我们可以使用replace_copy算法。\n1 replace_copy(vector.cbegin(),vector.cend(),back_inserter(list),0,1) 通过back_inserter创建一个新序列，其原序列vector不变，拷贝一份vector中元素于list中，且其中值为0的元素被替换为1。\n重排容器元素的算法 sort算法，其通过利用元素类型的\u0026lt;运算符实现排序。\nunique算法，覆盖重复元素。\n10.3 定制操作 在前面我们学到的算法大多使用到了元素类型的\u0026lt;或者=运算符进行元素比较。但是有些时候，我们希望自定义运算符，例如：当我们对未定义\u0026lt;运算符的元素类型进行比较。\n向算法传递函数 谓词(predicate)\n谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。\n标准库算法所使用的谓词分为两类：一元谓词(unary predicate) 和二元谓词(binary predicate)。\n一元谓词：意味着它们是接受单一参数 二元谓词：意味着它们有两个参数 接受谓词参数的算法对输入序列中的元素调用谓词，因此，元素类型必须能够转换为谓词的参数类型。\nlambda表达式 使用场景\n对于那种只在一两个地方使用的简单操作，lambda表达式是最有用的。\n无论是一元还是二元谓词，我们传递必须严格执行接受参数的数目，显然，在某些情况下这受到了限制。\n例如，我们有一种需求：求大于等于一个给定的单词，打印符合要求的单词。\n从要求，我们可以使用标准库中的find_if算法查找第一个具有特定大小的元素，接下来只需要设定好要求即可。但是如果我们使用谓词作为find_if算法的第三个参数，显然无法满足需求（因为需要对单词进行判断）。\n这个时候，我们就需要使用lambda表达式！\n在前面我们学过两种可调用对象：函数与函数指针，除此还有：重载了函数调用运算符的类与lambda表达式。\n一个lambda表达式表示一个可调用的代码单元，可理解为内联函数。\n一般的lambda表达式具有一个返回类型、一个参数列表和一个函数体\n一般结构：\n[capture list](parameter list)-\u0026gt; return type{function body}\n示例：\n1 2 3 int a = 10, b = 20; auto c = [a, b](const int \u0026amp;c) -\u0026gt; int { return a + b + c; }; std::cout \u0026lt;\u0026lt; \u0026#34;a + b + c = \u0026#34; \u0026lt;\u0026lt; c(30) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 需要注意的是：\nlambda必须使用尾置返回来指定返回类型 lambda可以忽略参数列表与返回类型，但是必须包含捕获列表和函数体 如果忽略返回类型，那么lambda根据函数体中代码推断返回类型(默认为void) lambda不能存在默认参数 捕获列表只用于局部非static变量，lambda可以直接使用局部static变量和在它所在函数之外声明的名字 lambda捕获和返回 当定义一个lambda时，编译器会生成一个与lambda对应的新的类类型。\n所以，当lambda表达式捕获变量时，由此生成的类类型中也会包含对应于捕获变量的数据成员，且lambda的数据成员会随着lambda对象的创建时被初始化。\n类似参数传递，变量的捕获也可以是值或者引用。\n值捕获 采用值捕获的前提是变量可以拷贝\n有意思的是，与参数值传递不同的是，被捕获的变量的值是在lambda创建时拷贝，而不是在调用时拷贝。\n1 2 3 4 5 6 void function_1{ size_t value=42; auto f=[value]{return value;}; // 将value拷贝到f可调用对象中 value=0; auto j=f(); // j仍然为42，f保存了我们在创建它时value的拷贝 } 引用捕获 当某些情况下，我们不能够拷贝捕获变量（如IO对象），那么我们就必须使用引用捕获。\n与参数引用类似，\n1 2 3 4 5 6 void function_2{ size_t value=42; auto f=[\u0026amp;value]{return value;}; // 将value拷贝到f可调用对象中 value=0; auto j=f(); // j仍然为0，f保存了value的引用，而非拷贝 }; 引用捕获和返回引用都有着相同的问题和限制。\n如果采用引用方式捕获一个变量，就必须确保被引用对象在lambda执行的时候是存在的。\n建议\n尽量保持lambda的变量捕获简单化\n一般来说，我们应该尽量减少捕获的数据量来避免潜在的捕获导致的问题。如果可能的话，应该避免捕获指针或引用。\n隐式捕获 编译器可以根据lambda体中的代码推断我们要使用哪些变量😊。为了指示编译器推断捕获列表，应该在捕获列表中写入\u0026amp;或者=，以表示编译器应该采用哪种捕获方式\n例如：\n1 2 3 // 隐式捕获 int sz=10; auto a=[=](const string\u0026amp;s){return s.size()\u0026gt;=sz}; 我们还不满足，希望对一部分变来能够采用值捕获，对另外一部分采用引用捕获，可以混合显式与隐式捕获。\n那么我们需要：\n捕获列表中的第一个元素必须是\u0026amp;或者=，以此指定默认捕获方式为引用还是值。 显示捕获的变量必须使用与隐式捕获不同的方式。 例如：\n1 2 3 4 5 int a=10,b=20; /* a为隐式捕获，引用捕获方式；b为显式捕获，值捕获方式 */ auto c=[\u0026amp;,b](const string\u0026amp;s){return s.size\u0026gt;=a+b;}; /* a为显式捕获，引用捕获方式；b为隐式捕获，值捕获方式 */ auto c=[=,\u0026amp;a](const string\u0026amp;s){return s.size\u0026gt;=a+b;}; 综上所述，lambda捕获有一下方式：\nlambda捕获列表 解释 [] 空捕获列表。lambda不能使用所在函数中的变量。一个lambda只有捕获变量后才能使用它们 [names] names是一个逗号分隔的名字列表，这些名字都是lambda所在函数的局部变量。默认情况下，捕获列表中的变量都被拷贝。名字前如果使用了\u0026amp;，则采用引用捕获方式 \u0026amp; 隐式捕获列表，采用引用捕获方式。lambda体中所使用的来自所在函数的实体都采用引用方式使用 [=] 隐式捕获列表，采用值捕获方式。lambda体将拷贝所使用的来所在函数的实体的值 [\u0026amp;,identifier_list] identifier_list是一个逗号分隔的列表，包含0个或多个来自所在函数的变量。这些变量采用值捕获的方式，而任何隐式捕获的变量都采用引用方式捕获。identifier_list中的名字前面不能使用\u0026amp; [=,identifier_list] identifier_list中的变量都采用引用方式捕获，而任何隐式捕获的变量都采用值方式捕获。identifier_list中的名字不能包括this,且这些名字之前必须使用\u0026amp; 可变lambda 默认情况下，对于一个被值捕获的变量，是不会被修改的。但是如果希望修改，则需要在参数列表尾加上关键字mutable。\n例如：\n1 2 3 4 5 6 size_t v1=42; auto f=[v1]()mutable{return ++v1;}; v1=0; auto j=f(); std::cout \u0026lt;\u0026lt; j \u0026lt;\u0026lt; std::endl; return 0; 对于引用捕获的变量是否可以修改则依赖于此引用指向的是一个const类型还是非const类型。\n例如：\n1 2 3 4 size_t v1=42; auto f=[\u0026amp;v1]{return ++v1;}; v1=0; auto j=f(); // j为1 指定lambda返回类型 默认情况下，如果一个lambda体包含return之外的任何语句，则编译器假定此lambda返回void。与其他返回void的函数类似，被推断返回void的lambda不能返回值。\n如果lambda体含有多行表达式，则必须使用尾置返回类型确定返回类型。\n例如：\n1 2 3 4 5 6 /* 将v1中每个负数替换为其绝对值 */ // transform算法将一个序列中元素进行替换。 transform(v1.begin(),v1.end(),v1.begin, [](int i){return i\u0026lt;0?-i:i;}); // true transform(v1.begin(),v1.end(),v1.begin, [](int i){if (i\u0026lt;0) return -i; else return i;); // false 在第二个transform算法中，由于lambda表达式返回为void，但是其本应该返回int值。所以编译器编译错误。\n修改为：\n1 2 transform(v1.begin(),v1.end(),v1.begin, [](int i) -\u0026gt; int {if (i\u0026lt;0) return -i; else return i;); 参数绑定 为了解决某个函数中调用对象（如函数）必须接受单一参数问题，标准库定义bind函数（定义在functional头文件中）来解决该问题。\n可以将bind看作一个通用的函数适配器，它接受一个可调用对象，生成一个新可调用对象来“适应”原对象的参数列表。\n一般形式：\n1 auto newCallable=bind(callable,arg_list); arg_list表示一个含有逗号隔离的参数列表，对应给定的callable的参数。在arg_list中可能包含形如“_n”，其中n是一个整数。这些参数称为“占位符”，用于表示newCallable的参数，其占据传递给newCallable的参数的“位置”。\n例如：\n1 2 // check6是一个可调用对象，接受一个string类型的参数 auto check6=bind(check_size,_1,6); _1出现在arg_list的第一个位置，表示check6的此参数对应check_size的第一个参数。加入该参数是一个const string\u0026amp;。那么，调用check6时必须传递给它一个string类型的参数。\n完整代码：\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include \u0026lt;functional\u0026gt; bool check_size(const std::string\u0026amp; s,size_t size){ return s.size()\u0026gt;size; } int main () { std::string str(\u0026#34;hello world!\u0026#34;); auto check6=std::bind(check_size,std::placeholders::_1,6); std::cout \u0026lt;\u0026lt; \u0026#34;The size of str is greater than 6 ? \u0026#34;\u0026lt;\u0026lt;(check6(str)?\u0026#34;yes\u0026#34;:\u0026#34;no\u0026#34;) \u0026lt;\u0026lt; std::endl; } 在完整代码中，我们注意到在“_1”前增加了命名空间“placeholders”。这个命名空间本身定义在std命名空间中。名字_n都定义在上述的命名空间中。\n在实际开发过程中，每次都书写声明占位符很麻烦，这个时候我们可以运用到using声明：using namespace namespace_name;\nbind除了可以修正参数外，还可以对可调用对象中的参数进行排序。\n1 2 3 4 // 存在g可调用对象，其存在5个参数 auto g=bind(f,a,b,_2,c,_1); // 调用g，实际上映射到bind上为：bind(f,a,b,Y,c,X); g(X,Y); 实例：\n1 2 3 4 // 按照单词长度升序 sort(words.begin(),words.end(),isShorter); // 按照单词长度降序 sort(words.begin(),words.end(),bind(isShorter,_2,_1)); 如果我们希望绑定的参数以引用方式传递，或者希望被绑定的参数为const，那么需要用到标准库中的ref和cref函数。（两函数均定义在functional头文件中）\nref函数：返回一个对象，包含给定的引用，此对象是可以拷贝的 cref函数：生成一个保存const引用的类 实例：\n1 2 3 4 5 ostream \u0026amp;print(ostream \u0026amp;os,const string \u0026amp;s,char c){ return os\u0026lt;\u0026lt;s\u0026lt;\u0026lt;c; } for_each(words.begin(),words.end(),bind(print,ref(os),_1,\u0026#39; \u0026#39;)); 10.4 再探迭代器 插入迭代器 绑定到一个容器上，向容器插入元素\n流迭代器 绑定到输入输出流上，可用来遍历所有关联的IO流\n反向迭代器 迭代器向后移动，除了forward_list之外的容器均有反向迭代器\n移动迭代器 专用迭代器，不是拷贝元素而是移动元素\n插入迭代器 插入器（插入迭代器）是一种迭代器适配器，其接受一个容器，生成一个迭代器，实现向给定容器添加元素。\n通过插入迭代器进行赋值时，迭代器调用容器操作向给定容器的指定位置插入元素。\n插入迭代器操作 解释 it=t 在it指定的当前位置插入值t。假设c是it绑定的容器，依赖于插入迭代器的不同种类，才赋值会分别调用c.push_back(t)、c.push_front(t)或c.insert(t,p)，其中p为传递给inserter的迭代器位置 *it,++it,it++ 不会对it做任何事情，均返回it 插入器有三种：\nback_inserter 创建一个使用push_back的迭代器 front_inserter 创建一个使用push_front的迭代器 元素总是插入到容器第一个元素之前 inserter 创建一个使用insert的迭代器。函数接受第二参数，其参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; int main(){ std::list\u0026lt;int\u0026gt; list_1={1,2,3,4}; std::list\u0026lt;int\u0026gt; list_2,list_3; std::copy(list_1.cbegin(),list_1.cend(),std::front_inserter(list_2)); std::copy(list_1.cbegin(),list_1.cend(),std::inserter(list_3,list_3.begin())); // 4 3 2 1 for(auto const\u0026amp; var : list_2) { std::cout \u0026lt;\u0026lt; var\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; // 1 2 3 4 for(auto const\u0026amp; var : list_3) { std::cout \u0026lt;\u0026lt; var \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } iostream迭代器 iostream迭代器将流当作一个特定类型的元素序列来处理。\nistream_iterator 读取输入流\nostream_iterator 向一个输出流写数据\nistream_iterator操作 创建一个流迭代器时，必须指定迭代器将要读写的对象类型。同时由于istream_iterator使用\u0026raquo;来读取流，所以，istream_iterator所读取的类型必须定义了输入运算符。\n示例：\n1、\n1 2 3 4 5 6 7 // 绑定到流上 istream_iterator\u0026lt;int\u0026gt; int_it(std::cin); // 默认初始化，创建可以当作尾后值使用的迭代器 istream_iterator\u0026lt;int\u0026gt; int_eof; // 从“abc”中读取字符串 ifstream in(\u0026#34;abc\u0026#34;); istream_iterator\u0026lt;string\u0026gt; str_it(in); 2、\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // main.cpp #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iterator\u0026gt; int main(){ std::vector\u0026lt;int\u0026gt; vec; std::istream_iterator\u0026lt;int\u0026gt; in_iter(std::cin), eof; while (in_iter != eof) { vec.push_back(*in_iter++); } // 可以优化为： // vector\u0026lt;int\u0026gt; vec(in_iter,eof); for (const auto\u0026amp; var : vec) std::cout \u0026lt;\u0026lt; var \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } 程序执行：\n1 2 3 4 $ g++ -o main -g main.cpp $ ./main 1 2 3 1 2 3 ⏎ 该程序从cin流中读取int值（注意：无需再次添加cin表达式，初始化istream_iterator已经明确表面执行cin程序）。\n由于eof为空istream_iterator，所以可以当作尾后迭代器使用。\nistream_iterator操作 解释 istream_iterator in(is); 从输入流is中读取类型为T的迭代器，名为in（通常is为std::cin） istream_iterator end; 读取类型为T的值的istream_iterator迭代器，通常表示尾后迭代器 in1==in2in1!=in2 in1和in2必须读取相同类型的值。如果二者均是尾后迭代器，或者绑定到相同的输入，则二者相等，否则不等 *in 返回从流中读取的值 in-\u0026gt;mem 与(*in).mem含义一致 ++in,in++ 使用元素类型所定义的\u0026raquo;运算符从输入流中读取下一个值 使用算法操纵符流迭代器 泛型算法依靠迭代器操纵数据从而实现。\n如：accumulate算法计算和：\n1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;iterator\u0026gt; int main() { std::istream_iterator\u0026lt;int\u0026gt; in(std::cin),eof; std::cout \u0026lt;\u0026lt; std::accumulate(in,eof,0) \u0026lt;\u0026lt; std::endl; } RUN\n1 2 3 $ ./main 1 2 3 4 5 6 7 28 istream_iterator允许使用懒惰求值 当流迭代器绑定到某个流上，标准库并不保证迭代器立即从流中读取数据。其所保证当第一次解引用迭代器时，从流中读取数据已完成。\n在常规情况下并无太大影响，但是当创建一个istream_iterator，没用就销毁或者从两个不同对象同步读取同一个流，何时读取就可能很重要。\nostream_iterator操纵 对输出流绑定的ostream_iterator允许第二参数，且参数为字符串（C风格字符串）。用意为：在输出每个元素后都会打印此字符串。\n由于ostream_iterator为输出流迭代器，所以「1」必须绑定到一个指定流、「2」不允许为空或者表示尾后位置\nostream_iterator操作 解释 ostream_iterator out(os); out将类型为T的值写到输出流os中 ostream_iterator out(os,d); out将类型为T的值写到输出流os中，每个值后面都输出一个d（C风格） out=val 用\u0026laquo;运算符将val写到out所绑定的ostream中。val的类型必须与out可写的类型兼容 *out,++out,out++ 这些运算符允许存在，但无法对out做任何操作，每个运算符都返回out 实例：\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; int main() { std::string str{\u0026#34;hello\u0026#34;}; std::ostream_iterator\u0026lt;char\u0026gt; out(std::cout,\u0026#34; \u0026#34;); for(auto var : str) { *out++=var; } std::cout; } RUN\n1 2 3 $ g++ -o main -g main.cpp $ ./main h e l l o ⏎ 虽然解引用与自增运算符对ostream_iterator并无作用，*out++=var与out=var并不区别。但是，在第一种写法更符合迭代器主流写法，与其他迭代器保持一致。方便阅读与修改。\n使用流迭代器处理类类型 我们可以为任何定义了输入运算符（\u0026raquo;）的类型创建istream_iterator对象，同样，也可以为任何任何定义输出运算符（\u0026laquo;)的类型创建ostream_iterator对象。\n反向迭代器 除了forward_list之外，其他容器均支持反向迭代器。\n示例：\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;vector\u0026gt; int main(){ std::vector\u0026lt;int\u0026gt; data{1,2,3,4,5,6,7,8}; for(auto r_iter=data.crbegin();r_iter!=data.crend();++r_iter){ std::cout \u0026lt;\u0026lt; *r_iter \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } RUN\n1 2 3 $ g++ -o main -g main.cpp $ ./main 8 7 6 5 4 3 2 1 ⏎ 如果希望将反向迭代器转为普通迭代器，可以使用base成员函数。\n图示：\n从上图中可以看出，为了实现左闭合区间，rcomma和rcomma.base()为相邻位置，而非相同位置。这就引出一个特性：由于反向迭代器目的是表示元素范围（这些范围是不对称的），那么当我们从普通迭代器与反向迭代器相互转换时，二者迭代器所指向的并不是同一个元素。\n10.5 泛型算法结构 任何算法的最基本的特性是它要求其迭代器提供哪些操作。\n算法所要求的迭代器分为5个迭代器类别（iterator category）:\n迭代器类别 解释 输入迭代器 只读，不写；单遍扫描，只能递增 输出迭代器 只写，不读；单遍扫描，只能递增 前向迭代器 可读写；多变扫描，只能递增 双向迭代器 可读写；多遍扫描，可递增递减 随机访问迭代器 可读写，多遍扫描，支持全部迭代器运算 每个迭代器都会对它的每个迭代器参数指名须提供哪类迭代器。\n迭代器是按它们所提供的操作里分类的，而这种分类形成了一种层次。除了输出迭代器之外，一个高层类别的迭代器支持底层类别迭代器的所有操作。\n5类迭代器 输入迭代器（input iterator）：可以读取序列中的元素。\n支持：\n用于比较两个迭代器的相等和不相等运算符（==、!=） 用于推进迭代器的前置和后置递增运算符（++） 用于读取元素的解引用运算符（*）；解引用只会出现在赋值运算符的右侧 箭头运算符（-\u0026gt;），等价于(*it).member,即，解引用迭代器，并提取对象的成员 输入迭代器只用于顺序访问。因为递增它可能导致所有其他指向流的迭代器失效。那么将导致不能保证输入迭代器的状态可以保存下来并用来访问元素。\n特性 只读，不写 只能递增 只能用于单遍扫描 算法 find accumulate 迭代器 istream_iterator 输出迭代器（output iterator）：可以看作输入迭代器的补集。\n支持：\n用于推进迭代器的前置和后置递增运算（++） 解引用运算符（*），只出现在赋值运算符的左侧 只能向一个输出迭代器赋值一次。\n特性 只写，不读 只能递增 只能用于单遍扫描 算法 copy（第三个参数） 迭代器 ostream_iterator 前向迭代器（forward iterator）：可以读写元素。只能沿着序列的一个方向移动。\n支持：\n所有输入和输出迭代器的操作\n特性\n可读写 只能递增 可以多遍扫描 算法\nreplace 迭代器\nforward_list上的迭代器 双向迭代器（bidirectional iterator）：可以正向/反向读写序列中的元素。\n支持：\n所有前向迭代器的操作\n前置和后置递增运算符（\u0026ndash;）\n特性\n可读写 可递增递减 可以多遍扫描 算法\nreverse 迭代器\n除了forward_list之外，其他标准库都提供双向迭代器所要求的迭代器 随机访问迭代器（random-access iterator）：提供在常量时间内访问序列中任意元素的能力。\n支持：\n所有双向迭代器操作\n用于比较两个迭代器相对位置的关系运算符（\u0026lt;、\u0026lt;=、\u0026gt;和\u0026gt;=）\n迭代器和一个整数值的加减运算（+、+=、-和-=），计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置。\n用于两个迭代器上的减法运算符（-），得到两个迭代器的距离\n下标运算符（iter[n]，与*(iter[n])等价\n特性\n可读写 支持全部迭代器运算 可以多遍扫描 算法\nsort 迭代器\narray、deque、string和vector的迭代器是随机访问迭代器，用于访问内置数组元素的指针也是 算法形参模式 在任何其他算法之上，还有一组参数规范。理解参数的含义，集中注意力在算法的操作上。\n大多数算法具有如下4种形式之一：\nalg(beg,end,other args) alg(beg,end,dest,other args) alg(beg,end,beg2,other args) alg(beg,end,beg2,end2,other args) dest表示算法可以写入的目的位置的迭代器。算法假定按照其需求写入数据，不管写入多少个都是安全的\n接受单独beg2的算法假定从beg2开始的序列与[beg,end)所表示的范围一样大\n算法命名规范 接受谓词参数来代替\u0026lt;或==运算符的算法，以及那些不接受额外参数的算法，通常都是重载的函数。 1 2 unique(beg,end); // 使用==运算符比较元素 unique(beg,end,comp); // 使用comp比较元素 接受一个元素值的算法通常有另一个不同名的版本，该版本结合搜一个谓词代替元素值。接受谓词参数的算法都有附加的_if前缀。 1 2 find(beg,end,val); // 查找val第一次出现位置 find_if(beg,end,pred); // 查找第一个令pred为真的元素 默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。这种算法一般在名字后附加_copy。 1 2 reverse(beg,end); // 反转输入范围中元素的顺序 reverse_copy(beg,end,dest); // 紧挨能够元素逆序拷贝到dest 10.6 特定容器算法 与其他容器不同，链表类型的list和forward_list定义了几个成员函数形式的算法，因为相较于定义链表类型的通用版本算法，定义链表独有算法代价更低。所以对于链表list和forward_list，应该优先使用成员函数版本的算法而不是通用算法。\nlist和forward_list成员函数版本的算法 解释 list.merge(list2) 将来自list2的元素合并入list。list和list2都必须是有序的 list.merge(list2,comp) 元素将从list2中删除。在合并之后，list2变成空。第一个版本使用\u0026lt;运算符；第二个版本使用给定的比较操作 list.remove(val)list.remove_if(pred) 调用erase删除掉与给定值相等（==）或令一元谓词为真的每个元素 list.reverse() 反转list中元素的顺序 list.sort()list.sort(comp) 使用\u0026lt;或给定比较操作排序元素 list.unique()list.unique(pred) 调用erase删除同一个值的连续拷贝。第一个版本使用==；第二个版本使用给定的二元谓词 splice成员\n链表类型定义了splice算法（其为链表数据结构特有的）。\n参考list.splice(args)或flist_after(args)\nlist和forward_list的splice成员函数的参数 解释 （p,list2) p是一个指向list中元素的迭代器，或一个指向flist首前位置的迭代器。函数将list2的所有元素移动到list中p之前的位置或是flist中p之后的位置。将元素从list2中删除。list2的类型必须与list或flist相同，且不能是同一个链表 (p,list2,p2) p2是一个指向list2中位置的有效的迭代器。将p2指向的元素移动到list中，或将p2之后的元素移动到flist中。list2可以是与list或flist相同的链表 （p,list2,b,e) b和e必须表示list2中的合法范围。将给定范围中的元素从list2移动到list或flist。list2与list（或flist）可以是相同的链表，但p不能指向给定范围中元素 链表特有版本的算法与通用版本之间的一个至关重要的区别是链表版本会改变底层的容器。\n总结 算法、迭代器、链表特定算法\n","date":"2025-04-06T00:00:00Z","image":"https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg","permalink":"https://Free-Aaron-Li.github.io/p/c-%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/","title":"C++ 基础： 第十章 泛型算法"},{"content":"第四章 表达式 前言 本章主要介绍：语言本身定义、并用于内置类型运算对象的运算符。简单介绍：几种标准库定义的运算符。\n表达式本身由一个或多个运算对象组成，其目的是得到一个结果。\n表达式的结构：value operator n*(operation object)\n通过运算符将一个或多个运算对象结合起来便组成了表达式！\n4.1 基础 基本概念 一元运算符（unary operator）、二元运算符（binary operator）和三元运算符（ternary operator）\n解释：\n一元运算符：作用于一个运算对象的运算符，例如：取地址符（\u0026amp;）和解引用符（*） 二元运算符：作用于两个运算对象的运算符，例如：相等运算符（==）和乘法运算符（*） 三元运算符：作用于三个运算对象的运算符，格式为：condition ? expression1 : expression2 补充\n函数调用也是一种特殊的运算符，只不过它对运算对象数量没有限制。\n对于能够充当多种元运算符的运算符，根据上下文判断其属于哪种元运算符,例如：*。\n重载运算符 在这里简单介绍一下重载运算符，重载运算符其实就是对已存在的运算符赋予另一层含义，例如：IO库中的“\u0026lt;\u0026lt;”和“\u0026gt;\u0026gt;”运算符。\n重载运算符会改变运算对象的类型和返回值的类型，但是无法改变运算对象的个数、运算符的优先级和结合律。\n左值和右值 具体查看代码\n优先级和结合律 关键点：\n优先级和结合律决定了运算对象组合的方式 括号无视该规则 表达式依赖于子表达式的结合方式 高优先级的运算对象比低优先级的运算对象更为紧密的组合在一起 算术运算对象满足左结合律 示例：\n1 2 int a=1+2*4/2+6; /* 11 */ int b=(1+2)*4/2+6; /* 12 */ 求值顺序 对于函数的调用来说，求值顺序的不同很有可能会产生不同的结果，甚至是错误！\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int test_number = 1; int test_evaluationOrder_test_1() { return test_number++; } int test_evaluationOrder_test_2() { return test_number += 3; } /** * 求值顺序的探讨 */ void test_evaluationOrder() { int i = 0; /** * \u0026lt;\u0026lt;运算符并未明确规定何时以及如何对运算对象进行求值，没有明确的执行顺序，那么该表达式就是错误的。 * 因为您无法确定是i先执行还是++i先执行，得到的答案不论如何都是错误的 * */ std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; ++i \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; /** * 同理：这下面一句也是错误的。 * 你无法判断是test_1()先执行还是test_2()先执行。 */ int number = test_evaluationOrder_test_1() * test_evaluationOrder_test_2(); std::cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 事实上，除了以下四种运算符明确规定运算对象的求值顺序，其他运算符并没有明确说明：\n逻辑与（\u0026amp;\u0026amp;）运算符 逻辑或（||）运算符 条件（?:）运算符 逗号（,）运算符 这就导致一个问题：这些函数的调用顺序没有明确规定，那么如果某几个函数会影响到同一个对象，那么必然导致结果的不确定性。\n建议\n对于复合表达式而言，有两条经验之谈：\n拿不准最好用括号括起来。\n如果已经改变某个对象的值，那么表达式中就不能再调用能够影响该值的函数。\n4.2 算术运算符 算术运算符分别有：\n+ - ，一元正号（负号） * / % ，乘法、除法、取余 + -，加号、减号 算术运算有时候也会产生未定义的结果，例如除数是0、数据溢出等。\n在取余这里，C++ 11定义有：\nm%(-n)=m%n (-m)%n=-(m%n) 具体示例：\n1 2 3 4 21%6=3; 21/6=3; 21%7=0; 21/7=3; -21%-8=-5; -21/-8=2; 21%-5=1; 21/-5=-4; 4.3 逻辑和关系运算符 关系运算符作用于算术类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型。二者返回值皆为布尔类型。\n其含有：\n!，逻辑非 \u0026lt; \u0026lt;= \u0026gt; \u0026gt;=，小于、小于等于、大于、大于等于 == !=，等于、不等于 \u0026amp;\u0026amp;，逻辑与 ||，逻辑或 注意\n在相等性测试和布尔字面值上，如果想要测试一个算术对象或指针对象的真值，最好的方式是用if语句：if(value)，在这种条件下，编译器会自动将算术对象转换为布尔值并进行判断。\n注意：不要使用if(value==true)的方式进行判断，原因：①、该写法不直观；②、如果value不是布尔值则失去比较意义：如果value不是布尔值，那么首先将true转换为value的类型，如果value不是布尔值，则转换为if(value==1) ，这样的比较是没有意义的。\n综述，如果进行比较运算，如果比较对象不是布尔类型，请不要使用布尔字面值作为运算对象参与比较。\n4.4 赋值运算符 赋值运算符的左侧运算对象必须是一个可修改的左值。\n赋值运算满足右结合律，例如：\n1 2 int rval,lval; rval=lval=0; /* rval和lval的值均为0 */ lval作为靠左赋值运算符的右侧运算对象，赋值运算返回其左侧运算对象，所以靠右的赋值运算的结果被赋值给rval。\n4.5 递增和递减运算符 递增和递减运算符有前置和后置两种方式，其原理：\n前置：将对象本身加/减1后作为左值返回；\n后置：将对象原始值的副本作为右值返回，后再进行对象本身的加/减1；\n建议\n除非必要，在使用递增和递减运算符时一律使用前置方式，使用后置方式会导致不必要的资源浪费，同时前置方式更符合编程初衷。\n4.6 成员访问运算符 成员访问运算符的作用就是访问成员（好像是一句废话😂），成员访问运算符有两种：点运算符（.）和箭头运算符（-\u0026gt;）。二者关系：pointer-\u0026gt;member等价于(*pointer).member。\n对左值和右值的讨论：\n箭头运算符作用于指针类型的运算对象，结果为左值；点运算符取决于作用的运算对象的左值还是右值，依据运算对象的左值右值返回结果。\n注意\n虽然我们在前面我们讨论了箭头运算符和点运算符的关系，但是我们需要注意到点运算符的优先级高于箭头运算符，所以在进行等价转换时一定要记得对指针添加括号：“(*pointer).member”，否则语句无法通过编译。\n4.7 条件运算符 条件运算符可以这样理解：将if-else逻辑嵌入到单个表达式中。\n其结构为：Judgment_Expression ? result1 : result2;\n首先执行语句（“Judgment_Expression”），若结果为真，执行result1并返回结果；否则，执行result2并返回结果。\n若result1和result2都是左值或能转换为一种左值类型，其运算结果为左值，否则为右值。\n条件运算符满足右结合律。\n由于条件运算符的优先值非常低，所以在使用时请加上括号！\n4.8 位运算 在这里引用本书对位运算做出的解释：\n位运算作用于整数类型的运算对象，并把与运算对象看成是二进制位的集合。位运算符提供检查和设置二进制的功能。同时位运算符也能用于bitset类型对象。\n一般来说：如果位运算的运算对象为“小整数”将自动提升为整数类型。位运算的对象可以是带符号的，也可以是不带符号的。但是如果处理带符号且为负数的运算对象，那么其处理操作依赖于机器，所以 强烈建议位运算符用于处理无符号类型对象\n位运算符有：\n运算符 功能 ~ 位求反 \u0026lt;\u0026lt; 左移 \u0026gt;\u0026gt; 右移 \u0026amp; 位与 ^ 位异或 | 位或 首先介绍左移右移位运算符：\n格式为：expr1 \u0026laquo; expr2 或者 expr1 \u0026raquo; expr2\n左侧运算对象作为被位移对象，在完成位移后以其对象拷贝作为求值结果。右侧对象作为位移操作要求，其对象值必须小于左侧对象值，且不能为负数。\n无论是左移还是右移，移出的位都会被舍弃掉。\n左移运算符（\u0026laquo;）是在右侧插入0，右移运算符（\u0026raquo;）根据是否为无符号数判断，若为无符号数，在左侧插入0；若为有符号数，在左侧插入符号位的副本或值为0的二进制位（其根据具体环境判断）。\n位求反运算符：\n将运算对象的每一位都取反。\n位与、位非、位或运算符：\n三者都是根据两个运算对象的对应位进行比较，最终依照比较内容返回结果。\n未与：若二者都为1，则为1。 位或：若二者至少一个为1，则为1。 位异或：若二者仅有一个为1，则为1。 移位运算符满足左结合律。\n4.9 sizeof运算符 sizeof运算符返回一条表达式或一个类型名字所占的字节数。其返回值为size_t类型（一种机器相关的无符号类型）的常量表达式。\nsizeof本身满足右结合律。\n其有两种形式：\n1 2 sizeof (type) sizeof type 第二种形式返回的是表达式结果类型的大小。\n这里引用书中的Sales_data类型：\n1 2 3 4 5 6 Sales_data data,*p; sizeof(Sales_data); /* 存储Sales_data类型的对象所占的空间大小 */ sizeof data; /* data的类型大小，等价于上面的表达式 */ sizeof p; /* 指针所占的空间大小 */ sizeof *p; /* p多指向的对象类型的空间大小，等价于第二个表达式 */ sizeof data.revenue; /* Sales_data的revenue成员对应类型的大小 */ 有关sizeof的部分还有许多特点，详细可见书P139页。\n4.10 逗号运算符 逗号运算符（comma operator）含有两个运算对象，按照从左往右的顺序依次求值。\n对于逗号运算符来说，首先对左侧的表达式求值，然后将求值结果丢弃。真正的结果是右侧表达式的值，如果右侧运算对象为左值，结果也为左值。\n4.11 类型转换 隐式转换（implicit conversion），由编译器自动执行，无需程序员介入或了解的类型转换，在下面的情况中，编译器将会进行该转换方式：\n在大多数情况下，比int类型小的整数值首先提升为较大的整数类型。 在条件中，非布尔类型转换为布尔类型 初始化对象中，初始值转换为变量的类型；在赋值语句中，右侧运算对象转换城左侧运算对象的类型。 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。 函数调用时会发生类型转换。 算术转换 算术转换规则为：将运算符的运算对象转换成最宽的类型。例如：运算对象类型有：int、double，那么将转换为double。\n转换顺序为：首先进行整型提升、之后对符号位进行判断（若某个运算对象的类型是无符号类型，则转换结果依赖于机器中各个整数类型的相对大小）。\n显示转换 显示转换又称为强制类型转换（cast），其本身使用是十分危险的。\n强制类型转换的格式：\n1 2 cast-name \u0026lt;type\u0026gt; (expression); /* cast-name表示转换方式，type表示转换的目标类型，expression表示要转换的值。如果type为引用类型，其结果为左值。 */ ，其中cast-name有四种：static_cast，dynamic_cast，const_cast和reinterpret_cast。\nstatic_cast 对任何具有明确定义的类型转换（不包含底层const），均可使用该转换方式。\n例如：\n1 2 int j=0; double i=static_cast\u0026lt;double\u0026gt;(j); 在之前如果将较大的运算对象转换为较小的运算对象，编译器将会报错或警告，但是执行显式类型转换，警告信息将会被关闭（编译器默认程序员已经知道这样做的坏处结果）。\nconst_cast const_cast只能改变运算对象的底层const。\n如果对象本身不是常量类型，使用强制类型转换获得写权限是合法的，但是如果对象为常量，使用const_cast执行写操作就会产生未定义的后果。\n1 2 const char *pc; char *p=const_cast\u0026lt;char *\u0026gt;(pc); /* 正确，但是通过p写值是未定义的 */ 只有const_cast能够改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。\nreinterpret_cast reinterpret_cast 通常为运算对象的位模式提供较低层次上的重新解释。\n示例：\n1 2 3 int *ip; char *cp=reinterpret_cast\u0026lt;char *\u0026gt;(ip); /* 在这里，本来cp存放的是char类型的指针，经过强制类型转换，其存储的是int类型指针 */ 警告\n使用reinterpret_cast是十分危险的事情（实际上显示转换本身就是危险的事情）。因为该显示转换改变的是对象本身的类型，编译是无法给出任何警告和错误提示的！，如示例，在编译看来cp本身存储的应当是char类型指针，实际上存储的是int类型指针。\n最后，做出警告！\n应当避免使用强制类型转换，因为这样做会干扰正常的类型检查！\n关于旧式类型转换的讨论：\n1 2 type (expression) /* 函数形式的强制类型转换 */ (type) expression /* C语言风格的强制类型转换 */ 在笔者看来，旧式强制类型转换比现今使用的强制类型转换更加难以追踪！\n当我们使用旧式强制类型转换时，编译器会根据合法性进行判断：\n如果，该处的强制类型转换能够使用const_cast和static_cast代替，那么其强制类型转换的行为与对应的现今强制类型转换一致；如果不合法，那么该强制类型转换将会执行reinterpret_cast类似功能，同时其效果与reinterpret_cast一致。\n旧式的强制类型转换更为模糊，更加难以查找bug和跟踪对象。\n","date":"2025-04-06T00:00:00Z","image":"https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg","permalink":"https://Free-Aaron-Li.github.io/p/c-%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%BF%90%E7%AE%97%E7%AC%A6/","title":"C++ 基础： 第四章 运算符"},{"content":"第五章 语句 前言 通常情况下，程序是按照顺序执行。但是仅仅依靠顺序执行无法解决一些复杂问题，所以C++提供一组控制流 （flow-of-control）语句支持更加复杂的执行路径。\n5.1 简单语句 简单语句的三种语句：\n1 2 3 4 5 6 value+5; /* 表达式语句 */ ; /* 空语句 */ while(value\u0026lt;10){ /* 复合语句（块） */ cout\u0026lt;\u0026lt;value\u0026lt;\u0026lt;\u0026#34; \u0026#34;; ++value; } 有一个很好的例子：\n1 2 3 /* 重复读取数据直到到达文件末尾或者遇到换行 */ while(cin\u0026gt;\u0026gt;s \u0026amp;\u0026amp; s!=\u0026#39;\\n\u0026#39;) ; /* 空语句 */ 当语法上只需要一条语句，但是逻辑上需要多条语句时便可以使用复合语句。\n5.2 语句作用域 定义在控制结构当中的变量只在相应语句的内部可见。\n5.3 条件语句 C++提供两种按条件执行的语句。一种是if语句，另一种是switch语句。\nif语句 if语句的形式：\n1 2 3 4 5 6 7 8 if(condition) statement /* if-else形式 */ if(condition) statement else statement2 condition可以是一个表达式，也可以是一个初始化了的变量声明。但都必须用括号括起来。\nswitch语句 当对多个固定选项进行选择时，使用if-else语句就显得冗余，所以C++提出switch语句。\nswitch语句的形式：\n1 2 3 4 5 6 7 8 9 10 switch(condition){ case option1: statement1; case option2: statement2; case optionn: statement3; default: statement4; } 注意点：case标签必须为整型常量表达式，且任意的两个case标签不能相同；default属于特殊的case标签。\n有关case的一个特点，可以将几个case标签写在同一行，用于强调这些case代表的是某个范围的值：\n1 2 3 4 5 6 7 8 9 10 11 char character; int number = 0; std::cin \u0026gt;\u0026gt; character; switch (character) { case \u0026#39;a\u0026#39;: case \u0026#39;b\u0026#39;: case \u0026#39;c\u0026#39;: number++; break; default: std::cout \u0026lt;\u0026lt; \u0026#34;error!\\n\u0026#34;; break; } /* 如果输入的是“a”、“b”、“c”，则返回1，否则返回0 */ std::cout \u0026lt;\u0026lt; \u0026#34;number is \u0026#34; \u0026lt;\u0026lt; number \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 建议\n一般不要遗忘在最后一个case分支上添加break语句，如果有需要，请用注释注明。\n即便不使用default语句，也请定义一个default标签。这样做的目的：表明对switch语句的case分支情况我们已经考虑全面。\n无论是case还是default标签，我们都不应该让其内容为空，哪怕这个分支并未起作用，我们也应该使用空语句或者空块填充内容。\n还有个关于在switch内部的变量定义讨论：\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 bool index = false; switch (index) { case true: std::string file_name; int ival = 0; int jval; break; case false: /* 错误！ */ jval = 0; if (file_name.empty()) {}; break; default: break; } C++规定：不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。\n5.4 迭代语句 迭代语句又叫循环语句，在之前我们了解过三种循环语句：\nwhile() for() do-while() while语句 其形式：\n1 2 while(condition) statement 其条件部分与if语句类型：可以是一个表达式，也可以是一个初始化了的变量声明。\n传统for语句 其形式：\n1 2 for(init-statement;condition;expression) statement 注意点：\nfor循环语句中定义的变量仅在该循环语句中有效 init-statement仅存在一条声明语句（注意不是仅能声明一个对象），但可以有多个对象 for语句头能够省略任何一个语句，即便是全部省略也可以 范围for语句 其形式：\n1 2 for (declaration:expression) statement do while语句 其形式：\n1 2 3 do{ statement } while(condition); 相较于while语句，\ndo-while语句会在进行判断语句之前执行一次statement do-while语句在括号后会添加一个分号 5.5 跳转语句 跳转语句用于中断当前的执行过程，C++语言提供了四种跳转语句：break、continue、goto和return。\nbreak语句 break语句负责终止离它最近的while、do-while、for或switch语句，并从这些语句之后的第一条语句开始继续执行。\ncontinue语句 continue语句负责终止最近循环中当前迭代并立即开始下一次迭代。其与break不同点在于：continue仅能出现在for、while和do-while语句中，除非switch语句被嵌套在前三者之中，否则不能在switch语句中使用continue。\n其中断迭代及下次迭代过程：\n对于while和do-while：终止当前迭代，执行判断条件语句。 对于传统for：终止当前迭代，执行for语句头的expression（注意：不是init-statement）。 对于范围for：终止当前迭代，使用下一个元素初始化循环控制变量。 goto语句 goto语句的作用是从goto语句无条件跳转到同一函数内的另一个语句。\n建议\ngoto用时很爽，用完火葬场💀。由于goto的无条件，在程序开发中如果随时使用goto语句，那么难以对对象进行追踪。建议使用goto语句时其标签与调用点代码行数不超过30行。\ngoto语句其形式为：\n1 goto label; label是用于标识一条语句的标识符。\n带标签语句为一种特殊语句，其形式为在普通语句之前有一个标示符以及一个冒号。\n1 2 3 label: do{ }while(/*...*/); 注意\n标签标示符独立与变量名和其他标示符名，所以标签标示符可以和其他实体的标示符使用同一个名字，但是建议不要这么做，容易导致混乱（除非你对你的代码排版有信心）。\ngoto语句和控制权转向指定的带标签语句必须在同一个函数内。并且，goto语句无法将程序的控制权从变量作用域之外转到作用域之内。\n这里需要考虑goto语句是向前跳还是向后跳：\n如果向前跳，则之前声明的变量定义将会被销毁并重新创建，如果是向后跳，如果后续的变量已经被定义则合法，否则不合法。\n5.6 try语句块和异常处理 异常是指存在于运行时的反常行为。\n异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持：\nthrow表达式，throw用于异常检测。当出现异常，那么throw将会将异常“抛出” try语句块，try-catch语句用于异常处理，当异常被try“抛出”后，执行catch字句用于处理“异常”。因此也被称为“异常处理代码”（exception handler） throw表达式 throw表达式包括：关键字throw和紧跟的表达式。其表达式的类型就是抛出的异常类型。\n例如：\n1 2 3 4 5 int i=2,j=0; if(i/j) throw.runtime_error(\u0026#34;被除数不能为零！\u0026#34;); /* runtime_error是标准库异常类型的一种，定义在stdexcept头文件中。 * 使用该类型，必须初始化。初始化方式为为它提供一个string对象或者C风格字符串。 */ 抛出异常后将终止当前函数，并把控制权转移给能够处理该异常的代码。\ntry语句块 其形式：\n1 2 3 4 5 6 7 try{ program-statement } catch(exception-declaration){ handler-statements } catch(exception-declaration){ handler-statements } // ... catch字句包括三部分：关键字catch、括号内一个对象的声明（称作异常声明，exception declaration）以及一个块。\ntry语句块内的声明变量无法在块外部访问。\n对执行catch语句的讨论：\n当异常被抛出时，首先搜索抛出该异常的函数，如果没有与之匹配的catch字句，该函数将被终止，并在调用该函数的函数中寻找，如果依旧没有找到与之匹配的catch字句，该新函数也将被终止，继续向上搜索，直到找到适合类型的catch字句。\n如果最终依旧没有找到与之匹配的catch字句，程序将转到terminate标准库，该函数的行为和系统有关，一般情况下，执行该函数将导致程序的非正常退出。\n对于没有使用try语句块但是出现异常的函数，系统会调用terminate函数并终止当前程序的执行。\n标准异常 C++标准库定义了一组类，其分别定义在4个头文件中：\nexception 头文件定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外信息 stdexcept 头文件定义了几种常用的异常类 new 头文件定义了bad_alloc异常类型 type_info 头文件定义了bad_cast异常类型 定义的异常类：\n类名 解释 exception 最常见的问题 runtime_error 只有在运行时才能检测出的问题 range_error 运行时错误：生成的结果超出了有意义的至于范围 overflow_error 运行时错误：计算上溢 underflow_error 运行时错误：计算下溢 logic_error 程序逻辑错误 domain_error 逻辑错误：参数对应的结果值不存在 invalid_argument 逻辑错误：无效参数 length_error 逻辑错误：试图创建一个超出该类型最大长度的对象 out_of_range 逻辑错误：使用一个超出有效范围的值 对于exception、bad_alloc和bad_cast对象，我们只能采用默认初始化方式，不允许为这些对象提供初始值。其他的异常类型必须使用string对象或 C风格字符串对象作为初始值初始化，不允许使用默认初始化方式。\n同时，异常类型只定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的const char*。该字符串的目的是提供关于异常的文本信息。what函数返回的C风格字符串内容与异常对象有关，如果该异常类型存在初始值，则what返回该初始值字符串，如果无初始值，其返回内容由编译器决定。\n","date":"2025-04-06T00:00:00Z","image":"https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg","permalink":"https://Free-Aaron-Li.github.io/p/c-%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%AF%AD%E5%8F%A5/","title":"C++ 基础： 第五章 语句"},{"content":"第一章 开始 前言 介绍大部分C++的基础内容：类型、变量、表达式、语句及函数。简单介绍如何编译及运行程序。\n编写一个简单的程序，如编写记录书籍信息的程序，其必然包括一下内容：\n定义变量 进行输入与输出 使用数据结构保存数据 检测两条记录是否存在相同的ISBN 循环处理每条记录 1.1 编写一个简单的C++程序 每一个C++程序都包含一个或多个函数（function），其中一个必须使用main命名。\n1 2 3 int main(){ return 0; } 一个函数的定义包含四个部分，包括返回类型（return type）、函数名（function name）、参数列表（parameter list，运行为空）以及函数体（function body）。\nmain函数的返回类型必须为int，即为整数类型。int类型是一种内置类型 （built-in-type），即语言自身定义的类型。\n函数定义定义的最后一部分为函数体，它是一个以左花括号（curly brace）开始，以右花括号结束的语句块 （block of statements）：\n1 2 3 { return 0; } return用于结束函数的执行，同时会返回一个值。当return语句包括一个值时，此返回值的类型必须与函数的返回类型相同。\n在大多数系统中，main的返回值被用来指示状态。返回值0表示成功，非0的返回值的含义由系统定义，通常用来指出错误类型。\n1.1.1 编译、运行程序 程序源文件命名约定 无论使用的是命令行界面还是IDE(Integrated Developed Environment 集成开发环境)，大多数编译器都要求程序 源码存储在一个或多个文件中。程序文件通常被成为源文件（source file）。文件后缀名用于告诉系统这个文件是一个 C++程序。不同编译器使用不同的后缀名，在接下来笔者一直使用.cpp文件后缀名。\n从命令行运行编译器 在GNU/Linux下使用：\n1 2 3 g++ -o main main.cpp ./main echo $? 使用G++编译器编译main.cpp文件，运行并通过echo $?命令查看返回值结果\n1.2 初识输入输出 C++语言并未定义任何输入输出（IO）语句，取而代之，包含了一个全面的标准库（standard library）来 提供IO机制。\niostrem库，包含两个基础类型istrem和ostream，分别表示输入流和输出流。一个流就是一个字符序列，即从IO设备 读出或写入IO设备的。术语“流（stream）”想要表达的是，随着时间的推移，字符是顺序生成或消耗的。\n标准输入输出对象 标准库定义了4个IO对象。处理输入名为cin的istream类型对象，这个对象被称为标准输入（standard input）。 处理输出，则用cout的ostream类型对象。也被称为标准输出（standard output）。此外，还定义了两个其他ostream 对象，名为cerr和clog。cerr用来输出警告和错误信息，也被称为标准错误（standard error）。clog用来输出程序运行时的一般性信息。\nC++ 中的clog对象是类ostream的对象。它与标准 C 错误输出流stderr相关联。\nclog 和 cerr 都与 stderr 相关联，但它与 cerr 的不同之处在于 clog 中的流被缓冲并且不会自动与 cout 绑定。\n缓冲输出比无缓冲输出更有效。在缓冲输出的情况下，所有输出都保存到一个变量中并一次全部写入磁盘。对于无缓冲的输出，我们必须继续写入磁盘。\n缓冲输出不适用于严重错误。在系统崩溃的情况下，可能会出现输出仍在缓冲区中并且没有写入磁盘并且无法检索错误消息的情况。我们不能在系统崩溃的情况下丢失错误数据，因此即使速度较慢，我们也会继续将严重错误写入磁盘。\nclog 通常用于记录目的。对于非关键事件日志记录，效率更为重要，因此clog优于cerr。\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Enter two numbers: \u0026#34; \u0026lt;\u0026lt; std::endl; int value1=0, value2=0; std::cin \u0026gt;\u0026gt; value1 \u0026gt;\u0026gt; value2; std::cout \u0026lt;\u0026lt; \u0026#34;The sum of \u0026#34; \u0026lt;\u0026lt; value1 \u0026lt;\u0026lt; \u0026#34; and \u0026#34; \u0026lt;\u0026lt; value2 \u0026lt;\u0026lt; \u0026#34; is \u0026#34; \u0026lt;\u0026lt; value1 + value2 \u0026lt;\u0026lt; std::endl; return 0; } 程序第一行告诉编译器需要使用iostream库。尖括号中的名字指出一个头文件（header）。通常情况下，一般将程序的所有 #include指令放在源文件的开始位置。\n向流写入数据 在上述示例中，main的函数体的第一条语句执行了一个表达式（expression）。在C++中，一个表达式产生一个计算结果 ，它由一个或多个运算对象和（通常是）一个运算符组成。这条语句中使用了输出运算符（\u0026laquo; ）在标准输出上打印信息。\n\u0026laquo;运算符接受两个运算对象，左侧对象必须是一个ostream对象，右侧对象是打印的值。此运算符将给定的值写到给定的ostream对象中。 输出运算符的计算结果就是其左侧运算对象。\n在第一条语句中第一个运算符的结果成为第二个运算符的左侧运算对象。这样，我们就可以将输出请求连接起来。\n\u0026quot;Enter two numbers: 为一个字符串字面值常量（string literal），是用一对双引号包围的字符序列。\nendl被称为操纵符（manipulator）的特殊值。写入endl的效果是结束当前行。并将设备关联的 缓冲区（buffer）中的内容刷到设备中 。缓冲刷新操作可以保证到目前为止程序中所产生的所有输出都真正的写入输出流中，而不是仅停留在内存中等待写入流。\n使用标准库中的名字 再看示例，前缀std::指出名字cout和endl是定义在名为std的命名空间（namespace）中的。\n命名空间可以帮助我们避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突。标准库定义的所有名字都在 命名空间std中。\n通过命名空间使用标准库有一个副作用：当使用标准库中的一个名字时，必须显式说明我们想要使用来自命名空间std中的名字。 例如，需要写入std::cout，通过使用作用域运算符（::）来访问标准库中的名字cout。\n从流读取数据 在代码块中语句int value1=0, value2=0。将int类型的变量初始化（initialize）为0。即初始化一个变量，就是在变量创建 的同时为它赋予一个值。建议，每定义的变量都赋予初值。\n1 std::cin\u0026gt;\u0026gt;value1\u0026gt;\u0026gt;value2; 它读入输入数据。输入运算符（\u0026raquo;）与输出运算符类似。它接受一个istream作为其左侧运算对象，接受一个对象作为 其右侧运算对象。它从给定的istream读入数据，并存入给定对象中。与输出运算符类似，输出运算符返回其左侧运算对象作为其计算结果。\n例如：\n1 2 3 4 (std::cin\u0026gt;\u0026gt;value1)\u0026gt;\u0026gt;value2; std::cin\u0026gt;\u0026gt;value1; std::cin\u0026gt;\u0026gt;value2; 上述代码，其第一条语句执行结果等同于第二第三条执行结果。\n1.3 注释简介 注释（comments）。注释可以帮助人类读者理解程序。应该明白的是代码是给人类读的，只是恰好机器能够明白！\n注释通常用于概述算法（算法是一组完成任务的指令），确定变量的用途，或者解释晦涩难懂的代码段。\n当修改代码时，不要忘记同时更新注释！ 因为错误的注释往往比完全没有注释更糟糕！\nC++中注释有两种：\n单行注释，以“//”开头，换行符结束。 多行注释，以界定符“/”开头，“*/”结束。编译器会将“/*/”中所有文本内容忽略掉。 注释界定符可以跨越程序中的多行，但者并不是必须的。 当注释界定符跨越多行时，最好能显式指出其内部的程序行都属于注释的一部分。\n采用的风格是，注释内的每一行都以一个星号开头，从而指出整个范围都是多行注释的一部分。\n程序中通常同时包含两种形式的注释。注释界定符对通常用于多行注释，而双斜线注释常用于半行和单行附注。\n注释界定符不能嵌套，加入我们需要在调试期间注释一些代码，最好的方式是用单行注释方式注释掉代码段的每一行。\n1.4控制流 语句一般是顺序执行的，但程序设计语言提供了多种不同的控制流语句，允许我们写出更为复杂的执行路径。\n1.4.1 while语句 while语句允许反复执行一段代码，直至给定条件为假为止。\nwhile语句的形式为：\n1 2 while (condition) statement while语句的执行过程是交替地检测condition条件和执行关联的语句statement，直至condition为假 停止。所谓条件(condition)就是一个产生真或假的结果的表达式。\n1.4.2 for语句 每个for语句都包含两部分：循环头和循环体。循环头控制循环体的执行次数，它由三部分组成 ：一个初始化语句（init-statement）、一个循环条件（condition）以及一个表达式（expression） 。\n1.4.3 读取数量不定的输入数据 如题：\n编写程序，实线对用户输入的一组数求和。\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; int main(){ int sum=0,value=0; /* 读取数据直到遇到文件尾，计算所有读入的值的和 */ while(std::cin\u0026gt;\u0026gt;value){ sum+=value; } std::cout\u0026lt;\u0026lt;\u0026#34;Sum is: \u0026#34;\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;std::endl; return 0; } while语句中的表达式表示从标准输入读取下一个数，并赋值（保存在）给value。输入运算符返回其左侧运算对象，即std::cin 。因此，其循环条件其实检测的是std::cin。\n当我们使用一个istream对象作为条件时，其效果是检测流的状态。如果流是有效的，那么检测成功。就可以通过while检测。 而当遇见遇见文件解释符（EOF end-of-while），流状态就变为无效。while判断便无法通过。\n其实还可以写成这种情况,就可以使用回车结束当前循环：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; void Exercise_1_4::OutputSum() { int sum = 0, value = 0; while (std::cin \u0026gt;\u0026gt; value) { sum += value; if (std::cin.get()==\u0026#39;\\n\u0026#39;){ break; } } std::cout \u0026lt;\u0026lt; \u0026#34;Sum is: \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; } PS:\n编译器其实无法检测代码是否符合开发者要求，编译器能做的是检测代码形式(form)或者说语法上的错误。\n常见的编译器错误：\n1、语法错误（syntax error）\n2、类型错误（type error）\n3、声明错误（declaration error）\n明白了编译器提供的错误提示就应该马上修改，因为错误往往具有传递效应。同时还需要做到错误修改完成立刻重新 编译。即“编辑-编译-调试”（edit-compile-debug）周期。\n1.4.4 if语句 用于判断表达式的真假\nPS:\nC++程序的缩进和格式\n无论使用什么格式，当做出该代码格式时应该明白为什么要这样做？有什么影响？有什么好处？\n如果明白其格式作用，那么就应该坚持下去，切不可三心二意。\n我的格式清单：\n1、代码长度不超过100个字符\n2、左侧花括号应该与其代码处于同一行（借鉴java）\n3、上下邻居的输出输出运算符应该排列整齐\n1.5 类简介 一个类（class）定义了一个类型，以及与其关联的一组操作。\n类机制是C++最重要的特性之一。C++最初的设计焦点就是能定义使用上像内置类型一样自然的类类型（class type）\n使用类，需要明白三件事：\n类名是什么？\n类在哪里定义？\n类支持什么操作？\n头文件根据其中定义的类的名字来命名。一般通常使用.h后缀名来作为头文件命名，当然也可以使用其他后缀名比如：.H、 .hpp或hxx。标准库头文件通常不带后缀。编译器也不会关心文件名的形式。\n类作者决定了类类型对象上可以使用的所有操作。\n在引入头文件时，在源文件使用尖括号（\u0026lt; \u0026gt;）包围标准头文件，而不属于标准头文件，则用双引号（\u0026quot; \u0026ldquo;）包围。\nPS：\n文件重定向\n文件重定向一般有两种实现三种方式。\n第一种方式：代码内编写\n可以使用函数：freopen()和rdbuf()。\n第二种方式：控制台实现 例如存在main.cpp文件，首先运行文件生成可执行文件（如：mian）\n通过使用“\u0026lt;”和“\u0026gt;”实现重定向，\nmain \u0026lt;in.txt \u0026gt;out.txt\n成员函数（member function）是定义为类的一部分的函数，有时也被称为方法（method）。笔者更愿意称为方法， 原因是类作为C++的高级特性，称呼为方法表明该函数存在于类中，与传统的函数做区分。\n通过使用点运算符（.）用来表示“名为xxx的对象的xxx成员”，例如常见的cin.get()。点运算符只能用于类类型的对象。 其左侧运算对象必须是一个类类型的对象，右侧运算对象必须是该类类型的一个成员名，运算结果为右侧对象指定成员。\n当访问一个成员函数（方法）时，我们想要调用该方法，则需要使用调用运算符（()）。在其内放置实参（argument）列表。\n","date":"2025-04-06T00:00:00Z","image":"https://s3.bmp.ovh/imgs/2024/11/23/f8eb19dce3c8aec6.jpg","permalink":"https://Free-Aaron-Li.github.io/p/c-%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%80%E5%A7%8B/","title":"C++ 基础： 第一章 开始"},{"content":"部署配置 Github Action 配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 name: deploy on: push: branches: - master jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: | hugo -F --cleanDestinationDir mkdir -p public cp -r ./public/* ./ - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.DEPLOY_TOKEN }} EXTERNAL_REPOSITORY: Free-Aaron-Li/blog PUBLISH_BRANCH: master PUBLISH_DIR: ./ commit_message: auto deploy ","date":"2025-04-06T18:44:11+08:00","permalink":"https://Free-Aaron-Li.github.io/p/hugo%E9%83%A8%E7%BD%B2%E8%87%B3github/","title":"Hugo部署至Github"}]